
rtosTest.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006c24  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000016e  00800060  00006c24  00006cb8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000491  008001ce  008001ce  00006e26  2**0
                  ALLOC
  3 .stab         00007254  00000000  00000000  00006e28  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000033a4  00000000  00000000  0000e07c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  00011420  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  000115c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  000117b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  00013bbd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  00014f43  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  0001611c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  000162dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  000165d2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00016f40  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 0a 2a 	jmp	0x5414	; 0x5414 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e2       	ldi	r30, 0x24	; 36
      68:	fc e6       	ldi	r31, 0x6C	; 108
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 3c       	cpi	r26, 0xCE	; 206
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	ae ec       	ldi	r26, 0xCE	; 206
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 35       	cpi	r26, 0x5F	; 95
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 93 26 	call	0x4d26	; 0x4d26 <main>
      8a:	0c 94 10 36 	jmp	0x6c20	; 0x6c20 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 ba 35 	jmp	0x6b74	; 0x6b74 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ab e7       	ldi	r26, 0x7B	; 123
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 d6 35 	jmp	0x6bac	; 0x6bac <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 c6 35 	jmp	0x6b8c	; 0x6b8c <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 e2 35 	jmp	0x6bc4	; 0x6bc4 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 c6 35 	jmp	0x6b8c	; 0x6b8c <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 e2 35 	jmp	0x6bc4	; 0x6bc4 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 ba 35 	jmp	0x6b74	; 0x6b74 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8b e7       	ldi	r24, 0x7B	; 123
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 d6 35 	jmp	0x6bac	; 0x6bac <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 c2 35 	jmp	0x6b84	; 0x6b84 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	6b e7       	ldi	r22, 0x7B	; 123
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 de 35 	jmp	0x6bbc	; 0x6bbc <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 c6 35 	jmp	0x6b8c	; 0x6b8c <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 e2 35 	jmp	0x6bc4	; 0x6bc4 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 c6 35 	jmp	0x6b8c	; 0x6b8c <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 e2 35 	jmp	0x6bc4	; 0x6bc4 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 c6 35 	jmp	0x6b8c	; 0x6b8c <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 e2 35 	jmp	0x6bc4	; 0x6bc4 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 ca 35 	jmp	0x6b94	; 0x6b94 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 e6 35 	jmp	0x6bcc	; 0x6bcc <__epilogue_restores__+0x20>

00000952 <__floatunsisf>:
     952:	a8 e0       	ldi	r26, 0x08	; 8
     954:	b0 e0       	ldi	r27, 0x00	; 0
     956:	ef ea       	ldi	r30, 0xAF	; 175
     958:	f4 e0       	ldi	r31, 0x04	; 4
     95a:	0c 94 c2 35 	jmp	0x6b84	; 0x6b84 <__prologue_saves__+0x10>
     95e:	7b 01       	movw	r14, r22
     960:	8c 01       	movw	r16, r24
     962:	61 15       	cp	r22, r1
     964:	71 05       	cpc	r23, r1
     966:	81 05       	cpc	r24, r1
     968:	91 05       	cpc	r25, r1
     96a:	19 f4       	brne	.+6      	; 0x972 <__floatunsisf+0x20>
     96c:	82 e0       	ldi	r24, 0x02	; 2
     96e:	89 83       	std	Y+1, r24	; 0x01
     970:	60 c0       	rjmp	.+192    	; 0xa32 <__floatunsisf+0xe0>
     972:	83 e0       	ldi	r24, 0x03	; 3
     974:	89 83       	std	Y+1, r24	; 0x01
     976:	8e e1       	ldi	r24, 0x1E	; 30
     978:	c8 2e       	mov	r12, r24
     97a:	d1 2c       	mov	r13, r1
     97c:	dc 82       	std	Y+4, r13	; 0x04
     97e:	cb 82       	std	Y+3, r12	; 0x03
     980:	ed 82       	std	Y+5, r14	; 0x05
     982:	fe 82       	std	Y+6, r15	; 0x06
     984:	0f 83       	std	Y+7, r16	; 0x07
     986:	18 87       	std	Y+8, r17	; 0x08
     988:	c8 01       	movw	r24, r16
     98a:	b7 01       	movw	r22, r14
     98c:	0e 94 22 05 	call	0xa44	; 0xa44 <__clzsi2>
     990:	fc 01       	movw	r30, r24
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	f7 ff       	sbrs	r31, 7
     996:	3b c0       	rjmp	.+118    	; 0xa0e <__floatunsisf+0xbc>
     998:	22 27       	eor	r18, r18
     99a:	33 27       	eor	r19, r19
     99c:	2e 1b       	sub	r18, r30
     99e:	3f 0b       	sbc	r19, r31
     9a0:	57 01       	movw	r10, r14
     9a2:	68 01       	movw	r12, r16
     9a4:	02 2e       	mov	r0, r18
     9a6:	04 c0       	rjmp	.+8      	; 0x9b0 <__floatunsisf+0x5e>
     9a8:	d6 94       	lsr	r13
     9aa:	c7 94       	ror	r12
     9ac:	b7 94       	ror	r11
     9ae:	a7 94       	ror	r10
     9b0:	0a 94       	dec	r0
     9b2:	d2 f7       	brpl	.-12     	; 0x9a8 <__floatunsisf+0x56>
     9b4:	40 e0       	ldi	r20, 0x00	; 0
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	a0 e0       	ldi	r26, 0x00	; 0
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__floatunsisf+0x7c>
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	aa 1f       	adc	r26, r26
     9cc:	bb 1f       	adc	r27, r27
     9ce:	2a 95       	dec	r18
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__floatunsisf+0x74>
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	a1 09       	sbc	r26, r1
     9d6:	b1 09       	sbc	r27, r1
     9d8:	8e 21       	and	r24, r14
     9da:	9f 21       	and	r25, r15
     9dc:	a0 23       	and	r26, r16
     9de:	b1 23       	and	r27, r17
     9e0:	00 97       	sbiw	r24, 0x00	; 0
     9e2:	a1 05       	cpc	r26, r1
     9e4:	b1 05       	cpc	r27, r1
     9e6:	21 f0       	breq	.+8      	; 0x9f0 <__floatunsisf+0x9e>
     9e8:	41 e0       	ldi	r20, 0x01	; 1
     9ea:	50 e0       	ldi	r21, 0x00	; 0
     9ec:	60 e0       	ldi	r22, 0x00	; 0
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	4a 29       	or	r20, r10
     9f2:	5b 29       	or	r21, r11
     9f4:	6c 29       	or	r22, r12
     9f6:	7d 29       	or	r23, r13
     9f8:	4d 83       	std	Y+5, r20	; 0x05
     9fa:	5e 83       	std	Y+6, r21	; 0x06
     9fc:	6f 83       	std	Y+7, r22	; 0x07
     9fe:	78 87       	std	Y+8, r23	; 0x08
     a00:	8e e1       	ldi	r24, 0x1E	; 30
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	8e 1b       	sub	r24, r30
     a06:	9f 0b       	sbc	r25, r31
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	12 c0       	rjmp	.+36     	; 0xa32 <__floatunsisf+0xe0>
     a0e:	30 97       	sbiw	r30, 0x00	; 0
     a10:	81 f0       	breq	.+32     	; 0xa32 <__floatunsisf+0xe0>
     a12:	0e 2e       	mov	r0, r30
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <__floatunsisf+0xcc>
     a16:	ee 0c       	add	r14, r14
     a18:	ff 1c       	adc	r15, r15
     a1a:	00 1f       	adc	r16, r16
     a1c:	11 1f       	adc	r17, r17
     a1e:	0a 94       	dec	r0
     a20:	d2 f7       	brpl	.-12     	; 0xa16 <__floatunsisf+0xc4>
     a22:	ed 82       	std	Y+5, r14	; 0x05
     a24:	fe 82       	std	Y+6, r15	; 0x06
     a26:	0f 83       	std	Y+7, r16	; 0x07
     a28:	18 87       	std	Y+8, r17	; 0x08
     a2a:	ce 1a       	sub	r12, r30
     a2c:	df 0a       	sbc	r13, r31
     a2e:	dc 82       	std	Y+4, r13	; 0x04
     a30:	cb 82       	std	Y+3, r12	; 0x03
     a32:	1a 82       	std	Y+2, r1	; 0x02
     a34:	ce 01       	movw	r24, r28
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     a3c:	28 96       	adiw	r28, 0x08	; 8
     a3e:	ea e0       	ldi	r30, 0x0A	; 10
     a40:	0c 94 de 35 	jmp	0x6bbc	; 0x6bbc <__epilogue_restores__+0x10>

00000a44 <__clzsi2>:
     a44:	ef 92       	push	r14
     a46:	ff 92       	push	r15
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	7b 01       	movw	r14, r22
     a4e:	8c 01       	movw	r16, r24
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	e8 16       	cp	r14, r24
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	f8 06       	cpc	r15, r24
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	08 07       	cpc	r16, r24
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	18 07       	cpc	r17, r24
     a60:	88 f4       	brcc	.+34     	; 0xa84 <__clzsi2+0x40>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	e8 16       	cp	r14, r24
     a66:	f1 04       	cpc	r15, r1
     a68:	01 05       	cpc	r16, r1
     a6a:	11 05       	cpc	r17, r1
     a6c:	31 f0       	breq	.+12     	; 0xa7a <__clzsi2+0x36>
     a6e:	28 f0       	brcs	.+10     	; 0xa7a <__clzsi2+0x36>
     a70:	88 e0       	ldi	r24, 0x08	; 8
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	a0 e0       	ldi	r26, 0x00	; 0
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	17 c0       	rjmp	.+46     	; 0xaa8 <__clzsi2+0x64>
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	a0 e0       	ldi	r26, 0x00	; 0
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	12 c0       	rjmp	.+36     	; 0xaa8 <__clzsi2+0x64>
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	e8 16       	cp	r14, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	f8 06       	cpc	r15, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	08 07       	cpc	r16, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	18 07       	cpc	r17, r24
     a94:	28 f0       	brcs	.+10     	; 0xaa0 <__clzsi2+0x5c>
     a96:	88 e1       	ldi	r24, 0x18	; 24
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__clzsi2+0x64>
     aa0:	80 e1       	ldi	r24, 0x10	; 16
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	a0 e0       	ldi	r26, 0x00	; 0
     aa6:	b0 e0       	ldi	r27, 0x00	; 0
     aa8:	20 e2       	ldi	r18, 0x20	; 32
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	28 1b       	sub	r18, r24
     ab2:	39 0b       	sbc	r19, r25
     ab4:	4a 0b       	sbc	r20, r26
     ab6:	5b 0b       	sbc	r21, r27
     ab8:	04 c0       	rjmp	.+8      	; 0xac2 <__clzsi2+0x7e>
     aba:	16 95       	lsr	r17
     abc:	07 95       	ror	r16
     abe:	f7 94       	ror	r15
     ac0:	e7 94       	ror	r14
     ac2:	8a 95       	dec	r24
     ac4:	d2 f7       	brpl	.-12     	; 0xaba <__clzsi2+0x76>
     ac6:	f7 01       	movw	r30, r14
     ac8:	ed 57       	subi	r30, 0x7D	; 125
     aca:	ff 4f       	sbci	r31, 0xFF	; 255
     acc:	80 81       	ld	r24, Z
     ace:	28 1b       	sub	r18, r24
     ad0:	31 09       	sbc	r19, r1
     ad2:	41 09       	sbc	r20, r1
     ad4:	51 09       	sbc	r21, r1
     ad6:	c9 01       	movw	r24, r18
     ad8:	1f 91       	pop	r17
     ada:	0f 91       	pop	r16
     adc:	ff 90       	pop	r15
     ade:	ef 90       	pop	r14
     ae0:	08 95       	ret

00000ae2 <__pack_f>:
     ae2:	df 92       	push	r13
     ae4:	ef 92       	push	r14
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	fc 01       	movw	r30, r24
     aee:	e4 80       	ldd	r14, Z+4	; 0x04
     af0:	f5 80       	ldd	r15, Z+5	; 0x05
     af2:	06 81       	ldd	r16, Z+6	; 0x06
     af4:	17 81       	ldd	r17, Z+7	; 0x07
     af6:	d1 80       	ldd	r13, Z+1	; 0x01
     af8:	80 81       	ld	r24, Z
     afa:	82 30       	cpi	r24, 0x02	; 2
     afc:	48 f4       	brcc	.+18     	; 0xb10 <__pack_f+0x2e>
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	a0 e1       	ldi	r26, 0x10	; 16
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e8 2a       	or	r14, r24
     b08:	f9 2a       	or	r15, r25
     b0a:	0a 2b       	or	r16, r26
     b0c:	1b 2b       	or	r17, r27
     b0e:	a5 c0       	rjmp	.+330    	; 0xc5a <__pack_f+0x178>
     b10:	84 30       	cpi	r24, 0x04	; 4
     b12:	09 f4       	brne	.+2      	; 0xb16 <__pack_f+0x34>
     b14:	9f c0       	rjmp	.+318    	; 0xc54 <__pack_f+0x172>
     b16:	82 30       	cpi	r24, 0x02	; 2
     b18:	21 f4       	brne	.+8      	; 0xb22 <__pack_f+0x40>
     b1a:	ee 24       	eor	r14, r14
     b1c:	ff 24       	eor	r15, r15
     b1e:	87 01       	movw	r16, r14
     b20:	05 c0       	rjmp	.+10     	; 0xb2c <__pack_f+0x4a>
     b22:	e1 14       	cp	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	01 05       	cpc	r16, r1
     b28:	11 05       	cpc	r17, r1
     b2a:	19 f4       	brne	.+6      	; 0xb32 <__pack_f+0x50>
     b2c:	e0 e0       	ldi	r30, 0x00	; 0
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	96 c0       	rjmp	.+300    	; 0xc5e <__pack_f+0x17c>
     b32:	62 81       	ldd	r22, Z+2	; 0x02
     b34:	73 81       	ldd	r23, Z+3	; 0x03
     b36:	9f ef       	ldi	r25, 0xFF	; 255
     b38:	62 38       	cpi	r22, 0x82	; 130
     b3a:	79 07       	cpc	r23, r25
     b3c:	0c f0       	brlt	.+2      	; 0xb40 <__pack_f+0x5e>
     b3e:	5b c0       	rjmp	.+182    	; 0xbf6 <__pack_f+0x114>
     b40:	22 e8       	ldi	r18, 0x82	; 130
     b42:	3f ef       	ldi	r19, 0xFF	; 255
     b44:	26 1b       	sub	r18, r22
     b46:	37 0b       	sbc	r19, r23
     b48:	2a 31       	cpi	r18, 0x1A	; 26
     b4a:	31 05       	cpc	r19, r1
     b4c:	2c f0       	brlt	.+10     	; 0xb58 <__pack_f+0x76>
     b4e:	20 e0       	ldi	r18, 0x00	; 0
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	2a c0       	rjmp	.+84     	; 0xbac <__pack_f+0xca>
     b58:	b8 01       	movw	r22, r16
     b5a:	a7 01       	movw	r20, r14
     b5c:	02 2e       	mov	r0, r18
     b5e:	04 c0       	rjmp	.+8      	; 0xb68 <__pack_f+0x86>
     b60:	76 95       	lsr	r23
     b62:	67 95       	ror	r22
     b64:	57 95       	ror	r21
     b66:	47 95       	ror	r20
     b68:	0a 94       	dec	r0
     b6a:	d2 f7       	brpl	.-12     	; 0xb60 <__pack_f+0x7e>
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	a0 e0       	ldi	r26, 0x00	; 0
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__pack_f+0x9c>
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	aa 1f       	adc	r26, r26
     b7c:	bb 1f       	adc	r27, r27
     b7e:	2a 95       	dec	r18
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__pack_f+0x94>
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	a1 09       	sbc	r26, r1
     b86:	b1 09       	sbc	r27, r1
     b88:	8e 21       	and	r24, r14
     b8a:	9f 21       	and	r25, r15
     b8c:	a0 23       	and	r26, r16
     b8e:	b1 23       	and	r27, r17
     b90:	00 97       	sbiw	r24, 0x00	; 0
     b92:	a1 05       	cpc	r26, r1
     b94:	b1 05       	cpc	r27, r1
     b96:	21 f0       	breq	.+8      	; 0xba0 <__pack_f+0xbe>
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a0 e0       	ldi	r26, 0x00	; 0
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	9a 01       	movw	r18, r20
     ba2:	ab 01       	movw	r20, r22
     ba4:	28 2b       	or	r18, r24
     ba6:	39 2b       	or	r19, r25
     ba8:	4a 2b       	or	r20, r26
     baa:	5b 2b       	or	r21, r27
     bac:	da 01       	movw	r26, r20
     bae:	c9 01       	movw	r24, r18
     bb0:	8f 77       	andi	r24, 0x7F	; 127
     bb2:	90 70       	andi	r25, 0x00	; 0
     bb4:	a0 70       	andi	r26, 0x00	; 0
     bb6:	b0 70       	andi	r27, 0x00	; 0
     bb8:	80 34       	cpi	r24, 0x40	; 64
     bba:	91 05       	cpc	r25, r1
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	39 f4       	brne	.+14     	; 0xbd0 <__pack_f+0xee>
     bc2:	27 ff       	sbrs	r18, 7
     bc4:	09 c0       	rjmp	.+18     	; 0xbd8 <__pack_f+0xf6>
     bc6:	20 5c       	subi	r18, 0xC0	; 192
     bc8:	3f 4f       	sbci	r19, 0xFF	; 255
     bca:	4f 4f       	sbci	r20, 0xFF	; 255
     bcc:	5f 4f       	sbci	r21, 0xFF	; 255
     bce:	04 c0       	rjmp	.+8      	; 0xbd8 <__pack_f+0xf6>
     bd0:	21 5c       	subi	r18, 0xC1	; 193
     bd2:	3f 4f       	sbci	r19, 0xFF	; 255
     bd4:	4f 4f       	sbci	r20, 0xFF	; 255
     bd6:	5f 4f       	sbci	r21, 0xFF	; 255
     bd8:	e0 e0       	ldi	r30, 0x00	; 0
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	20 30       	cpi	r18, 0x00	; 0
     bde:	a0 e0       	ldi	r26, 0x00	; 0
     be0:	3a 07       	cpc	r19, r26
     be2:	a0 e0       	ldi	r26, 0x00	; 0
     be4:	4a 07       	cpc	r20, r26
     be6:	a0 e4       	ldi	r26, 0x40	; 64
     be8:	5a 07       	cpc	r21, r26
     bea:	10 f0       	brcs	.+4      	; 0xbf0 <__pack_f+0x10e>
     bec:	e1 e0       	ldi	r30, 0x01	; 1
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	79 01       	movw	r14, r18
     bf2:	8a 01       	movw	r16, r20
     bf4:	27 c0       	rjmp	.+78     	; 0xc44 <__pack_f+0x162>
     bf6:	60 38       	cpi	r22, 0x80	; 128
     bf8:	71 05       	cpc	r23, r1
     bfa:	64 f5       	brge	.+88     	; 0xc54 <__pack_f+0x172>
     bfc:	fb 01       	movw	r30, r22
     bfe:	e1 58       	subi	r30, 0x81	; 129
     c00:	ff 4f       	sbci	r31, 0xFF	; 255
     c02:	d8 01       	movw	r26, r16
     c04:	c7 01       	movw	r24, r14
     c06:	8f 77       	andi	r24, 0x7F	; 127
     c08:	90 70       	andi	r25, 0x00	; 0
     c0a:	a0 70       	andi	r26, 0x00	; 0
     c0c:	b0 70       	andi	r27, 0x00	; 0
     c0e:	80 34       	cpi	r24, 0x40	; 64
     c10:	91 05       	cpc	r25, r1
     c12:	a1 05       	cpc	r26, r1
     c14:	b1 05       	cpc	r27, r1
     c16:	39 f4       	brne	.+14     	; 0xc26 <__pack_f+0x144>
     c18:	e7 fe       	sbrs	r14, 7
     c1a:	0d c0       	rjmp	.+26     	; 0xc36 <__pack_f+0x154>
     c1c:	80 e4       	ldi	r24, 0x40	; 64
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	a0 e0       	ldi	r26, 0x00	; 0
     c22:	b0 e0       	ldi	r27, 0x00	; 0
     c24:	04 c0       	rjmp	.+8      	; 0xc2e <__pack_f+0x14c>
     c26:	8f e3       	ldi	r24, 0x3F	; 63
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a0 e0       	ldi	r26, 0x00	; 0
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	e8 0e       	add	r14, r24
     c30:	f9 1e       	adc	r15, r25
     c32:	0a 1f       	adc	r16, r26
     c34:	1b 1f       	adc	r17, r27
     c36:	17 ff       	sbrs	r17, 7
     c38:	05 c0       	rjmp	.+10     	; 0xc44 <__pack_f+0x162>
     c3a:	16 95       	lsr	r17
     c3c:	07 95       	ror	r16
     c3e:	f7 94       	ror	r15
     c40:	e7 94       	ror	r14
     c42:	31 96       	adiw	r30, 0x01	; 1
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	16 95       	lsr	r17
     c48:	07 95       	ror	r16
     c4a:	f7 94       	ror	r15
     c4c:	e7 94       	ror	r14
     c4e:	8a 95       	dec	r24
     c50:	d1 f7       	brne	.-12     	; 0xc46 <__pack_f+0x164>
     c52:	05 c0       	rjmp	.+10     	; 0xc5e <__pack_f+0x17c>
     c54:	ee 24       	eor	r14, r14
     c56:	ff 24       	eor	r15, r15
     c58:	87 01       	movw	r16, r14
     c5a:	ef ef       	ldi	r30, 0xFF	; 255
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	6e 2f       	mov	r22, r30
     c60:	67 95       	ror	r22
     c62:	66 27       	eor	r22, r22
     c64:	67 95       	ror	r22
     c66:	90 2f       	mov	r25, r16
     c68:	9f 77       	andi	r25, 0x7F	; 127
     c6a:	d7 94       	ror	r13
     c6c:	dd 24       	eor	r13, r13
     c6e:	d7 94       	ror	r13
     c70:	8e 2f       	mov	r24, r30
     c72:	86 95       	lsr	r24
     c74:	49 2f       	mov	r20, r25
     c76:	46 2b       	or	r20, r22
     c78:	58 2f       	mov	r21, r24
     c7a:	5d 29       	or	r21, r13
     c7c:	b7 01       	movw	r22, r14
     c7e:	ca 01       	movw	r24, r20
     c80:	1f 91       	pop	r17
     c82:	0f 91       	pop	r16
     c84:	ff 90       	pop	r15
     c86:	ef 90       	pop	r14
     c88:	df 90       	pop	r13
     c8a:	08 95       	ret

00000c8c <__unpack_f>:
     c8c:	fc 01       	movw	r30, r24
     c8e:	db 01       	movw	r26, r22
     c90:	40 81       	ld	r20, Z
     c92:	51 81       	ldd	r21, Z+1	; 0x01
     c94:	22 81       	ldd	r18, Z+2	; 0x02
     c96:	62 2f       	mov	r22, r18
     c98:	6f 77       	andi	r22, 0x7F	; 127
     c9a:	70 e0       	ldi	r23, 0x00	; 0
     c9c:	22 1f       	adc	r18, r18
     c9e:	22 27       	eor	r18, r18
     ca0:	22 1f       	adc	r18, r18
     ca2:	93 81       	ldd	r25, Z+3	; 0x03
     ca4:	89 2f       	mov	r24, r25
     ca6:	88 0f       	add	r24, r24
     ca8:	82 2b       	or	r24, r18
     caa:	28 2f       	mov	r18, r24
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	99 1f       	adc	r25, r25
     cb0:	99 27       	eor	r25, r25
     cb2:	99 1f       	adc	r25, r25
     cb4:	11 96       	adiw	r26, 0x01	; 1
     cb6:	9c 93       	st	X, r25
     cb8:	11 97       	sbiw	r26, 0x01	; 1
     cba:	21 15       	cp	r18, r1
     cbc:	31 05       	cpc	r19, r1
     cbe:	a9 f5       	brne	.+106    	; 0xd2a <__unpack_f+0x9e>
     cc0:	41 15       	cp	r20, r1
     cc2:	51 05       	cpc	r21, r1
     cc4:	61 05       	cpc	r22, r1
     cc6:	71 05       	cpc	r23, r1
     cc8:	11 f4       	brne	.+4      	; 0xcce <__unpack_f+0x42>
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	37 c0       	rjmp	.+110    	; 0xd3c <__unpack_f+0xb0>
     cce:	82 e8       	ldi	r24, 0x82	; 130
     cd0:	9f ef       	ldi	r25, 0xFF	; 255
     cd2:	13 96       	adiw	r26, 0x03	; 3
     cd4:	9c 93       	st	X, r25
     cd6:	8e 93       	st	-X, r24
     cd8:	12 97       	sbiw	r26, 0x02	; 2
     cda:	9a 01       	movw	r18, r20
     cdc:	ab 01       	movw	r20, r22
     cde:	67 e0       	ldi	r22, 0x07	; 7
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	55 1f       	adc	r21, r21
     ce8:	6a 95       	dec	r22
     cea:	d1 f7       	brne	.-12     	; 0xce0 <__unpack_f+0x54>
     cec:	83 e0       	ldi	r24, 0x03	; 3
     cee:	8c 93       	st	X, r24
     cf0:	0d c0       	rjmp	.+26     	; 0xd0c <__unpack_f+0x80>
     cf2:	22 0f       	add	r18, r18
     cf4:	33 1f       	adc	r19, r19
     cf6:	44 1f       	adc	r20, r20
     cf8:	55 1f       	adc	r21, r21
     cfa:	12 96       	adiw	r26, 0x02	; 2
     cfc:	8d 91       	ld	r24, X+
     cfe:	9c 91       	ld	r25, X
     d00:	13 97       	sbiw	r26, 0x03	; 3
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	13 96       	adiw	r26, 0x03	; 3
     d06:	9c 93       	st	X, r25
     d08:	8e 93       	st	-X, r24
     d0a:	12 97       	sbiw	r26, 0x02	; 2
     d0c:	20 30       	cpi	r18, 0x00	; 0
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	38 07       	cpc	r19, r24
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	48 07       	cpc	r20, r24
     d16:	80 e4       	ldi	r24, 0x40	; 64
     d18:	58 07       	cpc	r21, r24
     d1a:	58 f3       	brcs	.-42     	; 0xcf2 <__unpack_f+0x66>
     d1c:	14 96       	adiw	r26, 0x04	; 4
     d1e:	2d 93       	st	X+, r18
     d20:	3d 93       	st	X+, r19
     d22:	4d 93       	st	X+, r20
     d24:	5c 93       	st	X, r21
     d26:	17 97       	sbiw	r26, 0x07	; 7
     d28:	08 95       	ret
     d2a:	2f 3f       	cpi	r18, 0xFF	; 255
     d2c:	31 05       	cpc	r19, r1
     d2e:	79 f4       	brne	.+30     	; 0xd4e <__unpack_f+0xc2>
     d30:	41 15       	cp	r20, r1
     d32:	51 05       	cpc	r21, r1
     d34:	61 05       	cpc	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	19 f4       	brne	.+6      	; 0xd40 <__unpack_f+0xb4>
     d3a:	84 e0       	ldi	r24, 0x04	; 4
     d3c:	8c 93       	st	X, r24
     d3e:	08 95       	ret
     d40:	64 ff       	sbrs	r22, 4
     d42:	03 c0       	rjmp	.+6      	; 0xd4a <__unpack_f+0xbe>
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	8c 93       	st	X, r24
     d48:	12 c0       	rjmp	.+36     	; 0xd6e <__unpack_f+0xe2>
     d4a:	1c 92       	st	X, r1
     d4c:	10 c0       	rjmp	.+32     	; 0xd6e <__unpack_f+0xe2>
     d4e:	2f 57       	subi	r18, 0x7F	; 127
     d50:	30 40       	sbci	r19, 0x00	; 0
     d52:	13 96       	adiw	r26, 0x03	; 3
     d54:	3c 93       	st	X, r19
     d56:	2e 93       	st	-X, r18
     d58:	12 97       	sbiw	r26, 0x02	; 2
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	8c 93       	st	X, r24
     d5e:	87 e0       	ldi	r24, 0x07	; 7
     d60:	44 0f       	add	r20, r20
     d62:	55 1f       	adc	r21, r21
     d64:	66 1f       	adc	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	8a 95       	dec	r24
     d6a:	d1 f7       	brne	.-12     	; 0xd60 <__unpack_f+0xd4>
     d6c:	70 64       	ori	r23, 0x40	; 64
     d6e:	14 96       	adiw	r26, 0x04	; 4
     d70:	4d 93       	st	X+, r20
     d72:	5d 93       	st	X+, r21
     d74:	6d 93       	st	X+, r22
     d76:	7c 93       	st	X, r23
     d78:	17 97       	sbiw	r26, 0x07	; 7
     d7a:	08 95       	ret

00000d7c <__fpcmp_parts_f>:
     d7c:	1f 93       	push	r17
     d7e:	dc 01       	movw	r26, r24
     d80:	fb 01       	movw	r30, r22
     d82:	9c 91       	ld	r25, X
     d84:	92 30       	cpi	r25, 0x02	; 2
     d86:	08 f4       	brcc	.+2      	; 0xd8a <__fpcmp_parts_f+0xe>
     d88:	47 c0       	rjmp	.+142    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d8a:	80 81       	ld	r24, Z
     d8c:	82 30       	cpi	r24, 0x02	; 2
     d8e:	08 f4       	brcc	.+2      	; 0xd92 <__fpcmp_parts_f+0x16>
     d90:	43 c0       	rjmp	.+134    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d92:	94 30       	cpi	r25, 0x04	; 4
     d94:	51 f4       	brne	.+20     	; 0xdaa <__fpcmp_parts_f+0x2e>
     d96:	11 96       	adiw	r26, 0x01	; 1
     d98:	1c 91       	ld	r17, X
     d9a:	84 30       	cpi	r24, 0x04	; 4
     d9c:	99 f5       	brne	.+102    	; 0xe04 <__fpcmp_parts_f+0x88>
     d9e:	81 81       	ldd	r24, Z+1	; 0x01
     da0:	68 2f       	mov	r22, r24
     da2:	70 e0       	ldi	r23, 0x00	; 0
     da4:	61 1b       	sub	r22, r17
     da6:	71 09       	sbc	r23, r1
     da8:	3f c0       	rjmp	.+126    	; 0xe28 <__fpcmp_parts_f+0xac>
     daa:	84 30       	cpi	r24, 0x04	; 4
     dac:	21 f0       	breq	.+8      	; 0xdb6 <__fpcmp_parts_f+0x3a>
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	31 f4       	brne	.+12     	; 0xdbe <__fpcmp_parts_f+0x42>
     db2:	82 30       	cpi	r24, 0x02	; 2
     db4:	b9 f1       	breq	.+110    	; 0xe24 <__fpcmp_parts_f+0xa8>
     db6:	81 81       	ldd	r24, Z+1	; 0x01
     db8:	88 23       	and	r24, r24
     dba:	89 f1       	breq	.+98     	; 0xe1e <__fpcmp_parts_f+0xa2>
     dbc:	2d c0       	rjmp	.+90     	; 0xe18 <__fpcmp_parts_f+0x9c>
     dbe:	11 96       	adiw	r26, 0x01	; 1
     dc0:	1c 91       	ld	r17, X
     dc2:	11 97       	sbiw	r26, 0x01	; 1
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	f1 f0       	breq	.+60     	; 0xe04 <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	18 17       	cp	r17, r24
     dcc:	d9 f4       	brne	.+54     	; 0xe04 <__fpcmp_parts_f+0x88>
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	2d 91       	ld	r18, X+
     dd2:	3c 91       	ld	r19, X
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	82 81       	ldd	r24, Z+2	; 0x02
     dd8:	93 81       	ldd	r25, Z+3	; 0x03
     dda:	82 17       	cp	r24, r18
     ddc:	93 07       	cpc	r25, r19
     dde:	94 f0       	brlt	.+36     	; 0xe04 <__fpcmp_parts_f+0x88>
     de0:	28 17       	cp	r18, r24
     de2:	39 07       	cpc	r19, r25
     de4:	bc f0       	brlt	.+46     	; 0xe14 <__fpcmp_parts_f+0x98>
     de6:	14 96       	adiw	r26, 0x04	; 4
     de8:	8d 91       	ld	r24, X+
     dea:	9d 91       	ld	r25, X+
     dec:	0d 90       	ld	r0, X+
     dee:	bc 91       	ld	r27, X
     df0:	a0 2d       	mov	r26, r0
     df2:	24 81       	ldd	r18, Z+4	; 0x04
     df4:	35 81       	ldd	r19, Z+5	; 0x05
     df6:	46 81       	ldd	r20, Z+6	; 0x06
     df8:	57 81       	ldd	r21, Z+7	; 0x07
     dfa:	28 17       	cp	r18, r24
     dfc:	39 07       	cpc	r19, r25
     dfe:	4a 07       	cpc	r20, r26
     e00:	5b 07       	cpc	r21, r27
     e02:	18 f4       	brcc	.+6      	; 0xe0a <__fpcmp_parts_f+0x8e>
     e04:	11 23       	and	r17, r17
     e06:	41 f0       	breq	.+16     	; 0xe18 <__fpcmp_parts_f+0x9c>
     e08:	0a c0       	rjmp	.+20     	; 0xe1e <__fpcmp_parts_f+0xa2>
     e0a:	82 17       	cp	r24, r18
     e0c:	93 07       	cpc	r25, r19
     e0e:	a4 07       	cpc	r26, r20
     e10:	b5 07       	cpc	r27, r21
     e12:	40 f4       	brcc	.+16     	; 0xe24 <__fpcmp_parts_f+0xa8>
     e14:	11 23       	and	r17, r17
     e16:	19 f0       	breq	.+6      	; 0xe1e <__fpcmp_parts_f+0xa2>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <__fpcmp_parts_f+0xac>
     e1e:	6f ef       	ldi	r22, 0xFF	; 255
     e20:	7f ef       	ldi	r23, 0xFF	; 255
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <__fpcmp_parts_f+0xac>
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	70 e0       	ldi	r23, 0x00	; 0
     e28:	cb 01       	movw	r24, r22
     e2a:	1f 91       	pop	r17
     e2c:	08 95       	ret

00000e2e <DIO_VoidInit>:

/* HAL */

/* Defination Of Function  */
Void DIO_VoidInit(Void)
{
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	cd b7       	in	r28, 0x3d	; 61
     e34:	de b7       	in	r29, 0x3e	; 62

        /* intial direction */

        DDRA__UINT8_REG = CONC(DIO__UINT8_PA7_INITIAL_DIRECTION, DIO__UINT8_PA6_INITIAL_DIRECTION, DIO__UINT8_PA5_INITIAL_DIRECTION, DIO__UINT8_PA4_INITIAL_DIRECTION, DIO__UINT8_PA3_INITIAL_DIRECTION, DIO__UINT8_PA2_INITIAL_DIRECTION, DIO__UINT8_PA1_INITIAL_DIRECTION, DIO__UINT8_PA0_INITIAL_DIRECTION);
     e36:	ea e3       	ldi	r30, 0x3A	; 58
     e38:	f0 e0       	ldi	r31, 0x00	; 0
     e3a:	8f e0       	ldi	r24, 0x0F	; 15
     e3c:	80 83       	st	Z, r24
        DDRB__UINT8_REG = CONC(DIO__UINT8_PB7_INITIAL_DIRECTION, DIO__UINT8_PB6_INITIAL_DIRECTION, DIO__UINT8_PB5_INITIAL_DIRECTION, DIO__UINT8_PB4_INITIAL_DIRECTION, DIO__UINT8_PB3_INITIAL_DIRECTION, DIO__UINT8_PB2_INITIAL_DIRECTION, DIO__UINT8_PB1_INITIAL_DIRECTION, DIO__UINT8_PB0_INITIAL_DIRECTION);
     e3e:	e7 e3       	ldi	r30, 0x37	; 55
     e40:	f0 e0       	ldi	r31, 0x00	; 0
     e42:	10 82       	st	Z, r1
        DDRC__UINT8_REG = CONC(DIO__UINT8_PC7_INITIAL_DIRECTION, DIO__UINT8_PC6_INITIAL_DIRECTION, DIO__UINT8_PC5_INITIAL_DIRECTION, DIO__UINT8_PC4_INITIAL_DIRECTION, DIO__UINT8_PC3_INITIAL_DIRECTION, DIO__UINT8_PC2_INITIAL_DIRECTION, DIO__UINT8_PC1_INITIAL_DIRECTION, DIO__UINT8_PC0_INITIAL_DIRECTION);
     e44:	e4 e3       	ldi	r30, 0x34	; 52
     e46:	f0 e0       	ldi	r31, 0x00	; 0
     e48:	80 ef       	ldi	r24, 0xF0	; 240
     e4a:	80 83       	st	Z, r24
        DDRD__UINT8_REG = CONC(DIO__UINT8_PD7_INITIAL_DIRECTION, DIO__UINT8_PD6_INITIAL_DIRECTION, DIO__UINT8_PD5_INITIAL_DIRECTION, DIO__UINT8_PD4_INITIAL_DIRECTION, DIO__UINT8_PD3_INITIAL_DIRECTION, DIO__UINT8_PD2_INITIAL_DIRECTION, DIO__UINT8_PD1_INITIAL_DIRECTION, DIO__UINT8_PD0_INITIAL_DIRECTION);
     e4c:	e1 e3       	ldi	r30, 0x31	; 49
     e4e:	f0 e0       	ldi	r31, 0x00	; 0
     e50:	87 e0       	ldi	r24, 0x07	; 7
     e52:	80 83       	st	Z, r24

        /* initial Value */

        PORTA__UINT8_REG = CONC(DIO__UINT8_PA7_INITIAL_VALUE, DIO__UINT8_PA6_INITIAL_VALUE, DIO__UINT8_PA5_INITIAL_VALUE, DIO__UINT8_PA4_INITIAL_VALUE, DIO__UINT8_PA3_INITIAL_VALUE, DIO__UINT8_PA2_INITIAL_VALUE, DIO__UINT8_PA1_INITIAL_VALUE, DIO__UINT8_PA0_INITIAL_VALUE);
     e54:	eb e3       	ldi	r30, 0x3B	; 59
     e56:	f0 e0       	ldi	r31, 0x00	; 0
     e58:	10 82       	st	Z, r1
        PORTB__UINT8_REG = CONC(DIO__UINT8_PB7_INITIAL_VALUE, DIO__UINT8_PB6_INITIAL_VALUE, DIO__UINT8_PB5_INITIAL_VALUE, DIO__UINT8_PB4_INITIAL_VALUE, DIO__UINT8_PB3_INITIAL_VALUE, DIO__UINT8_PB2_INITIAL_VALUE, DIO__UINT8_PB1_INITIAL_VALUE, DIO__UINT8_PB0_INITIAL_VALUE);
     e5a:	e8 e3       	ldi	r30, 0x38	; 56
     e5c:	f0 e0       	ldi	r31, 0x00	; 0
     e5e:	10 82       	st	Z, r1
        PORTC__UINT8_REG = CONC(DIO__UINT8_PC7_INITIAL_VALUE, DIO__UINT8_PC6_INITIAL_VALUE, DIO__UINT8_PC5_INITIAL_VALUE, DIO__UINT8_PC4_INITIAL_VALUE, DIO__UINT8_PC3_INITIAL_VALUE, DIO__UINT8_PC2_INITIAL_VALUE, DIO__UINT8_PC1_INITIAL_VALUE, DIO__UINT8_PC0_INITIAL_VALUE);
     e60:	e5 e3       	ldi	r30, 0x35	; 53
     e62:	f0 e0       	ldi	r31, 0x00	; 0
     e64:	10 82       	st	Z, r1
        PORTD__UINT8_REG = CONC(DIO__UINT8_PD7_INITIAL_VALUE, DIO__UINT8_PD6_INITIAL_VALUE, DIO__UINT8_PD5_INITIAL_VALUE, DIO__UINT8_PD4_INITIAL_VALUE, DIO__UINT8_PD3_INITIAL_VALUE, DIO__UINT8_PD2_INITIAL_VALUE, DIO__UINT8_PD1_INITIAL_VALUE, DIO__UINT8_PD0_INITIAL_VALUE);
     e66:	e2 e3       	ldi	r30, 0x32	; 50
     e68:	f0 e0       	ldi	r31, 0x00	; 0
     e6a:	10 82       	st	Z, r1
}
     e6c:	cf 91       	pop	r28
     e6e:	df 91       	pop	r29
     e70:	08 95       	ret

00000e72 <DIO__CheckStatusSetPinDirection>:

CheckStatus DIO__CheckStatusSetPinDirection(_uint8 Copy__uint8PortId, _uint8 Copy__uint8PinId, _uint8 Copy__uint8PinDirection)
{
     e72:	df 93       	push	r29
     e74:	cf 93       	push	r28
     e76:	cd b7       	in	r28, 0x3d	; 61
     e78:	de b7       	in	r29, 0x3e	; 62
     e7a:	2f 97       	sbiw	r28, 0x0f	; 15
     e7c:	0f b6       	in	r0, 0x3f	; 63
     e7e:	f8 94       	cli
     e80:	de bf       	out	0x3e, r29	; 62
     e82:	0f be       	out	0x3f, r0	; 63
     e84:	cd bf       	out	0x3d, r28	; 61
     e86:	8a 83       	std	Y+2, r24	; 0x02
     e88:	6b 83       	std	Y+3, r22	; 0x03
     e8a:	4c 83       	std	Y+4, r20	; 0x04
        CheckStatus Local_CheckStatusReturnStatus = CHECK_SUCCESS;
     e8c:	19 82       	std	Y+1, r1	; 0x01
        /*
        Check 1-Valid PORT Id
              2-Valid Pin  Id
              3-Valid Pin  Direction
        */
        if ((Copy__uint8PortId <= DIO__UINT8_PORTD) && (Copy__uint8PinId <= DIO__UINT8_PIN7) && ((Copy__uint8PinDirection == DIO__UINT8_OUTPUT) || (Copy__uint8PinDirection == DIO__UINT8_INPUT)))
     e8e:	8a 81       	ldd	r24, Y+2	; 0x02
     e90:	84 30       	cpi	r24, 0x04	; 4
     e92:	08 f0       	brcs	.+2      	; 0xe96 <DIO__CheckStatusSetPinDirection+0x24>
     e94:	0e c1       	rjmp	.+540    	; 0x10b2 <DIO__CheckStatusSetPinDirection+0x240>
     e96:	8b 81       	ldd	r24, Y+3	; 0x03
     e98:	88 30       	cpi	r24, 0x08	; 8
     e9a:	08 f0       	brcs	.+2      	; 0xe9e <DIO__CheckStatusSetPinDirection+0x2c>
     e9c:	0a c1       	rjmp	.+532    	; 0x10b2 <DIO__CheckStatusSetPinDirection+0x240>
     e9e:	8c 81       	ldd	r24, Y+4	; 0x04
     ea0:	81 30       	cpi	r24, 0x01	; 1
     ea2:	21 f0       	breq	.+8      	; 0xeac <DIO__CheckStatusSetPinDirection+0x3a>
     ea4:	8c 81       	ldd	r24, Y+4	; 0x04
     ea6:	88 23       	and	r24, r24
     ea8:	09 f0       	breq	.+2      	; 0xeac <DIO__CheckStatusSetPinDirection+0x3a>
     eaa:	03 c1       	rjmp	.+518    	; 0x10b2 <DIO__CheckStatusSetPinDirection+0x240>
        {
                switch (Copy__uint8PortId)
     eac:	8a 81       	ldd	r24, Y+2	; 0x02
     eae:	28 2f       	mov	r18, r24
     eb0:	30 e0       	ldi	r19, 0x00	; 0
     eb2:	3f 87       	std	Y+15, r19	; 0x0f
     eb4:	2e 87       	std	Y+14, r18	; 0x0e
     eb6:	8e 85       	ldd	r24, Y+14	; 0x0e
     eb8:	9f 85       	ldd	r25, Y+15	; 0x0f
     eba:	81 30       	cpi	r24, 0x01	; 1
     ebc:	91 05       	cpc	r25, r1
     ebe:	09 f4       	brne	.+2      	; 0xec2 <DIO__CheckStatusSetPinDirection+0x50>
     ec0:	4f c0       	rjmp	.+158    	; 0xf60 <DIO__CheckStatusSetPinDirection+0xee>
     ec2:	2e 85       	ldd	r18, Y+14	; 0x0e
     ec4:	3f 85       	ldd	r19, Y+15	; 0x0f
     ec6:	22 30       	cpi	r18, 0x02	; 2
     ec8:	31 05       	cpc	r19, r1
     eca:	2c f4       	brge	.+10     	; 0xed6 <DIO__CheckStatusSetPinDirection+0x64>
     ecc:	8e 85       	ldd	r24, Y+14	; 0x0e
     ece:	9f 85       	ldd	r25, Y+15	; 0x0f
     ed0:	00 97       	sbiw	r24, 0x00	; 0
     ed2:	71 f0       	breq	.+28     	; 0xef0 <DIO__CheckStatusSetPinDirection+0x7e>
     ed4:	eb c0       	rjmp	.+470    	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>
     ed6:	2e 85       	ldd	r18, Y+14	; 0x0e
     ed8:	3f 85       	ldd	r19, Y+15	; 0x0f
     eda:	22 30       	cpi	r18, 0x02	; 2
     edc:	31 05       	cpc	r19, r1
     ede:	09 f4       	brne	.+2      	; 0xee2 <DIO__CheckStatusSetPinDirection+0x70>
     ee0:	77 c0       	rjmp	.+238    	; 0xfd0 <DIO__CheckStatusSetPinDirection+0x15e>
     ee2:	8e 85       	ldd	r24, Y+14	; 0x0e
     ee4:	9f 85       	ldd	r25, Y+15	; 0x0f
     ee6:	83 30       	cpi	r24, 0x03	; 3
     ee8:	91 05       	cpc	r25, r1
     eea:	09 f4       	brne	.+2      	; 0xeee <DIO__CheckStatusSetPinDirection+0x7c>
     eec:	a9 c0       	rjmp	.+338    	; 0x1040 <DIO__CheckStatusSetPinDirection+0x1ce>
     eee:	de c0       	rjmp	.+444    	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>
                {
                case DIO__UINT8_PORTA:
                        switch (Copy__uint8PinDirection)
     ef0:	8c 81       	ldd	r24, Y+4	; 0x04
     ef2:	28 2f       	mov	r18, r24
     ef4:	30 e0       	ldi	r19, 0x00	; 0
     ef6:	3d 87       	std	Y+13, r19	; 0x0d
     ef8:	2c 87       	std	Y+12, r18	; 0x0c
     efa:	8c 85       	ldd	r24, Y+12	; 0x0c
     efc:	9d 85       	ldd	r25, Y+13	; 0x0d
     efe:	00 97       	sbiw	r24, 0x00	; 0
     f00:	d1 f0       	breq	.+52     	; 0xf36 <DIO__CheckStatusSetPinDirection+0xc4>
     f02:	2c 85       	ldd	r18, Y+12	; 0x0c
     f04:	3d 85       	ldd	r19, Y+13	; 0x0d
     f06:	21 30       	cpi	r18, 0x01	; 1
     f08:	31 05       	cpc	r19, r1
     f0a:	09 f0       	breq	.+2      	; 0xf0e <DIO__CheckStatusSetPinDirection+0x9c>
     f0c:	cf c0       	rjmp	.+414    	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>
                        {
                        case DIO__UINT8_OUTPUT:
                                SET_BIT(DDRA__UINT8_REG, Copy__uint8PinId);
     f0e:	aa e3       	ldi	r26, 0x3A	; 58
     f10:	b0 e0       	ldi	r27, 0x00	; 0
     f12:	ea e3       	ldi	r30, 0x3A	; 58
     f14:	f0 e0       	ldi	r31, 0x00	; 0
     f16:	80 81       	ld	r24, Z
     f18:	48 2f       	mov	r20, r24
     f1a:	8b 81       	ldd	r24, Y+3	; 0x03
     f1c:	28 2f       	mov	r18, r24
     f1e:	30 e0       	ldi	r19, 0x00	; 0
     f20:	81 e0       	ldi	r24, 0x01	; 1
     f22:	90 e0       	ldi	r25, 0x00	; 0
     f24:	02 2e       	mov	r0, r18
     f26:	02 c0       	rjmp	.+4      	; 0xf2c <DIO__CheckStatusSetPinDirection+0xba>
     f28:	88 0f       	add	r24, r24
     f2a:	99 1f       	adc	r25, r25
     f2c:	0a 94       	dec	r0
     f2e:	e2 f7       	brpl	.-8      	; 0xf28 <DIO__CheckStatusSetPinDirection+0xb6>
     f30:	84 2b       	or	r24, r20
     f32:	8c 93       	st	X, r24
     f34:	bb c0       	rjmp	.+374    	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>
                                break;

                        case DIO__UINT8_INPUT:
                                CLEAR_BIT(DDRA__UINT8_REG, Copy__uint8PinId);
     f36:	aa e3       	ldi	r26, 0x3A	; 58
     f38:	b0 e0       	ldi	r27, 0x00	; 0
     f3a:	ea e3       	ldi	r30, 0x3A	; 58
     f3c:	f0 e0       	ldi	r31, 0x00	; 0
     f3e:	80 81       	ld	r24, Z
     f40:	48 2f       	mov	r20, r24
     f42:	8b 81       	ldd	r24, Y+3	; 0x03
     f44:	28 2f       	mov	r18, r24
     f46:	30 e0       	ldi	r19, 0x00	; 0
     f48:	81 e0       	ldi	r24, 0x01	; 1
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	02 2e       	mov	r0, r18
     f4e:	02 c0       	rjmp	.+4      	; 0xf54 <DIO__CheckStatusSetPinDirection+0xe2>
     f50:	88 0f       	add	r24, r24
     f52:	99 1f       	adc	r25, r25
     f54:	0a 94       	dec	r0
     f56:	e2 f7       	brpl	.-8      	; 0xf50 <DIO__CheckStatusSetPinDirection+0xde>
     f58:	80 95       	com	r24
     f5a:	84 23       	and	r24, r20
     f5c:	8c 93       	st	X, r24
     f5e:	a6 c0       	rjmp	.+332    	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>

                                break;
                        }
                        break;
                case DIO__UINT8_PORTB:
                        switch (Copy__uint8PinDirection)
     f60:	8c 81       	ldd	r24, Y+4	; 0x04
     f62:	28 2f       	mov	r18, r24
     f64:	30 e0       	ldi	r19, 0x00	; 0
     f66:	3b 87       	std	Y+11, r19	; 0x0b
     f68:	2a 87       	std	Y+10, r18	; 0x0a
     f6a:	8a 85       	ldd	r24, Y+10	; 0x0a
     f6c:	9b 85       	ldd	r25, Y+11	; 0x0b
     f6e:	00 97       	sbiw	r24, 0x00	; 0
     f70:	d1 f0       	breq	.+52     	; 0xfa6 <DIO__CheckStatusSetPinDirection+0x134>
     f72:	2a 85       	ldd	r18, Y+10	; 0x0a
     f74:	3b 85       	ldd	r19, Y+11	; 0x0b
     f76:	21 30       	cpi	r18, 0x01	; 1
     f78:	31 05       	cpc	r19, r1
     f7a:	09 f0       	breq	.+2      	; 0xf7e <DIO__CheckStatusSetPinDirection+0x10c>
     f7c:	97 c0       	rjmp	.+302    	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>
                        {
                        case DIO__UINT8_OUTPUT:
                                SET_BIT(DDRB__UINT8_REG, Copy__uint8PinId);
     f7e:	a7 e3       	ldi	r26, 0x37	; 55
     f80:	b0 e0       	ldi	r27, 0x00	; 0
     f82:	e7 e3       	ldi	r30, 0x37	; 55
     f84:	f0 e0       	ldi	r31, 0x00	; 0
     f86:	80 81       	ld	r24, Z
     f88:	48 2f       	mov	r20, r24
     f8a:	8b 81       	ldd	r24, Y+3	; 0x03
     f8c:	28 2f       	mov	r18, r24
     f8e:	30 e0       	ldi	r19, 0x00	; 0
     f90:	81 e0       	ldi	r24, 0x01	; 1
     f92:	90 e0       	ldi	r25, 0x00	; 0
     f94:	02 2e       	mov	r0, r18
     f96:	02 c0       	rjmp	.+4      	; 0xf9c <DIO__CheckStatusSetPinDirection+0x12a>
     f98:	88 0f       	add	r24, r24
     f9a:	99 1f       	adc	r25, r25
     f9c:	0a 94       	dec	r0
     f9e:	e2 f7       	brpl	.-8      	; 0xf98 <DIO__CheckStatusSetPinDirection+0x126>
     fa0:	84 2b       	or	r24, r20
     fa2:	8c 93       	st	X, r24
     fa4:	83 c0       	rjmp	.+262    	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>
                                break;
                        case DIO__UINT8_INPUT:
                                CLEAR_BIT(DDRB__UINT8_REG, Copy__uint8PinId);
     fa6:	a7 e3       	ldi	r26, 0x37	; 55
     fa8:	b0 e0       	ldi	r27, 0x00	; 0
     faa:	e7 e3       	ldi	r30, 0x37	; 55
     fac:	f0 e0       	ldi	r31, 0x00	; 0
     fae:	80 81       	ld	r24, Z
     fb0:	48 2f       	mov	r20, r24
     fb2:	8b 81       	ldd	r24, Y+3	; 0x03
     fb4:	28 2f       	mov	r18, r24
     fb6:	30 e0       	ldi	r19, 0x00	; 0
     fb8:	81 e0       	ldi	r24, 0x01	; 1
     fba:	90 e0       	ldi	r25, 0x00	; 0
     fbc:	02 2e       	mov	r0, r18
     fbe:	02 c0       	rjmp	.+4      	; 0xfc4 <DIO__CheckStatusSetPinDirection+0x152>
     fc0:	88 0f       	add	r24, r24
     fc2:	99 1f       	adc	r25, r25
     fc4:	0a 94       	dec	r0
     fc6:	e2 f7       	brpl	.-8      	; 0xfc0 <DIO__CheckStatusSetPinDirection+0x14e>
     fc8:	80 95       	com	r24
     fca:	84 23       	and	r24, r20
     fcc:	8c 93       	st	X, r24
     fce:	6e c0       	rjmp	.+220    	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>

                                break;
                        }
                        break;
                case DIO__UINT8_PORTC:
                        switch (Copy__uint8PinDirection)
     fd0:	8c 81       	ldd	r24, Y+4	; 0x04
     fd2:	28 2f       	mov	r18, r24
     fd4:	30 e0       	ldi	r19, 0x00	; 0
     fd6:	39 87       	std	Y+9, r19	; 0x09
     fd8:	28 87       	std	Y+8, r18	; 0x08
     fda:	88 85       	ldd	r24, Y+8	; 0x08
     fdc:	99 85       	ldd	r25, Y+9	; 0x09
     fde:	00 97       	sbiw	r24, 0x00	; 0
     fe0:	d1 f0       	breq	.+52     	; 0x1016 <DIO__CheckStatusSetPinDirection+0x1a4>
     fe2:	28 85       	ldd	r18, Y+8	; 0x08
     fe4:	39 85       	ldd	r19, Y+9	; 0x09
     fe6:	21 30       	cpi	r18, 0x01	; 1
     fe8:	31 05       	cpc	r19, r1
     fea:	09 f0       	breq	.+2      	; 0xfee <DIO__CheckStatusSetPinDirection+0x17c>
     fec:	5f c0       	rjmp	.+190    	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>
                        {
                        case DIO__UINT8_OUTPUT:
                                SET_BIT(DDRC__UINT8_REG, Copy__uint8PinId);
     fee:	a4 e3       	ldi	r26, 0x34	; 52
     ff0:	b0 e0       	ldi	r27, 0x00	; 0
     ff2:	e4 e3       	ldi	r30, 0x34	; 52
     ff4:	f0 e0       	ldi	r31, 0x00	; 0
     ff6:	80 81       	ld	r24, Z
     ff8:	48 2f       	mov	r20, r24
     ffa:	8b 81       	ldd	r24, Y+3	; 0x03
     ffc:	28 2f       	mov	r18, r24
     ffe:	30 e0       	ldi	r19, 0x00	; 0
    1000:	81 e0       	ldi	r24, 0x01	; 1
    1002:	90 e0       	ldi	r25, 0x00	; 0
    1004:	02 2e       	mov	r0, r18
    1006:	02 c0       	rjmp	.+4      	; 0x100c <DIO__CheckStatusSetPinDirection+0x19a>
    1008:	88 0f       	add	r24, r24
    100a:	99 1f       	adc	r25, r25
    100c:	0a 94       	dec	r0
    100e:	e2 f7       	brpl	.-8      	; 0x1008 <DIO__CheckStatusSetPinDirection+0x196>
    1010:	84 2b       	or	r24, r20
    1012:	8c 93       	st	X, r24
    1014:	4b c0       	rjmp	.+150    	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>
                                break;
                        case DIO__UINT8_INPUT:
                                CLEAR_BIT(DDRC__UINT8_REG, Copy__uint8PinId);
    1016:	a4 e3       	ldi	r26, 0x34	; 52
    1018:	b0 e0       	ldi	r27, 0x00	; 0
    101a:	e4 e3       	ldi	r30, 0x34	; 52
    101c:	f0 e0       	ldi	r31, 0x00	; 0
    101e:	80 81       	ld	r24, Z
    1020:	48 2f       	mov	r20, r24
    1022:	8b 81       	ldd	r24, Y+3	; 0x03
    1024:	28 2f       	mov	r18, r24
    1026:	30 e0       	ldi	r19, 0x00	; 0
    1028:	81 e0       	ldi	r24, 0x01	; 1
    102a:	90 e0       	ldi	r25, 0x00	; 0
    102c:	02 2e       	mov	r0, r18
    102e:	02 c0       	rjmp	.+4      	; 0x1034 <DIO__CheckStatusSetPinDirection+0x1c2>
    1030:	88 0f       	add	r24, r24
    1032:	99 1f       	adc	r25, r25
    1034:	0a 94       	dec	r0
    1036:	e2 f7       	brpl	.-8      	; 0x1030 <DIO__CheckStatusSetPinDirection+0x1be>
    1038:	80 95       	com	r24
    103a:	84 23       	and	r24, r20
    103c:	8c 93       	st	X, r24
    103e:	36 c0       	rjmp	.+108    	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>

                                break;
                        }
                        break;
                case DIO__UINT8_PORTD:
                        switch (Copy__uint8PinDirection)
    1040:	8c 81       	ldd	r24, Y+4	; 0x04
    1042:	28 2f       	mov	r18, r24
    1044:	30 e0       	ldi	r19, 0x00	; 0
    1046:	3f 83       	std	Y+7, r19	; 0x07
    1048:	2e 83       	std	Y+6, r18	; 0x06
    104a:	8e 81       	ldd	r24, Y+6	; 0x06
    104c:	9f 81       	ldd	r25, Y+7	; 0x07
    104e:	00 97       	sbiw	r24, 0x00	; 0
    1050:	c9 f0       	breq	.+50     	; 0x1084 <DIO__CheckStatusSetPinDirection+0x212>
    1052:	2e 81       	ldd	r18, Y+6	; 0x06
    1054:	3f 81       	ldd	r19, Y+7	; 0x07
    1056:	21 30       	cpi	r18, 0x01	; 1
    1058:	31 05       	cpc	r19, r1
    105a:	41 f5       	brne	.+80     	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>
                        {
                        case DIO__UINT8_OUTPUT:
                                SET_BIT(DDRD__UINT8_REG, Copy__uint8PinId);
    105c:	a1 e3       	ldi	r26, 0x31	; 49
    105e:	b0 e0       	ldi	r27, 0x00	; 0
    1060:	e1 e3       	ldi	r30, 0x31	; 49
    1062:	f0 e0       	ldi	r31, 0x00	; 0
    1064:	80 81       	ld	r24, Z
    1066:	48 2f       	mov	r20, r24
    1068:	8b 81       	ldd	r24, Y+3	; 0x03
    106a:	28 2f       	mov	r18, r24
    106c:	30 e0       	ldi	r19, 0x00	; 0
    106e:	81 e0       	ldi	r24, 0x01	; 1
    1070:	90 e0       	ldi	r25, 0x00	; 0
    1072:	02 2e       	mov	r0, r18
    1074:	02 c0       	rjmp	.+4      	; 0x107a <DIO__CheckStatusSetPinDirection+0x208>
    1076:	88 0f       	add	r24, r24
    1078:	99 1f       	adc	r25, r25
    107a:	0a 94       	dec	r0
    107c:	e2 f7       	brpl	.-8      	; 0x1076 <DIO__CheckStatusSetPinDirection+0x204>
    107e:	84 2b       	or	r24, r20
    1080:	8c 93       	st	X, r24
    1082:	14 c0       	rjmp	.+40     	; 0x10ac <DIO__CheckStatusSetPinDirection+0x23a>
                                break;
                        case DIO__UINT8_INPUT:
                                CLEAR_BIT(DDRD__UINT8_REG, Copy__uint8PinId);
    1084:	a1 e3       	ldi	r26, 0x31	; 49
    1086:	b0 e0       	ldi	r27, 0x00	; 0
    1088:	e1 e3       	ldi	r30, 0x31	; 49
    108a:	f0 e0       	ldi	r31, 0x00	; 0
    108c:	80 81       	ld	r24, Z
    108e:	48 2f       	mov	r20, r24
    1090:	8b 81       	ldd	r24, Y+3	; 0x03
    1092:	28 2f       	mov	r18, r24
    1094:	30 e0       	ldi	r19, 0x00	; 0
    1096:	81 e0       	ldi	r24, 0x01	; 1
    1098:	90 e0       	ldi	r25, 0x00	; 0
    109a:	02 2e       	mov	r0, r18
    109c:	02 c0       	rjmp	.+4      	; 0x10a2 <DIO__CheckStatusSetPinDirection+0x230>
    109e:	88 0f       	add	r24, r24
    10a0:	99 1f       	adc	r25, r25
    10a2:	0a 94       	dec	r0
    10a4:	e2 f7       	brpl	.-8      	; 0x109e <DIO__CheckStatusSetPinDirection+0x22c>
    10a6:	80 95       	com	r24
    10a8:	84 23       	and	r24, r20
    10aa:	8c 93       	st	X, r24
                        break;
                default:
                        /* DO NOTHING */
                        break;
                }
                return Local_CheckStatusReturnStatus;
    10ac:	39 81       	ldd	r19, Y+1	; 0x01
    10ae:	3d 83       	std	Y+5, r19	; 0x05
    10b0:	04 c0       	rjmp	.+8      	; 0x10ba <DIO__CheckStatusSetPinDirection+0x248>
        }
        else
        {
                Local_CheckStatusReturnStatus = CHECK_FAIL;
    10b2:	81 e0       	ldi	r24, 0x01	; 1
    10b4:	89 83       	std	Y+1, r24	; 0x01
                return Local_CheckStatusReturnStatus;
    10b6:	89 81       	ldd	r24, Y+1	; 0x01
    10b8:	8d 83       	std	Y+5, r24	; 0x05
    10ba:	8d 81       	ldd	r24, Y+5	; 0x05
        }
}
    10bc:	2f 96       	adiw	r28, 0x0f	; 15
    10be:	0f b6       	in	r0, 0x3f	; 63
    10c0:	f8 94       	cli
    10c2:	de bf       	out	0x3e, r29	; 62
    10c4:	0f be       	out	0x3f, r0	; 63
    10c6:	cd bf       	out	0x3d, r28	; 61
    10c8:	cf 91       	pop	r28
    10ca:	df 91       	pop	r29
    10cc:	08 95       	ret

000010ce <DIO__CheckStatusSetPinValue>:

CheckStatus DIO__CheckStatusSetPinValue(_uint8 Copy__uint8PortId, _uint8 Copy__uint8PinId, _uint8 Copy__uint8PinValue)
{
    10ce:	df 93       	push	r29
    10d0:	cf 93       	push	r28
    10d2:	cd b7       	in	r28, 0x3d	; 61
    10d4:	de b7       	in	r29, 0x3e	; 62
    10d6:	2f 97       	sbiw	r28, 0x0f	; 15
    10d8:	0f b6       	in	r0, 0x3f	; 63
    10da:	f8 94       	cli
    10dc:	de bf       	out	0x3e, r29	; 62
    10de:	0f be       	out	0x3f, r0	; 63
    10e0:	cd bf       	out	0x3d, r28	; 61
    10e2:	8a 83       	std	Y+2, r24	; 0x02
    10e4:	6b 83       	std	Y+3, r22	; 0x03
    10e6:	4c 83       	std	Y+4, r20	; 0x04
        CheckStatus Local_CheckStatusReturnStatus = CHECK_SUCCESS;
    10e8:	19 82       	std	Y+1, r1	; 0x01
        /*
        Check 1-Valid PORT Id
              2-Valid Pin  Id
              3-Valid Pin  Value 
        */
        if ((Copy__uint8PortId <= DIO__UINT8_PORTD) && (Copy__uint8PinId <= DIO__UINT8_PIN7) && ((Copy__uint8PinValue == DIO__UINT8_HIGH) || (Copy__uint8PinValue == DIO__UINT8_LOW)))
    10ea:	8a 81       	ldd	r24, Y+2	; 0x02
    10ec:	84 30       	cpi	r24, 0x04	; 4
    10ee:	08 f0       	brcs	.+2      	; 0x10f2 <DIO__CheckStatusSetPinValue+0x24>
    10f0:	0e c1       	rjmp	.+540    	; 0x130e <DIO__CheckStatusSetPinValue+0x240>
    10f2:	8b 81       	ldd	r24, Y+3	; 0x03
    10f4:	88 30       	cpi	r24, 0x08	; 8
    10f6:	08 f0       	brcs	.+2      	; 0x10fa <DIO__CheckStatusSetPinValue+0x2c>
    10f8:	0a c1       	rjmp	.+532    	; 0x130e <DIO__CheckStatusSetPinValue+0x240>
    10fa:	8c 81       	ldd	r24, Y+4	; 0x04
    10fc:	81 30       	cpi	r24, 0x01	; 1
    10fe:	21 f0       	breq	.+8      	; 0x1108 <DIO__CheckStatusSetPinValue+0x3a>
    1100:	8c 81       	ldd	r24, Y+4	; 0x04
    1102:	88 23       	and	r24, r24
    1104:	09 f0       	breq	.+2      	; 0x1108 <DIO__CheckStatusSetPinValue+0x3a>
    1106:	03 c1       	rjmp	.+518    	; 0x130e <DIO__CheckStatusSetPinValue+0x240>
        {
                switch (Copy__uint8PortId)
    1108:	8a 81       	ldd	r24, Y+2	; 0x02
    110a:	28 2f       	mov	r18, r24
    110c:	30 e0       	ldi	r19, 0x00	; 0
    110e:	3f 87       	std	Y+15, r19	; 0x0f
    1110:	2e 87       	std	Y+14, r18	; 0x0e
    1112:	8e 85       	ldd	r24, Y+14	; 0x0e
    1114:	9f 85       	ldd	r25, Y+15	; 0x0f
    1116:	81 30       	cpi	r24, 0x01	; 1
    1118:	91 05       	cpc	r25, r1
    111a:	09 f4       	brne	.+2      	; 0x111e <DIO__CheckStatusSetPinValue+0x50>
    111c:	4f c0       	rjmp	.+158    	; 0x11bc <DIO__CheckStatusSetPinValue+0xee>
    111e:	2e 85       	ldd	r18, Y+14	; 0x0e
    1120:	3f 85       	ldd	r19, Y+15	; 0x0f
    1122:	22 30       	cpi	r18, 0x02	; 2
    1124:	31 05       	cpc	r19, r1
    1126:	2c f4       	brge	.+10     	; 0x1132 <DIO__CheckStatusSetPinValue+0x64>
    1128:	8e 85       	ldd	r24, Y+14	; 0x0e
    112a:	9f 85       	ldd	r25, Y+15	; 0x0f
    112c:	00 97       	sbiw	r24, 0x00	; 0
    112e:	71 f0       	breq	.+28     	; 0x114c <DIO__CheckStatusSetPinValue+0x7e>
    1130:	eb c0       	rjmp	.+470    	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>
    1132:	2e 85       	ldd	r18, Y+14	; 0x0e
    1134:	3f 85       	ldd	r19, Y+15	; 0x0f
    1136:	22 30       	cpi	r18, 0x02	; 2
    1138:	31 05       	cpc	r19, r1
    113a:	09 f4       	brne	.+2      	; 0x113e <DIO__CheckStatusSetPinValue+0x70>
    113c:	77 c0       	rjmp	.+238    	; 0x122c <DIO__CheckStatusSetPinValue+0x15e>
    113e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1140:	9f 85       	ldd	r25, Y+15	; 0x0f
    1142:	83 30       	cpi	r24, 0x03	; 3
    1144:	91 05       	cpc	r25, r1
    1146:	09 f4       	brne	.+2      	; 0x114a <DIO__CheckStatusSetPinValue+0x7c>
    1148:	a9 c0       	rjmp	.+338    	; 0x129c <DIO__CheckStatusSetPinValue+0x1ce>
    114a:	de c0       	rjmp	.+444    	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>
                {
                case DIO__UINT8_PORTA:
                        switch (Copy__uint8PinValue)
    114c:	8c 81       	ldd	r24, Y+4	; 0x04
    114e:	28 2f       	mov	r18, r24
    1150:	30 e0       	ldi	r19, 0x00	; 0
    1152:	3d 87       	std	Y+13, r19	; 0x0d
    1154:	2c 87       	std	Y+12, r18	; 0x0c
    1156:	8c 85       	ldd	r24, Y+12	; 0x0c
    1158:	9d 85       	ldd	r25, Y+13	; 0x0d
    115a:	00 97       	sbiw	r24, 0x00	; 0
    115c:	d1 f0       	breq	.+52     	; 0x1192 <DIO__CheckStatusSetPinValue+0xc4>
    115e:	2c 85       	ldd	r18, Y+12	; 0x0c
    1160:	3d 85       	ldd	r19, Y+13	; 0x0d
    1162:	21 30       	cpi	r18, 0x01	; 1
    1164:	31 05       	cpc	r19, r1
    1166:	09 f0       	breq	.+2      	; 0x116a <DIO__CheckStatusSetPinValue+0x9c>
    1168:	cf c0       	rjmp	.+414    	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>
                        {
                        case DIO__UINT8_HIGH:
                                SET_BIT(PORTA__UINT8_REG, Copy__uint8PinId);
    116a:	ab e3       	ldi	r26, 0x3B	; 59
    116c:	b0 e0       	ldi	r27, 0x00	; 0
    116e:	eb e3       	ldi	r30, 0x3B	; 59
    1170:	f0 e0       	ldi	r31, 0x00	; 0
    1172:	80 81       	ld	r24, Z
    1174:	48 2f       	mov	r20, r24
    1176:	8b 81       	ldd	r24, Y+3	; 0x03
    1178:	28 2f       	mov	r18, r24
    117a:	30 e0       	ldi	r19, 0x00	; 0
    117c:	81 e0       	ldi	r24, 0x01	; 1
    117e:	90 e0       	ldi	r25, 0x00	; 0
    1180:	02 2e       	mov	r0, r18
    1182:	02 c0       	rjmp	.+4      	; 0x1188 <DIO__CheckStatusSetPinValue+0xba>
    1184:	88 0f       	add	r24, r24
    1186:	99 1f       	adc	r25, r25
    1188:	0a 94       	dec	r0
    118a:	e2 f7       	brpl	.-8      	; 0x1184 <DIO__CheckStatusSetPinValue+0xb6>
    118c:	84 2b       	or	r24, r20
    118e:	8c 93       	st	X, r24
    1190:	bb c0       	rjmp	.+374    	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>
                                break;
                        case DIO__UINT8_LOW:
                                CLEAR_BIT(PORTA__UINT8_REG, Copy__uint8PinId);
    1192:	ab e3       	ldi	r26, 0x3B	; 59
    1194:	b0 e0       	ldi	r27, 0x00	; 0
    1196:	eb e3       	ldi	r30, 0x3B	; 59
    1198:	f0 e0       	ldi	r31, 0x00	; 0
    119a:	80 81       	ld	r24, Z
    119c:	48 2f       	mov	r20, r24
    119e:	8b 81       	ldd	r24, Y+3	; 0x03
    11a0:	28 2f       	mov	r18, r24
    11a2:	30 e0       	ldi	r19, 0x00	; 0
    11a4:	81 e0       	ldi	r24, 0x01	; 1
    11a6:	90 e0       	ldi	r25, 0x00	; 0
    11a8:	02 2e       	mov	r0, r18
    11aa:	02 c0       	rjmp	.+4      	; 0x11b0 <DIO__CheckStatusSetPinValue+0xe2>
    11ac:	88 0f       	add	r24, r24
    11ae:	99 1f       	adc	r25, r25
    11b0:	0a 94       	dec	r0
    11b2:	e2 f7       	brpl	.-8      	; 0x11ac <DIO__CheckStatusSetPinValue+0xde>
    11b4:	80 95       	com	r24
    11b6:	84 23       	and	r24, r20
    11b8:	8c 93       	st	X, r24
    11ba:	a6 c0       	rjmp	.+332    	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>

                                break;
                        }
                        break;
                case DIO__UINT8_PORTB:
                        switch (Copy__uint8PinValue)
    11bc:	8c 81       	ldd	r24, Y+4	; 0x04
    11be:	28 2f       	mov	r18, r24
    11c0:	30 e0       	ldi	r19, 0x00	; 0
    11c2:	3b 87       	std	Y+11, r19	; 0x0b
    11c4:	2a 87       	std	Y+10, r18	; 0x0a
    11c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    11c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    11ca:	00 97       	sbiw	r24, 0x00	; 0
    11cc:	d1 f0       	breq	.+52     	; 0x1202 <DIO__CheckStatusSetPinValue+0x134>
    11ce:	2a 85       	ldd	r18, Y+10	; 0x0a
    11d0:	3b 85       	ldd	r19, Y+11	; 0x0b
    11d2:	21 30       	cpi	r18, 0x01	; 1
    11d4:	31 05       	cpc	r19, r1
    11d6:	09 f0       	breq	.+2      	; 0x11da <DIO__CheckStatusSetPinValue+0x10c>
    11d8:	97 c0       	rjmp	.+302    	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>
                        {
                        case DIO__UINT8_HIGH:
                                SET_BIT(PORTB__UINT8_REG, Copy__uint8PinId);
    11da:	a8 e3       	ldi	r26, 0x38	; 56
    11dc:	b0 e0       	ldi	r27, 0x00	; 0
    11de:	e8 e3       	ldi	r30, 0x38	; 56
    11e0:	f0 e0       	ldi	r31, 0x00	; 0
    11e2:	80 81       	ld	r24, Z
    11e4:	48 2f       	mov	r20, r24
    11e6:	8b 81       	ldd	r24, Y+3	; 0x03
    11e8:	28 2f       	mov	r18, r24
    11ea:	30 e0       	ldi	r19, 0x00	; 0
    11ec:	81 e0       	ldi	r24, 0x01	; 1
    11ee:	90 e0       	ldi	r25, 0x00	; 0
    11f0:	02 2e       	mov	r0, r18
    11f2:	02 c0       	rjmp	.+4      	; 0x11f8 <DIO__CheckStatusSetPinValue+0x12a>
    11f4:	88 0f       	add	r24, r24
    11f6:	99 1f       	adc	r25, r25
    11f8:	0a 94       	dec	r0
    11fa:	e2 f7       	brpl	.-8      	; 0x11f4 <DIO__CheckStatusSetPinValue+0x126>
    11fc:	84 2b       	or	r24, r20
    11fe:	8c 93       	st	X, r24
    1200:	83 c0       	rjmp	.+262    	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>
                                break;
                        case DIO__UINT8_LOW:
                                CLEAR_BIT(PORTB__UINT8_REG, Copy__uint8PinId);
    1202:	a8 e3       	ldi	r26, 0x38	; 56
    1204:	b0 e0       	ldi	r27, 0x00	; 0
    1206:	e8 e3       	ldi	r30, 0x38	; 56
    1208:	f0 e0       	ldi	r31, 0x00	; 0
    120a:	80 81       	ld	r24, Z
    120c:	48 2f       	mov	r20, r24
    120e:	8b 81       	ldd	r24, Y+3	; 0x03
    1210:	28 2f       	mov	r18, r24
    1212:	30 e0       	ldi	r19, 0x00	; 0
    1214:	81 e0       	ldi	r24, 0x01	; 1
    1216:	90 e0       	ldi	r25, 0x00	; 0
    1218:	02 2e       	mov	r0, r18
    121a:	02 c0       	rjmp	.+4      	; 0x1220 <DIO__CheckStatusSetPinValue+0x152>
    121c:	88 0f       	add	r24, r24
    121e:	99 1f       	adc	r25, r25
    1220:	0a 94       	dec	r0
    1222:	e2 f7       	brpl	.-8      	; 0x121c <DIO__CheckStatusSetPinValue+0x14e>
    1224:	80 95       	com	r24
    1226:	84 23       	and	r24, r20
    1228:	8c 93       	st	X, r24
    122a:	6e c0       	rjmp	.+220    	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>

                                break;
                        }
                        break;
                case DIO__UINT8_PORTC:
                        switch (Copy__uint8PinValue)
    122c:	8c 81       	ldd	r24, Y+4	; 0x04
    122e:	28 2f       	mov	r18, r24
    1230:	30 e0       	ldi	r19, 0x00	; 0
    1232:	39 87       	std	Y+9, r19	; 0x09
    1234:	28 87       	std	Y+8, r18	; 0x08
    1236:	88 85       	ldd	r24, Y+8	; 0x08
    1238:	99 85       	ldd	r25, Y+9	; 0x09
    123a:	00 97       	sbiw	r24, 0x00	; 0
    123c:	d1 f0       	breq	.+52     	; 0x1272 <DIO__CheckStatusSetPinValue+0x1a4>
    123e:	28 85       	ldd	r18, Y+8	; 0x08
    1240:	39 85       	ldd	r19, Y+9	; 0x09
    1242:	21 30       	cpi	r18, 0x01	; 1
    1244:	31 05       	cpc	r19, r1
    1246:	09 f0       	breq	.+2      	; 0x124a <DIO__CheckStatusSetPinValue+0x17c>
    1248:	5f c0       	rjmp	.+190    	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>
                        {
                        case DIO__UINT8_HIGH:
                                SET_BIT(PORTC__UINT8_REG, Copy__uint8PinId);
    124a:	a5 e3       	ldi	r26, 0x35	; 53
    124c:	b0 e0       	ldi	r27, 0x00	; 0
    124e:	e5 e3       	ldi	r30, 0x35	; 53
    1250:	f0 e0       	ldi	r31, 0x00	; 0
    1252:	80 81       	ld	r24, Z
    1254:	48 2f       	mov	r20, r24
    1256:	8b 81       	ldd	r24, Y+3	; 0x03
    1258:	28 2f       	mov	r18, r24
    125a:	30 e0       	ldi	r19, 0x00	; 0
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	02 2e       	mov	r0, r18
    1262:	02 c0       	rjmp	.+4      	; 0x1268 <DIO__CheckStatusSetPinValue+0x19a>
    1264:	88 0f       	add	r24, r24
    1266:	99 1f       	adc	r25, r25
    1268:	0a 94       	dec	r0
    126a:	e2 f7       	brpl	.-8      	; 0x1264 <DIO__CheckStatusSetPinValue+0x196>
    126c:	84 2b       	or	r24, r20
    126e:	8c 93       	st	X, r24
    1270:	4b c0       	rjmp	.+150    	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>
                                break;
                        case DIO__UINT8_LOW:
                                CLEAR_BIT(PORTC__UINT8_REG, Copy__uint8PinId);
    1272:	a5 e3       	ldi	r26, 0x35	; 53
    1274:	b0 e0       	ldi	r27, 0x00	; 0
    1276:	e5 e3       	ldi	r30, 0x35	; 53
    1278:	f0 e0       	ldi	r31, 0x00	; 0
    127a:	80 81       	ld	r24, Z
    127c:	48 2f       	mov	r20, r24
    127e:	8b 81       	ldd	r24, Y+3	; 0x03
    1280:	28 2f       	mov	r18, r24
    1282:	30 e0       	ldi	r19, 0x00	; 0
    1284:	81 e0       	ldi	r24, 0x01	; 1
    1286:	90 e0       	ldi	r25, 0x00	; 0
    1288:	02 2e       	mov	r0, r18
    128a:	02 c0       	rjmp	.+4      	; 0x1290 <DIO__CheckStatusSetPinValue+0x1c2>
    128c:	88 0f       	add	r24, r24
    128e:	99 1f       	adc	r25, r25
    1290:	0a 94       	dec	r0
    1292:	e2 f7       	brpl	.-8      	; 0x128c <DIO__CheckStatusSetPinValue+0x1be>
    1294:	80 95       	com	r24
    1296:	84 23       	and	r24, r20
    1298:	8c 93       	st	X, r24
    129a:	36 c0       	rjmp	.+108    	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>

                                break;
                        }
                        break;
                case DIO__UINT8_PORTD:
                        switch (Copy__uint8PinValue)
    129c:	8c 81       	ldd	r24, Y+4	; 0x04
    129e:	28 2f       	mov	r18, r24
    12a0:	30 e0       	ldi	r19, 0x00	; 0
    12a2:	3f 83       	std	Y+7, r19	; 0x07
    12a4:	2e 83       	std	Y+6, r18	; 0x06
    12a6:	8e 81       	ldd	r24, Y+6	; 0x06
    12a8:	9f 81       	ldd	r25, Y+7	; 0x07
    12aa:	00 97       	sbiw	r24, 0x00	; 0
    12ac:	c9 f0       	breq	.+50     	; 0x12e0 <DIO__CheckStatusSetPinValue+0x212>
    12ae:	2e 81       	ldd	r18, Y+6	; 0x06
    12b0:	3f 81       	ldd	r19, Y+7	; 0x07
    12b2:	21 30       	cpi	r18, 0x01	; 1
    12b4:	31 05       	cpc	r19, r1
    12b6:	41 f5       	brne	.+80     	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>
                        {
                        case DIO__UINT8_HIGH:
                                SET_BIT(PORTD__UINT8_REG, Copy__uint8PinId);
    12b8:	a2 e3       	ldi	r26, 0x32	; 50
    12ba:	b0 e0       	ldi	r27, 0x00	; 0
    12bc:	e2 e3       	ldi	r30, 0x32	; 50
    12be:	f0 e0       	ldi	r31, 0x00	; 0
    12c0:	80 81       	ld	r24, Z
    12c2:	48 2f       	mov	r20, r24
    12c4:	8b 81       	ldd	r24, Y+3	; 0x03
    12c6:	28 2f       	mov	r18, r24
    12c8:	30 e0       	ldi	r19, 0x00	; 0
    12ca:	81 e0       	ldi	r24, 0x01	; 1
    12cc:	90 e0       	ldi	r25, 0x00	; 0
    12ce:	02 2e       	mov	r0, r18
    12d0:	02 c0       	rjmp	.+4      	; 0x12d6 <DIO__CheckStatusSetPinValue+0x208>
    12d2:	88 0f       	add	r24, r24
    12d4:	99 1f       	adc	r25, r25
    12d6:	0a 94       	dec	r0
    12d8:	e2 f7       	brpl	.-8      	; 0x12d2 <DIO__CheckStatusSetPinValue+0x204>
    12da:	84 2b       	or	r24, r20
    12dc:	8c 93       	st	X, r24
    12de:	14 c0       	rjmp	.+40     	; 0x1308 <DIO__CheckStatusSetPinValue+0x23a>
                                break;
                        case DIO__UINT8_LOW:
                                CLEAR_BIT(PORTD__UINT8_REG, Copy__uint8PinId);
    12e0:	a2 e3       	ldi	r26, 0x32	; 50
    12e2:	b0 e0       	ldi	r27, 0x00	; 0
    12e4:	e2 e3       	ldi	r30, 0x32	; 50
    12e6:	f0 e0       	ldi	r31, 0x00	; 0
    12e8:	80 81       	ld	r24, Z
    12ea:	48 2f       	mov	r20, r24
    12ec:	8b 81       	ldd	r24, Y+3	; 0x03
    12ee:	28 2f       	mov	r18, r24
    12f0:	30 e0       	ldi	r19, 0x00	; 0
    12f2:	81 e0       	ldi	r24, 0x01	; 1
    12f4:	90 e0       	ldi	r25, 0x00	; 0
    12f6:	02 2e       	mov	r0, r18
    12f8:	02 c0       	rjmp	.+4      	; 0x12fe <DIO__CheckStatusSetPinValue+0x230>
    12fa:	88 0f       	add	r24, r24
    12fc:	99 1f       	adc	r25, r25
    12fe:	0a 94       	dec	r0
    1300:	e2 f7       	brpl	.-8      	; 0x12fa <DIO__CheckStatusSetPinValue+0x22c>
    1302:	80 95       	com	r24
    1304:	84 23       	and	r24, r20
    1306:	8c 93       	st	X, r24
                        break;
                default:
                        /* DO NOTHING */
                        break;
                }
                return Local_CheckStatusReturnStatus;
    1308:	39 81       	ldd	r19, Y+1	; 0x01
    130a:	3d 83       	std	Y+5, r19	; 0x05
    130c:	04 c0       	rjmp	.+8      	; 0x1316 <DIO__CheckStatusSetPinValue+0x248>
        }
        else
        {
                Local_CheckStatusReturnStatus = CHECK_FAIL;
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	89 83       	std	Y+1, r24	; 0x01
                return Local_CheckStatusReturnStatus;
    1312:	89 81       	ldd	r24, Y+1	; 0x01
    1314:	8d 83       	std	Y+5, r24	; 0x05
    1316:	8d 81       	ldd	r24, Y+5	; 0x05
        }
}
    1318:	2f 96       	adiw	r28, 0x0f	; 15
    131a:	0f b6       	in	r0, 0x3f	; 63
    131c:	f8 94       	cli
    131e:	de bf       	out	0x3e, r29	; 62
    1320:	0f be       	out	0x3f, r0	; 63
    1322:	cd bf       	out	0x3d, r28	; 61
    1324:	cf 91       	pop	r28
    1326:	df 91       	pop	r29
    1328:	08 95       	ret

0000132a <DIO__CheckStatusGetPinValue>:

CheckStatus DIO__CheckStatusGetPinValue(_uint8 Copy__uint8PortId, _uint8 Copy__uint8PinId, _uint8 *Copy_p_uint8ReturnPinValue)
{
    132a:	df 93       	push	r29
    132c:	cf 93       	push	r28
    132e:	cd b7       	in	r28, 0x3d	; 61
    1330:	de b7       	in	r29, 0x3e	; 62
    1332:	28 97       	sbiw	r28, 0x08	; 8
    1334:	0f b6       	in	r0, 0x3f	; 63
    1336:	f8 94       	cli
    1338:	de bf       	out	0x3e, r29	; 62
    133a:	0f be       	out	0x3f, r0	; 63
    133c:	cd bf       	out	0x3d, r28	; 61
    133e:	8a 83       	std	Y+2, r24	; 0x02
    1340:	6b 83       	std	Y+3, r22	; 0x03
    1342:	5d 83       	std	Y+5, r21	; 0x05
    1344:	4c 83       	std	Y+4, r20	; 0x04

        CheckStatus Local_CheckStatusReturnStatus = CHECK_SUCCESS;
    1346:	19 82       	std	Y+1, r1	; 0x01
        /*
        Check 1-Valid PORT Id
              2-Valid Pin  Id
              3-Valid Pointer != NULL
        */
        if ((Copy__uint8PortId <= DIO__UINT8_PORTD) && (Copy__uint8PinId <= DIO__UINT8_PIN7) && (Copy_p_uint8ReturnPinValue != NULL))
    1348:	8a 81       	ldd	r24, Y+2	; 0x02
    134a:	84 30       	cpi	r24, 0x04	; 4
    134c:	08 f0       	brcs	.+2      	; 0x1350 <DIO__CheckStatusGetPinValue+0x26>
    134e:	ec c0       	rjmp	.+472    	; 0x1528 <DIO__CheckStatusGetPinValue+0x1fe>
    1350:	8b 81       	ldd	r24, Y+3	; 0x03
    1352:	88 30       	cpi	r24, 0x08	; 8
    1354:	08 f0       	brcs	.+2      	; 0x1358 <DIO__CheckStatusGetPinValue+0x2e>
    1356:	e8 c0       	rjmp	.+464    	; 0x1528 <DIO__CheckStatusGetPinValue+0x1fe>
    1358:	8c 81       	ldd	r24, Y+4	; 0x04
    135a:	9d 81       	ldd	r25, Y+5	; 0x05
    135c:	00 97       	sbiw	r24, 0x00	; 0
    135e:	09 f4       	brne	.+2      	; 0x1362 <DIO__CheckStatusGetPinValue+0x38>
    1360:	e3 c0       	rjmp	.+454    	; 0x1528 <DIO__CheckStatusGetPinValue+0x1fe>
        {
                switch (Copy__uint8PortId)
    1362:	8a 81       	ldd	r24, Y+2	; 0x02
    1364:	28 2f       	mov	r18, r24
    1366:	30 e0       	ldi	r19, 0x00	; 0
    1368:	38 87       	std	Y+8, r19	; 0x08
    136a:	2f 83       	std	Y+7, r18	; 0x07
    136c:	4f 81       	ldd	r20, Y+7	; 0x07
    136e:	58 85       	ldd	r21, Y+8	; 0x08
    1370:	41 30       	cpi	r20, 0x01	; 1
    1372:	51 05       	cpc	r21, r1
    1374:	09 f4       	brne	.+2      	; 0x1378 <DIO__CheckStatusGetPinValue+0x4e>
    1376:	48 c0       	rjmp	.+144    	; 0x1408 <DIO__CheckStatusGetPinValue+0xde>
    1378:	8f 81       	ldd	r24, Y+7	; 0x07
    137a:	98 85       	ldd	r25, Y+8	; 0x08
    137c:	82 30       	cpi	r24, 0x02	; 2
    137e:	91 05       	cpc	r25, r1
    1380:	34 f4       	brge	.+12     	; 0x138e <DIO__CheckStatusGetPinValue+0x64>
    1382:	2f 81       	ldd	r18, Y+7	; 0x07
    1384:	38 85       	ldd	r19, Y+8	; 0x08
    1386:	21 15       	cp	r18, r1
    1388:	31 05       	cpc	r19, r1
    138a:	71 f0       	breq	.+28     	; 0x13a8 <DIO__CheckStatusGetPinValue+0x7e>
    138c:	ca c0       	rjmp	.+404    	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>
    138e:	4f 81       	ldd	r20, Y+7	; 0x07
    1390:	58 85       	ldd	r21, Y+8	; 0x08
    1392:	42 30       	cpi	r20, 0x02	; 2
    1394:	51 05       	cpc	r21, r1
    1396:	09 f4       	brne	.+2      	; 0x139a <DIO__CheckStatusGetPinValue+0x70>
    1398:	67 c0       	rjmp	.+206    	; 0x1468 <DIO__CheckStatusGetPinValue+0x13e>
    139a:	8f 81       	ldd	r24, Y+7	; 0x07
    139c:	98 85       	ldd	r25, Y+8	; 0x08
    139e:	83 30       	cpi	r24, 0x03	; 3
    13a0:	91 05       	cpc	r25, r1
    13a2:	09 f4       	brne	.+2      	; 0x13a6 <DIO__CheckStatusGetPinValue+0x7c>
    13a4:	90 c0       	rjmp	.+288    	; 0x14c6 <DIO__CheckStatusGetPinValue+0x19c>
    13a6:	bd c0       	rjmp	.+378    	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>
                {
                case DIO__UINT8_PORTA:
                        if (GET_BIT(PINA__UINT8_REG, Copy__uint8PinId) == 0)
    13a8:	e9 e3       	ldi	r30, 0x39	; 57
    13aa:	f0 e0       	ldi	r31, 0x00	; 0
    13ac:	80 81       	ld	r24, Z
    13ae:	28 2f       	mov	r18, r24
    13b0:	30 e0       	ldi	r19, 0x00	; 0
    13b2:	8b 81       	ldd	r24, Y+3	; 0x03
    13b4:	88 2f       	mov	r24, r24
    13b6:	90 e0       	ldi	r25, 0x00	; 0
    13b8:	a9 01       	movw	r20, r18
    13ba:	02 c0       	rjmp	.+4      	; 0x13c0 <DIO__CheckStatusGetPinValue+0x96>
    13bc:	55 95       	asr	r21
    13be:	47 95       	ror	r20
    13c0:	8a 95       	dec	r24
    13c2:	e2 f7       	brpl	.-8      	; 0x13bc <DIO__CheckStatusGetPinValue+0x92>
    13c4:	ca 01       	movw	r24, r20
    13c6:	81 70       	andi	r24, 0x01	; 1
    13c8:	90 70       	andi	r25, 0x00	; 0
    13ca:	00 97       	sbiw	r24, 0x00	; 0
    13cc:	21 f4       	brne	.+8      	; 0x13d6 <DIO__CheckStatusGetPinValue+0xac>
                        {
                                *Copy_p_uint8ReturnPinValue = DIO__UINT8_LOW;
    13ce:	ec 81       	ldd	r30, Y+4	; 0x04
    13d0:	fd 81       	ldd	r31, Y+5	; 0x05
    13d2:	10 82       	st	Z, r1
    13d4:	a6 c0       	rjmp	.+332    	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>
                        }
                        else if (GET_BIT(PINA__UINT8_REG, Copy__uint8PinId) != 0)
    13d6:	e9 e3       	ldi	r30, 0x39	; 57
    13d8:	f0 e0       	ldi	r31, 0x00	; 0
    13da:	80 81       	ld	r24, Z
    13dc:	28 2f       	mov	r18, r24
    13de:	30 e0       	ldi	r19, 0x00	; 0
    13e0:	8b 81       	ldd	r24, Y+3	; 0x03
    13e2:	88 2f       	mov	r24, r24
    13e4:	90 e0       	ldi	r25, 0x00	; 0
    13e6:	a9 01       	movw	r20, r18
    13e8:	02 c0       	rjmp	.+4      	; 0x13ee <DIO__CheckStatusGetPinValue+0xc4>
    13ea:	55 95       	asr	r21
    13ec:	47 95       	ror	r20
    13ee:	8a 95       	dec	r24
    13f0:	e2 f7       	brpl	.-8      	; 0x13ea <DIO__CheckStatusGetPinValue+0xc0>
    13f2:	ca 01       	movw	r24, r20
    13f4:	81 70       	andi	r24, 0x01	; 1
    13f6:	90 70       	andi	r25, 0x00	; 0
    13f8:	88 23       	and	r24, r24
    13fa:	09 f4       	brne	.+2      	; 0x13fe <DIO__CheckStatusGetPinValue+0xd4>
    13fc:	92 c0       	rjmp	.+292    	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>
                        {
                                *Copy_p_uint8ReturnPinValue = DIO__UINT8_HIGH;
    13fe:	ec 81       	ldd	r30, Y+4	; 0x04
    1400:	fd 81       	ldd	r31, Y+5	; 0x05
    1402:	81 e0       	ldi	r24, 0x01	; 1
    1404:	80 83       	st	Z, r24
    1406:	8d c0       	rjmp	.+282    	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>
                                /* DO NOTHING */
                        }

                        break;
                case DIO__UINT8_PORTB:
                        if (GET_BIT(PINB__UINT8_REG, Copy__uint8PinId) == 0)
    1408:	e6 e3       	ldi	r30, 0x36	; 54
    140a:	f0 e0       	ldi	r31, 0x00	; 0
    140c:	80 81       	ld	r24, Z
    140e:	28 2f       	mov	r18, r24
    1410:	30 e0       	ldi	r19, 0x00	; 0
    1412:	8b 81       	ldd	r24, Y+3	; 0x03
    1414:	88 2f       	mov	r24, r24
    1416:	90 e0       	ldi	r25, 0x00	; 0
    1418:	a9 01       	movw	r20, r18
    141a:	02 c0       	rjmp	.+4      	; 0x1420 <DIO__CheckStatusGetPinValue+0xf6>
    141c:	55 95       	asr	r21
    141e:	47 95       	ror	r20
    1420:	8a 95       	dec	r24
    1422:	e2 f7       	brpl	.-8      	; 0x141c <DIO__CheckStatusGetPinValue+0xf2>
    1424:	ca 01       	movw	r24, r20
    1426:	81 70       	andi	r24, 0x01	; 1
    1428:	90 70       	andi	r25, 0x00	; 0
    142a:	00 97       	sbiw	r24, 0x00	; 0
    142c:	21 f4       	brne	.+8      	; 0x1436 <DIO__CheckStatusGetPinValue+0x10c>
                        {
                                *Copy_p_uint8ReturnPinValue = DIO__UINT8_LOW;
    142e:	ec 81       	ldd	r30, Y+4	; 0x04
    1430:	fd 81       	ldd	r31, Y+5	; 0x05
    1432:	10 82       	st	Z, r1
    1434:	76 c0       	rjmp	.+236    	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>
                        }
                        else if (GET_BIT(PINB__UINT8_REG, Copy__uint8PinId) != 0)
    1436:	e6 e3       	ldi	r30, 0x36	; 54
    1438:	f0 e0       	ldi	r31, 0x00	; 0
    143a:	80 81       	ld	r24, Z
    143c:	28 2f       	mov	r18, r24
    143e:	30 e0       	ldi	r19, 0x00	; 0
    1440:	8b 81       	ldd	r24, Y+3	; 0x03
    1442:	88 2f       	mov	r24, r24
    1444:	90 e0       	ldi	r25, 0x00	; 0
    1446:	a9 01       	movw	r20, r18
    1448:	02 c0       	rjmp	.+4      	; 0x144e <DIO__CheckStatusGetPinValue+0x124>
    144a:	55 95       	asr	r21
    144c:	47 95       	ror	r20
    144e:	8a 95       	dec	r24
    1450:	e2 f7       	brpl	.-8      	; 0x144a <DIO__CheckStatusGetPinValue+0x120>
    1452:	ca 01       	movw	r24, r20
    1454:	81 70       	andi	r24, 0x01	; 1
    1456:	90 70       	andi	r25, 0x00	; 0
    1458:	88 23       	and	r24, r24
    145a:	09 f4       	brne	.+2      	; 0x145e <DIO__CheckStatusGetPinValue+0x134>
    145c:	62 c0       	rjmp	.+196    	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>
                        {
                                *Copy_p_uint8ReturnPinValue = DIO__UINT8_HIGH;
    145e:	ec 81       	ldd	r30, Y+4	; 0x04
    1460:	fd 81       	ldd	r31, Y+5	; 0x05
    1462:	81 e0       	ldi	r24, 0x01	; 1
    1464:	80 83       	st	Z, r24
    1466:	5d c0       	rjmp	.+186    	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>

                        break;

                case DIO__UINT8_PORTC:

                        if (GET_BIT(PINC__UINT8_REG, Copy__uint8PinId) == 0)
    1468:	e3 e3       	ldi	r30, 0x33	; 51
    146a:	f0 e0       	ldi	r31, 0x00	; 0
    146c:	80 81       	ld	r24, Z
    146e:	28 2f       	mov	r18, r24
    1470:	30 e0       	ldi	r19, 0x00	; 0
    1472:	8b 81       	ldd	r24, Y+3	; 0x03
    1474:	88 2f       	mov	r24, r24
    1476:	90 e0       	ldi	r25, 0x00	; 0
    1478:	a9 01       	movw	r20, r18
    147a:	02 c0       	rjmp	.+4      	; 0x1480 <DIO__CheckStatusGetPinValue+0x156>
    147c:	55 95       	asr	r21
    147e:	47 95       	ror	r20
    1480:	8a 95       	dec	r24
    1482:	e2 f7       	brpl	.-8      	; 0x147c <DIO__CheckStatusGetPinValue+0x152>
    1484:	ca 01       	movw	r24, r20
    1486:	81 70       	andi	r24, 0x01	; 1
    1488:	90 70       	andi	r25, 0x00	; 0
    148a:	00 97       	sbiw	r24, 0x00	; 0
    148c:	21 f4       	brne	.+8      	; 0x1496 <DIO__CheckStatusGetPinValue+0x16c>
                        {
                                *Copy_p_uint8ReturnPinValue = DIO__UINT8_LOW;
    148e:	ec 81       	ldd	r30, Y+4	; 0x04
    1490:	fd 81       	ldd	r31, Y+5	; 0x05
    1492:	10 82       	st	Z, r1
    1494:	46 c0       	rjmp	.+140    	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>
                        }
                        else if (GET_BIT(PINC__UINT8_REG, Copy__uint8PinId) != 0)
    1496:	e3 e3       	ldi	r30, 0x33	; 51
    1498:	f0 e0       	ldi	r31, 0x00	; 0
    149a:	80 81       	ld	r24, Z
    149c:	28 2f       	mov	r18, r24
    149e:	30 e0       	ldi	r19, 0x00	; 0
    14a0:	8b 81       	ldd	r24, Y+3	; 0x03
    14a2:	88 2f       	mov	r24, r24
    14a4:	90 e0       	ldi	r25, 0x00	; 0
    14a6:	a9 01       	movw	r20, r18
    14a8:	02 c0       	rjmp	.+4      	; 0x14ae <DIO__CheckStatusGetPinValue+0x184>
    14aa:	55 95       	asr	r21
    14ac:	47 95       	ror	r20
    14ae:	8a 95       	dec	r24
    14b0:	e2 f7       	brpl	.-8      	; 0x14aa <DIO__CheckStatusGetPinValue+0x180>
    14b2:	ca 01       	movw	r24, r20
    14b4:	81 70       	andi	r24, 0x01	; 1
    14b6:	90 70       	andi	r25, 0x00	; 0
    14b8:	88 23       	and	r24, r24
    14ba:	99 f1       	breq	.+102    	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>
                        {
                                *Copy_p_uint8ReturnPinValue = DIO__UINT8_HIGH;
    14bc:	ec 81       	ldd	r30, Y+4	; 0x04
    14be:	fd 81       	ldd	r31, Y+5	; 0x05
    14c0:	81 e0       	ldi	r24, 0x01	; 1
    14c2:	80 83       	st	Z, r24
    14c4:	2e c0       	rjmp	.+92     	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>
                                /* DO NOTHING */
                        }

                        break;
                case DIO__UINT8_PORTD:
                        if (GET_BIT(PIND__UINT8_REG, Copy__uint8PinId) == 0)
    14c6:	e0 e3       	ldi	r30, 0x30	; 48
    14c8:	f0 e0       	ldi	r31, 0x00	; 0
    14ca:	80 81       	ld	r24, Z
    14cc:	28 2f       	mov	r18, r24
    14ce:	30 e0       	ldi	r19, 0x00	; 0
    14d0:	8b 81       	ldd	r24, Y+3	; 0x03
    14d2:	88 2f       	mov	r24, r24
    14d4:	90 e0       	ldi	r25, 0x00	; 0
    14d6:	a9 01       	movw	r20, r18
    14d8:	02 c0       	rjmp	.+4      	; 0x14de <DIO__CheckStatusGetPinValue+0x1b4>
    14da:	55 95       	asr	r21
    14dc:	47 95       	ror	r20
    14de:	8a 95       	dec	r24
    14e0:	e2 f7       	brpl	.-8      	; 0x14da <DIO__CheckStatusGetPinValue+0x1b0>
    14e2:	ca 01       	movw	r24, r20
    14e4:	81 70       	andi	r24, 0x01	; 1
    14e6:	90 70       	andi	r25, 0x00	; 0
    14e8:	00 97       	sbiw	r24, 0x00	; 0
    14ea:	21 f4       	brne	.+8      	; 0x14f4 <DIO__CheckStatusGetPinValue+0x1ca>
                        {
                                *Copy_p_uint8ReturnPinValue = DIO__UINT8_LOW;
    14ec:	ec 81       	ldd	r30, Y+4	; 0x04
    14ee:	fd 81       	ldd	r31, Y+5	; 0x05
    14f0:	10 82       	st	Z, r1
    14f2:	17 c0       	rjmp	.+46     	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>
                        }
                        else if (GET_BIT(PIND__UINT8_REG, Copy__uint8PinId) != 0)
    14f4:	e0 e3       	ldi	r30, 0x30	; 48
    14f6:	f0 e0       	ldi	r31, 0x00	; 0
    14f8:	80 81       	ld	r24, Z
    14fa:	28 2f       	mov	r18, r24
    14fc:	30 e0       	ldi	r19, 0x00	; 0
    14fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1500:	88 2f       	mov	r24, r24
    1502:	90 e0       	ldi	r25, 0x00	; 0
    1504:	a9 01       	movw	r20, r18
    1506:	02 c0       	rjmp	.+4      	; 0x150c <DIO__CheckStatusGetPinValue+0x1e2>
    1508:	55 95       	asr	r21
    150a:	47 95       	ror	r20
    150c:	8a 95       	dec	r24
    150e:	e2 f7       	brpl	.-8      	; 0x1508 <DIO__CheckStatusGetPinValue+0x1de>
    1510:	ca 01       	movw	r24, r20
    1512:	81 70       	andi	r24, 0x01	; 1
    1514:	90 70       	andi	r25, 0x00	; 0
    1516:	88 23       	and	r24, r24
    1518:	21 f0       	breq	.+8      	; 0x1522 <DIO__CheckStatusGetPinValue+0x1f8>
                        {
                                *Copy_p_uint8ReturnPinValue = DIO__UINT8_HIGH;
    151a:	ec 81       	ldd	r30, Y+4	; 0x04
    151c:	fd 81       	ldd	r31, Y+5	; 0x05
    151e:	81 e0       	ldi	r24, 0x01	; 1
    1520:	80 83       	st	Z, r24
                        break;
                default:
                        /* DO NOTHING */
                        break;
                }
                return Local_CheckStatusReturnStatus;
    1522:	59 81       	ldd	r21, Y+1	; 0x01
    1524:	5e 83       	std	Y+6, r21	; 0x06
    1526:	04 c0       	rjmp	.+8      	; 0x1530 <DIO__CheckStatusGetPinValue+0x206>
        }
        else
        {
                Local_CheckStatusReturnStatus = CHECK_FAIL;
    1528:	81 e0       	ldi	r24, 0x01	; 1
    152a:	89 83       	std	Y+1, r24	; 0x01
                return Local_CheckStatusReturnStatus;
    152c:	89 81       	ldd	r24, Y+1	; 0x01
    152e:	8e 83       	std	Y+6, r24	; 0x06
    1530:	8e 81       	ldd	r24, Y+6	; 0x06
        }
}
    1532:	28 96       	adiw	r28, 0x08	; 8
    1534:	0f b6       	in	r0, 0x3f	; 63
    1536:	f8 94       	cli
    1538:	de bf       	out	0x3e, r29	; 62
    153a:	0f be       	out	0x3f, r0	; 63
    153c:	cd bf       	out	0x3d, r28	; 61
    153e:	cf 91       	pop	r28
    1540:	df 91       	pop	r29
    1542:	08 95       	ret

00001544 <DIO__CheckStatusSetPortDirection>:

CheckStatus DIO__CheckStatusSetPortDirection(_uint8 Copy__uint8PortId, _uint8 Copy__uint8PortDirection)
{
    1544:	df 93       	push	r29
    1546:	cf 93       	push	r28
    1548:	cd b7       	in	r28, 0x3d	; 61
    154a:	de b7       	in	r29, 0x3e	; 62
    154c:	2e 97       	sbiw	r28, 0x0e	; 14
    154e:	0f b6       	in	r0, 0x3f	; 63
    1550:	f8 94       	cli
    1552:	de bf       	out	0x3e, r29	; 62
    1554:	0f be       	out	0x3f, r0	; 63
    1556:	cd bf       	out	0x3d, r28	; 61
    1558:	8a 83       	std	Y+2, r24	; 0x02
    155a:	6b 83       	std	Y+3, r22	; 0x03
        CheckStatus Local_CheckStatusReturnStatus = CHECK_SUCCESS;
    155c:	19 82       	std	Y+1, r1	; 0x01
        /* 
        Check 1-Valid Port Id
              2-Valid PORT diraction 
        */

        if ((Copy__uint8PortId <= DIO__UINT8_PORTD) && ((Copy__uint8PortDirection == DIO__UINT8_OUTPUT) || (Copy__uint8PortDirection == DIO__UINT8_INPUT)))
    155e:	8a 81       	ldd	r24, Y+2	; 0x02
    1560:	84 30       	cpi	r24, 0x04	; 4
    1562:	08 f0       	brcs	.+2      	; 0x1566 <DIO__CheckStatusSetPortDirection+0x22>
    1564:	89 c0       	rjmp	.+274    	; 0x1678 <DIO__CheckStatusSetPortDirection+0x134>
    1566:	8b 81       	ldd	r24, Y+3	; 0x03
    1568:	81 30       	cpi	r24, 0x01	; 1
    156a:	21 f0       	breq	.+8      	; 0x1574 <DIO__CheckStatusSetPortDirection+0x30>
    156c:	8b 81       	ldd	r24, Y+3	; 0x03
    156e:	88 23       	and	r24, r24
    1570:	09 f0       	breq	.+2      	; 0x1574 <DIO__CheckStatusSetPortDirection+0x30>
    1572:	82 c0       	rjmp	.+260    	; 0x1678 <DIO__CheckStatusSetPortDirection+0x134>
        {
                switch (Copy__uint8PortId)
    1574:	8a 81       	ldd	r24, Y+2	; 0x02
    1576:	28 2f       	mov	r18, r24
    1578:	30 e0       	ldi	r19, 0x00	; 0
    157a:	3e 87       	std	Y+14, r19	; 0x0e
    157c:	2d 87       	std	Y+13, r18	; 0x0d
    157e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1580:	9e 85       	ldd	r25, Y+14	; 0x0e
    1582:	81 30       	cpi	r24, 0x01	; 1
    1584:	91 05       	cpc	r25, r1
    1586:	71 f1       	breq	.+92     	; 0x15e4 <DIO__CheckStatusSetPortDirection+0xa0>
    1588:	2d 85       	ldd	r18, Y+13	; 0x0d
    158a:	3e 85       	ldd	r19, Y+14	; 0x0e
    158c:	22 30       	cpi	r18, 0x02	; 2
    158e:	31 05       	cpc	r19, r1
    1590:	2c f4       	brge	.+10     	; 0x159c <DIO__CheckStatusSetPortDirection+0x58>
    1592:	8d 85       	ldd	r24, Y+13	; 0x0d
    1594:	9e 85       	ldd	r25, Y+14	; 0x0e
    1596:	00 97       	sbiw	r24, 0x00	; 0
    1598:	69 f0       	breq	.+26     	; 0x15b4 <DIO__CheckStatusSetPortDirection+0x70>
    159a:	6b c0       	rjmp	.+214    	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
    159c:	2d 85       	ldd	r18, Y+13	; 0x0d
    159e:	3e 85       	ldd	r19, Y+14	; 0x0e
    15a0:	22 30       	cpi	r18, 0x02	; 2
    15a2:	31 05       	cpc	r19, r1
    15a4:	b9 f1       	breq	.+110    	; 0x1614 <DIO__CheckStatusSetPortDirection+0xd0>
    15a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    15a8:	9e 85       	ldd	r25, Y+14	; 0x0e
    15aa:	83 30       	cpi	r24, 0x03	; 3
    15ac:	91 05       	cpc	r25, r1
    15ae:	09 f4       	brne	.+2      	; 0x15b2 <DIO__CheckStatusSetPortDirection+0x6e>
    15b0:	49 c0       	rjmp	.+146    	; 0x1644 <DIO__CheckStatusSetPortDirection+0x100>
    15b2:	5f c0       	rjmp	.+190    	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
                {
                case DIO__UINT8_PORTA:
                        switch (Copy__uint8PortDirection)
    15b4:	8b 81       	ldd	r24, Y+3	; 0x03
    15b6:	28 2f       	mov	r18, r24
    15b8:	30 e0       	ldi	r19, 0x00	; 0
    15ba:	3c 87       	std	Y+12, r19	; 0x0c
    15bc:	2b 87       	std	Y+11, r18	; 0x0b
    15be:	8b 85       	ldd	r24, Y+11	; 0x0b
    15c0:	9c 85       	ldd	r25, Y+12	; 0x0c
    15c2:	00 97       	sbiw	r24, 0x00	; 0
    15c4:	31 f0       	breq	.+12     	; 0x15d2 <DIO__CheckStatusSetPortDirection+0x8e>
    15c6:	2b 85       	ldd	r18, Y+11	; 0x0b
    15c8:	3c 85       	ldd	r19, Y+12	; 0x0c
    15ca:	21 30       	cpi	r18, 0x01	; 1
    15cc:	31 05       	cpc	r19, r1
    15ce:	29 f0       	breq	.+10     	; 0x15da <DIO__CheckStatusSetPortDirection+0x96>
    15d0:	50 c0       	rjmp	.+160    	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
                        {
                        case DIO__UINT8_INPUT:
                                PORTA__UINT8_REG = 0x00;
    15d2:	eb e3       	ldi	r30, 0x3B	; 59
    15d4:	f0 e0       	ldi	r31, 0x00	; 0
    15d6:	10 82       	st	Z, r1
    15d8:	4c c0       	rjmp	.+152    	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
                                break;
                        case DIO__UINT8_OUTPUT:
                                PORTA__UINT8_REG = 0xFF;
    15da:	eb e3       	ldi	r30, 0x3B	; 59
    15dc:	f0 e0       	ldi	r31, 0x00	; 0
    15de:	8f ef       	ldi	r24, 0xFF	; 255
    15e0:	80 83       	st	Z, r24
    15e2:	47 c0       	rjmp	.+142    	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
                                /* DO  NOTHING */
                                break;
                        }
                        break;
                case DIO__UINT8_PORTB:
                        switch (Copy__uint8PortDirection)
    15e4:	8b 81       	ldd	r24, Y+3	; 0x03
    15e6:	28 2f       	mov	r18, r24
    15e8:	30 e0       	ldi	r19, 0x00	; 0
    15ea:	3a 87       	std	Y+10, r19	; 0x0a
    15ec:	29 87       	std	Y+9, r18	; 0x09
    15ee:	89 85       	ldd	r24, Y+9	; 0x09
    15f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    15f2:	00 97       	sbiw	r24, 0x00	; 0
    15f4:	31 f0       	breq	.+12     	; 0x1602 <DIO__CheckStatusSetPortDirection+0xbe>
    15f6:	29 85       	ldd	r18, Y+9	; 0x09
    15f8:	3a 85       	ldd	r19, Y+10	; 0x0a
    15fa:	21 30       	cpi	r18, 0x01	; 1
    15fc:	31 05       	cpc	r19, r1
    15fe:	29 f0       	breq	.+10     	; 0x160a <DIO__CheckStatusSetPortDirection+0xc6>
    1600:	38 c0       	rjmp	.+112    	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
                        {
                        case DIO__UINT8_INPUT:
                                PORTB__UINT8_REG = 0x00;
    1602:	e8 e3       	ldi	r30, 0x38	; 56
    1604:	f0 e0       	ldi	r31, 0x00	; 0
    1606:	10 82       	st	Z, r1
    1608:	34 c0       	rjmp	.+104    	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
                                break;
                        case DIO__UINT8_OUTPUT:
                                PORTB__UINT8_REG = 0xFF;
    160a:	e8 e3       	ldi	r30, 0x38	; 56
    160c:	f0 e0       	ldi	r31, 0x00	; 0
    160e:	8f ef       	ldi	r24, 0xFF	; 255
    1610:	80 83       	st	Z, r24
    1612:	2f c0       	rjmp	.+94     	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
                        }

                        break;

                case DIO__UINT8_PORTC:
                        switch (Copy__uint8PortDirection)
    1614:	8b 81       	ldd	r24, Y+3	; 0x03
    1616:	28 2f       	mov	r18, r24
    1618:	30 e0       	ldi	r19, 0x00	; 0
    161a:	38 87       	std	Y+8, r19	; 0x08
    161c:	2f 83       	std	Y+7, r18	; 0x07
    161e:	8f 81       	ldd	r24, Y+7	; 0x07
    1620:	98 85       	ldd	r25, Y+8	; 0x08
    1622:	00 97       	sbiw	r24, 0x00	; 0
    1624:	31 f0       	breq	.+12     	; 0x1632 <DIO__CheckStatusSetPortDirection+0xee>
    1626:	2f 81       	ldd	r18, Y+7	; 0x07
    1628:	38 85       	ldd	r19, Y+8	; 0x08
    162a:	21 30       	cpi	r18, 0x01	; 1
    162c:	31 05       	cpc	r19, r1
    162e:	29 f0       	breq	.+10     	; 0x163a <DIO__CheckStatusSetPortDirection+0xf6>
    1630:	20 c0       	rjmp	.+64     	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
                        {
                        case DIO__UINT8_INPUT:
                                PORTC__UINT8_REG = 0x00;
    1632:	e5 e3       	ldi	r30, 0x35	; 53
    1634:	f0 e0       	ldi	r31, 0x00	; 0
    1636:	10 82       	st	Z, r1
    1638:	1c c0       	rjmp	.+56     	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
                                break;
                        case DIO__UINT8_OUTPUT:
                                PORTC__UINT8_REG = 0xFF;
    163a:	e5 e3       	ldi	r30, 0x35	; 53
    163c:	f0 e0       	ldi	r31, 0x00	; 0
    163e:	8f ef       	ldi	r24, 0xFF	; 255
    1640:	80 83       	st	Z, r24
    1642:	17 c0       	rjmp	.+46     	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
                                break;
                        }

                        break;
                case DIO__UINT8_PORTD:
                        switch (Copy__uint8PortDirection)
    1644:	8b 81       	ldd	r24, Y+3	; 0x03
    1646:	28 2f       	mov	r18, r24
    1648:	30 e0       	ldi	r19, 0x00	; 0
    164a:	3e 83       	std	Y+6, r19	; 0x06
    164c:	2d 83       	std	Y+5, r18	; 0x05
    164e:	8d 81       	ldd	r24, Y+5	; 0x05
    1650:	9e 81       	ldd	r25, Y+6	; 0x06
    1652:	00 97       	sbiw	r24, 0x00	; 0
    1654:	31 f0       	breq	.+12     	; 0x1662 <DIO__CheckStatusSetPortDirection+0x11e>
    1656:	2d 81       	ldd	r18, Y+5	; 0x05
    1658:	3e 81       	ldd	r19, Y+6	; 0x06
    165a:	21 30       	cpi	r18, 0x01	; 1
    165c:	31 05       	cpc	r19, r1
    165e:	29 f0       	breq	.+10     	; 0x166a <DIO__CheckStatusSetPortDirection+0x126>
    1660:	08 c0       	rjmp	.+16     	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
                        {
                        case DIO__UINT8_INPUT:
                                PORTD__UINT8_REG = 0x00;
    1662:	e2 e3       	ldi	r30, 0x32	; 50
    1664:	f0 e0       	ldi	r31, 0x00	; 0
    1666:	10 82       	st	Z, r1
    1668:	04 c0       	rjmp	.+8      	; 0x1672 <DIO__CheckStatusSetPortDirection+0x12e>
                                break;
                        case DIO__UINT8_OUTPUT:
                                PORTD__UINT8_REG = 0xFF;
    166a:	e2 e3       	ldi	r30, 0x32	; 50
    166c:	f0 e0       	ldi	r31, 0x00	; 0
    166e:	8f ef       	ldi	r24, 0xFF	; 255
    1670:	80 83       	st	Z, r24
                        break;
                default:
                        /* DO NOTHING */
                        break;
                }
                return Local_CheckStatusReturnStatus;
    1672:	39 81       	ldd	r19, Y+1	; 0x01
    1674:	3c 83       	std	Y+4, r19	; 0x04
    1676:	04 c0       	rjmp	.+8      	; 0x1680 <DIO__CheckStatusSetPortDirection+0x13c>
        }
        else
        {
                Local_CheckStatusReturnStatus = CHECK_FAIL;
    1678:	81 e0       	ldi	r24, 0x01	; 1
    167a:	89 83       	std	Y+1, r24	; 0x01
                return Local_CheckStatusReturnStatus;
    167c:	89 81       	ldd	r24, Y+1	; 0x01
    167e:	8c 83       	std	Y+4, r24	; 0x04
    1680:	8c 81       	ldd	r24, Y+4	; 0x04
        }
}
    1682:	2e 96       	adiw	r28, 0x0e	; 14
    1684:	0f b6       	in	r0, 0x3f	; 63
    1686:	f8 94       	cli
    1688:	de bf       	out	0x3e, r29	; 62
    168a:	0f be       	out	0x3f, r0	; 63
    168c:	cd bf       	out	0x3d, r28	; 61
    168e:	cf 91       	pop	r28
    1690:	df 91       	pop	r29
    1692:	08 95       	ret

00001694 <DIO__CheckStatusSetPortValue>:

CheckStatus DIO__CheckStatusSetPortValue(_uint8 Copy__uint8PortId, _uint8 Copy__uint8PortValue)
{
    1694:	df 93       	push	r29
    1696:	cf 93       	push	r28
    1698:	00 d0       	rcall	.+0      	; 0x169a <DIO__CheckStatusSetPortValue+0x6>
    169a:	00 d0       	rcall	.+0      	; 0x169c <DIO__CheckStatusSetPortValue+0x8>
    169c:	00 d0       	rcall	.+0      	; 0x169e <DIO__CheckStatusSetPortValue+0xa>
    169e:	cd b7       	in	r28, 0x3d	; 61
    16a0:	de b7       	in	r29, 0x3e	; 62
    16a2:	8a 83       	std	Y+2, r24	; 0x02
    16a4:	6b 83       	std	Y+3, r22	; 0x03

        CheckStatus Local_CheckStatusReturnStatus = CHECK_SUCCESS;
    16a6:	19 82       	std	Y+1, r1	; 0x01
        /*
        Check 1-Valid PORT Id
               
        */
        if (Copy__uint8PortId <= DIO__UINT8_PORTD)
    16a8:	8a 81       	ldd	r24, Y+2	; 0x02
    16aa:	84 30       	cpi	r24, 0x04	; 4
    16ac:	a8 f5       	brcc	.+106    	; 0x1718 <DIO__CheckStatusSetPortValue+0x84>
        {
                switch (Copy__uint8PortId)
    16ae:	8a 81       	ldd	r24, Y+2	; 0x02
    16b0:	28 2f       	mov	r18, r24
    16b2:	30 e0       	ldi	r19, 0x00	; 0
    16b4:	3e 83       	std	Y+6, r19	; 0x06
    16b6:	2d 83       	std	Y+5, r18	; 0x05
    16b8:	8d 81       	ldd	r24, Y+5	; 0x05
    16ba:	9e 81       	ldd	r25, Y+6	; 0x06
    16bc:	81 30       	cpi	r24, 0x01	; 1
    16be:	91 05       	cpc	r25, r1
    16c0:	d1 f0       	breq	.+52     	; 0x16f6 <DIO__CheckStatusSetPortValue+0x62>
    16c2:	2d 81       	ldd	r18, Y+5	; 0x05
    16c4:	3e 81       	ldd	r19, Y+6	; 0x06
    16c6:	22 30       	cpi	r18, 0x02	; 2
    16c8:	31 05       	cpc	r19, r1
    16ca:	2c f4       	brge	.+10     	; 0x16d6 <DIO__CheckStatusSetPortValue+0x42>
    16cc:	8d 81       	ldd	r24, Y+5	; 0x05
    16ce:	9e 81       	ldd	r25, Y+6	; 0x06
    16d0:	00 97       	sbiw	r24, 0x00	; 0
    16d2:	61 f0       	breq	.+24     	; 0x16ec <DIO__CheckStatusSetPortValue+0x58>
    16d4:	1e c0       	rjmp	.+60     	; 0x1712 <DIO__CheckStatusSetPortValue+0x7e>
    16d6:	2d 81       	ldd	r18, Y+5	; 0x05
    16d8:	3e 81       	ldd	r19, Y+6	; 0x06
    16da:	22 30       	cpi	r18, 0x02	; 2
    16dc:	31 05       	cpc	r19, r1
    16de:	81 f0       	breq	.+32     	; 0x1700 <DIO__CheckStatusSetPortValue+0x6c>
    16e0:	8d 81       	ldd	r24, Y+5	; 0x05
    16e2:	9e 81       	ldd	r25, Y+6	; 0x06
    16e4:	83 30       	cpi	r24, 0x03	; 3
    16e6:	91 05       	cpc	r25, r1
    16e8:	81 f0       	breq	.+32     	; 0x170a <DIO__CheckStatusSetPortValue+0x76>
    16ea:	13 c0       	rjmp	.+38     	; 0x1712 <DIO__CheckStatusSetPortValue+0x7e>
                {
                case DIO__UINT8_PORTA:
                        PORTA__UINT8_REG = Copy__uint8PortValue;
    16ec:	eb e3       	ldi	r30, 0x3B	; 59
    16ee:	f0 e0       	ldi	r31, 0x00	; 0
    16f0:	8b 81       	ldd	r24, Y+3	; 0x03
    16f2:	80 83       	st	Z, r24
    16f4:	0e c0       	rjmp	.+28     	; 0x1712 <DIO__CheckStatusSetPortValue+0x7e>
                        break;
                case DIO__UINT8_PORTB:
                        PORTB__UINT8_REG = Copy__uint8PortValue;
    16f6:	e8 e3       	ldi	r30, 0x38	; 56
    16f8:	f0 e0       	ldi	r31, 0x00	; 0
    16fa:	8b 81       	ldd	r24, Y+3	; 0x03
    16fc:	80 83       	st	Z, r24
    16fe:	09 c0       	rjmp	.+18     	; 0x1712 <DIO__CheckStatusSetPortValue+0x7e>
                        break;
                case DIO__UINT8_PORTC:
                        PORTC__UINT8_REG = Copy__uint8PortValue;
    1700:	e5 e3       	ldi	r30, 0x35	; 53
    1702:	f0 e0       	ldi	r31, 0x00	; 0
    1704:	8b 81       	ldd	r24, Y+3	; 0x03
    1706:	80 83       	st	Z, r24
    1708:	04 c0       	rjmp	.+8      	; 0x1712 <DIO__CheckStatusSetPortValue+0x7e>
                        break;
                case DIO__UINT8_PORTD:
                        PORTD__UINT8_REG = Copy__uint8PortValue;
    170a:	e2 e3       	ldi	r30, 0x32	; 50
    170c:	f0 e0       	ldi	r31, 0x00	; 0
    170e:	8b 81       	ldd	r24, Y+3	; 0x03
    1710:	80 83       	st	Z, r24
                        break;
                default:
                        /* DO NOTHING */
                        break;
                }
                return Local_CheckStatusReturnStatus;
    1712:	99 81       	ldd	r25, Y+1	; 0x01
    1714:	9c 83       	std	Y+4, r25	; 0x04
    1716:	04 c0       	rjmp	.+8      	; 0x1720 <DIO__CheckStatusSetPortValue+0x8c>
        }
        else
        {
                Local_CheckStatusReturnStatus = CHECK_FAIL;
    1718:	81 e0       	ldi	r24, 0x01	; 1
    171a:	89 83       	std	Y+1, r24	; 0x01
                return Local_CheckStatusReturnStatus;
    171c:	29 81       	ldd	r18, Y+1	; 0x01
    171e:	2c 83       	std	Y+4, r18	; 0x04
    1720:	8c 81       	ldd	r24, Y+4	; 0x04
        }
}
    1722:	26 96       	adiw	r28, 0x06	; 6
    1724:	0f b6       	in	r0, 0x3f	; 63
    1726:	f8 94       	cli
    1728:	de bf       	out	0x3e, r29	; 62
    172a:	0f be       	out	0x3f, r0	; 63
    172c:	cd bf       	out	0x3d, r28	; 61
    172e:	cf 91       	pop	r28
    1730:	df 91       	pop	r29
    1732:	08 95       	ret

00001734 <DIO__CheckStatusGetPortValue>:

CheckStatus DIO__CheckStatusGetPortValue(_uint8 Copy__uint8PortId, _uint8 *Copy_p_uint8ReturnPortValue)
{
    1734:	df 93       	push	r29
    1736:	cf 93       	push	r28
    1738:	cd b7       	in	r28, 0x3d	; 61
    173a:	de b7       	in	r29, 0x3e	; 62
    173c:	27 97       	sbiw	r28, 0x07	; 7
    173e:	0f b6       	in	r0, 0x3f	; 63
    1740:	f8 94       	cli
    1742:	de bf       	out	0x3e, r29	; 62
    1744:	0f be       	out	0x3f, r0	; 63
    1746:	cd bf       	out	0x3d, r28	; 61
    1748:	8a 83       	std	Y+2, r24	; 0x02
    174a:	7c 83       	std	Y+4, r23	; 0x04
    174c:	6b 83       	std	Y+3, r22	; 0x03
        CheckStatus Local_CheckStatusReturnStatus = CHECK_SUCCESS;
    174e:	19 82       	std	Y+1, r1	; 0x01
        /*
        Check 1-Valid Pointer != NULL
               
        */
        if (Copy_p_uint8ReturnPortValue != NULL)
    1750:	8b 81       	ldd	r24, Y+3	; 0x03
    1752:	9c 81       	ldd	r25, Y+4	; 0x04
    1754:	00 97       	sbiw	r24, 0x00	; 0
    1756:	e9 f1       	breq	.+122    	; 0x17d2 <DIO__CheckStatusGetPortValue+0x9e>
        {
                switch (Copy__uint8PortId)
    1758:	8a 81       	ldd	r24, Y+2	; 0x02
    175a:	28 2f       	mov	r18, r24
    175c:	30 e0       	ldi	r19, 0x00	; 0
    175e:	3f 83       	std	Y+7, r19	; 0x07
    1760:	2e 83       	std	Y+6, r18	; 0x06
    1762:	8e 81       	ldd	r24, Y+6	; 0x06
    1764:	9f 81       	ldd	r25, Y+7	; 0x07
    1766:	81 30       	cpi	r24, 0x01	; 1
    1768:	91 05       	cpc	r25, r1
    176a:	e1 f0       	breq	.+56     	; 0x17a4 <DIO__CheckStatusGetPortValue+0x70>
    176c:	2e 81       	ldd	r18, Y+6	; 0x06
    176e:	3f 81       	ldd	r19, Y+7	; 0x07
    1770:	22 30       	cpi	r18, 0x02	; 2
    1772:	31 05       	cpc	r19, r1
    1774:	2c f4       	brge	.+10     	; 0x1780 <DIO__CheckStatusGetPortValue+0x4c>
    1776:	8e 81       	ldd	r24, Y+6	; 0x06
    1778:	9f 81       	ldd	r25, Y+7	; 0x07
    177a:	00 97       	sbiw	r24, 0x00	; 0
    177c:	61 f0       	breq	.+24     	; 0x1796 <DIO__CheckStatusGetPortValue+0x62>
    177e:	26 c0       	rjmp	.+76     	; 0x17cc <DIO__CheckStatusGetPortValue+0x98>
    1780:	2e 81       	ldd	r18, Y+6	; 0x06
    1782:	3f 81       	ldd	r19, Y+7	; 0x07
    1784:	22 30       	cpi	r18, 0x02	; 2
    1786:	31 05       	cpc	r19, r1
    1788:	a1 f0       	breq	.+40     	; 0x17b2 <DIO__CheckStatusGetPortValue+0x7e>
    178a:	8e 81       	ldd	r24, Y+6	; 0x06
    178c:	9f 81       	ldd	r25, Y+7	; 0x07
    178e:	83 30       	cpi	r24, 0x03	; 3
    1790:	91 05       	cpc	r25, r1
    1792:	b1 f0       	breq	.+44     	; 0x17c0 <DIO__CheckStatusGetPortValue+0x8c>
    1794:	1b c0       	rjmp	.+54     	; 0x17cc <DIO__CheckStatusGetPortValue+0x98>
                {
                case DIO__UINT8_PORTA:
                        *Copy_p_uint8ReturnPortValue = PINA__UINT8_REG;
    1796:	e9 e3       	ldi	r30, 0x39	; 57
    1798:	f0 e0       	ldi	r31, 0x00	; 0
    179a:	80 81       	ld	r24, Z
    179c:	eb 81       	ldd	r30, Y+3	; 0x03
    179e:	fc 81       	ldd	r31, Y+4	; 0x04
    17a0:	80 83       	st	Z, r24
    17a2:	14 c0       	rjmp	.+40     	; 0x17cc <DIO__CheckStatusGetPortValue+0x98>
                        break;
                case DIO__UINT8_PORTB:
                        *Copy_p_uint8ReturnPortValue = PINB__UINT8_REG;
    17a4:	e6 e3       	ldi	r30, 0x36	; 54
    17a6:	f0 e0       	ldi	r31, 0x00	; 0
    17a8:	80 81       	ld	r24, Z
    17aa:	eb 81       	ldd	r30, Y+3	; 0x03
    17ac:	fc 81       	ldd	r31, Y+4	; 0x04
    17ae:	80 83       	st	Z, r24
    17b0:	0d c0       	rjmp	.+26     	; 0x17cc <DIO__CheckStatusGetPortValue+0x98>

                        break;
                case DIO__UINT8_PORTC:
                        *Copy_p_uint8ReturnPortValue = PINC__UINT8_REG;
    17b2:	e3 e3       	ldi	r30, 0x33	; 51
    17b4:	f0 e0       	ldi	r31, 0x00	; 0
    17b6:	80 81       	ld	r24, Z
    17b8:	eb 81       	ldd	r30, Y+3	; 0x03
    17ba:	fc 81       	ldd	r31, Y+4	; 0x04
    17bc:	80 83       	st	Z, r24
    17be:	06 c0       	rjmp	.+12     	; 0x17cc <DIO__CheckStatusGetPortValue+0x98>
                        break;
                case DIO__UINT8_PORTD:
                        *Copy_p_uint8ReturnPortValue = PIND__UINT8_REG;
    17c0:	e0 e3       	ldi	r30, 0x30	; 48
    17c2:	f0 e0       	ldi	r31, 0x00	; 0
    17c4:	80 81       	ld	r24, Z
    17c6:	eb 81       	ldd	r30, Y+3	; 0x03
    17c8:	fc 81       	ldd	r31, Y+4	; 0x04
    17ca:	80 83       	st	Z, r24
                        break;
                default:
                        /* DO NOTHING */
                        break;
                }
                return Local_CheckStatusReturnStatus;
    17cc:	99 81       	ldd	r25, Y+1	; 0x01
    17ce:	9d 83       	std	Y+5, r25	; 0x05
    17d0:	04 c0       	rjmp	.+8      	; 0x17da <DIO__CheckStatusGetPortValue+0xa6>
        }
        else
        {
                Local_CheckStatusReturnStatus = CHECK_FAIL;
    17d2:	81 e0       	ldi	r24, 0x01	; 1
    17d4:	89 83       	std	Y+1, r24	; 0x01
                return Local_CheckStatusReturnStatus;
    17d6:	29 81       	ldd	r18, Y+1	; 0x01
    17d8:	2d 83       	std	Y+5, r18	; 0x05
    17da:	8d 81       	ldd	r24, Y+5	; 0x05
        }
}
    17dc:	27 96       	adiw	r28, 0x07	; 7
    17de:	0f b6       	in	r0, 0x3f	; 63
    17e0:	f8 94       	cli
    17e2:	de bf       	out	0x3e, r29	; 62
    17e4:	0f be       	out	0x3f, r0	; 63
    17e6:	cd bf       	out	0x3d, r28	; 61
    17e8:	cf 91       	pop	r28
    17ea:	df 91       	pop	r29
    17ec:	08 95       	ret

000017ee <LCD_VoidInit>:
                                     LCD_A_UINT8CHAR6,
                                     LCD_A_UINT8CHAR7,
                                     LCD_A_UINT8CHAR8};
/* Defination Of Function  */
Void LCD_VoidInit(Void)
{
    17ee:	0f 93       	push	r16
    17f0:	1f 93       	push	r17
    17f2:	df 93       	push	r29
    17f4:	cf 93       	push	r28
    17f6:	cd b7       	in	r28, 0x3d	; 61
    17f8:	de b7       	in	r29, 0x3e	; 62
    17fa:	cc 54       	subi	r28, 0x4C	; 76
    17fc:	d0 40       	sbci	r29, 0x00	; 0
    17fe:	0f b6       	in	r0, 0x3f	; 63
    1800:	f8 94       	cli
    1802:	de bf       	out	0x3e, r29	; 62
    1804:	0f be       	out	0x3f, r0	; 63
    1806:	cd bf       	out	0x3d, r28	; 61
    1808:	fe 01       	movw	r30, r28
    180a:	e7 5b       	subi	r30, 0xB7	; 183
    180c:	ff 4f       	sbci	r31, 0xFF	; 255
    180e:	80 e0       	ldi	r24, 0x00	; 0
    1810:	90 e0       	ldi	r25, 0x00	; 0
    1812:	ac e0       	ldi	r26, 0x0C	; 12
    1814:	b2 e4       	ldi	r27, 0x42	; 66
    1816:	80 83       	st	Z, r24
    1818:	91 83       	std	Z+1, r25	; 0x01
    181a:	a2 83       	std	Z+2, r26	; 0x02
    181c:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    181e:	8e 01       	movw	r16, r28
    1820:	0b 5b       	subi	r16, 0xBB	; 187
    1822:	1f 4f       	sbci	r17, 0xFF	; 255
    1824:	fe 01       	movw	r30, r28
    1826:	e7 5b       	subi	r30, 0xB7	; 183
    1828:	ff 4f       	sbci	r31, 0xFF	; 255
    182a:	60 81       	ld	r22, Z
    182c:	71 81       	ldd	r23, Z+1	; 0x01
    182e:	82 81       	ldd	r24, Z+2	; 0x02
    1830:	93 81       	ldd	r25, Z+3	; 0x03
    1832:	20 e0       	ldi	r18, 0x00	; 0
    1834:	30 e0       	ldi	r19, 0x00	; 0
    1836:	4a ef       	ldi	r20, 0xFA	; 250
    1838:	54 e4       	ldi	r21, 0x44	; 68
    183a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    183e:	dc 01       	movw	r26, r24
    1840:	cb 01       	movw	r24, r22
    1842:	f8 01       	movw	r30, r16
    1844:	80 83       	st	Z, r24
    1846:	91 83       	std	Z+1, r25	; 0x01
    1848:	a2 83       	std	Z+2, r26	; 0x02
    184a:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    184c:	fe 01       	movw	r30, r28
    184e:	eb 5b       	subi	r30, 0xBB	; 187
    1850:	ff 4f       	sbci	r31, 0xFF	; 255
    1852:	60 81       	ld	r22, Z
    1854:	71 81       	ldd	r23, Z+1	; 0x01
    1856:	82 81       	ldd	r24, Z+2	; 0x02
    1858:	93 81       	ldd	r25, Z+3	; 0x03
    185a:	20 e0       	ldi	r18, 0x00	; 0
    185c:	30 e0       	ldi	r19, 0x00	; 0
    185e:	40 e8       	ldi	r20, 0x80	; 128
    1860:	5f e3       	ldi	r21, 0x3F	; 63
    1862:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1866:	88 23       	and	r24, r24
    1868:	44 f4       	brge	.+16     	; 0x187a <LCD_VoidInit+0x8c>
		__ticks = 1;
    186a:	fe 01       	movw	r30, r28
    186c:	ed 5b       	subi	r30, 0xBD	; 189
    186e:	ff 4f       	sbci	r31, 0xFF	; 255
    1870:	81 e0       	ldi	r24, 0x01	; 1
    1872:	90 e0       	ldi	r25, 0x00	; 0
    1874:	91 83       	std	Z+1, r25	; 0x01
    1876:	80 83       	st	Z, r24
    1878:	64 c0       	rjmp	.+200    	; 0x1942 <LCD_VoidInit+0x154>
	else if (__tmp > 65535)
    187a:	fe 01       	movw	r30, r28
    187c:	eb 5b       	subi	r30, 0xBB	; 187
    187e:	ff 4f       	sbci	r31, 0xFF	; 255
    1880:	60 81       	ld	r22, Z
    1882:	71 81       	ldd	r23, Z+1	; 0x01
    1884:	82 81       	ldd	r24, Z+2	; 0x02
    1886:	93 81       	ldd	r25, Z+3	; 0x03
    1888:	20 e0       	ldi	r18, 0x00	; 0
    188a:	3f ef       	ldi	r19, 0xFF	; 255
    188c:	4f e7       	ldi	r20, 0x7F	; 127
    188e:	57 e4       	ldi	r21, 0x47	; 71
    1890:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1894:	18 16       	cp	r1, r24
    1896:	0c f0       	brlt	.+2      	; 0x189a <LCD_VoidInit+0xac>
    1898:	43 c0       	rjmp	.+134    	; 0x1920 <LCD_VoidInit+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    189a:	fe 01       	movw	r30, r28
    189c:	e7 5b       	subi	r30, 0xB7	; 183
    189e:	ff 4f       	sbci	r31, 0xFF	; 255
    18a0:	60 81       	ld	r22, Z
    18a2:	71 81       	ldd	r23, Z+1	; 0x01
    18a4:	82 81       	ldd	r24, Z+2	; 0x02
    18a6:	93 81       	ldd	r25, Z+3	; 0x03
    18a8:	20 e0       	ldi	r18, 0x00	; 0
    18aa:	30 e0       	ldi	r19, 0x00	; 0
    18ac:	40 e2       	ldi	r20, 0x20	; 32
    18ae:	51 e4       	ldi	r21, 0x41	; 65
    18b0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    18b4:	dc 01       	movw	r26, r24
    18b6:	cb 01       	movw	r24, r22
    18b8:	8e 01       	movw	r16, r28
    18ba:	0d 5b       	subi	r16, 0xBD	; 189
    18bc:	1f 4f       	sbci	r17, 0xFF	; 255
    18be:	bc 01       	movw	r22, r24
    18c0:	cd 01       	movw	r24, r26
    18c2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18c6:	dc 01       	movw	r26, r24
    18c8:	cb 01       	movw	r24, r22
    18ca:	f8 01       	movw	r30, r16
    18cc:	91 83       	std	Z+1, r25	; 0x01
    18ce:	80 83       	st	Z, r24
    18d0:	1f c0       	rjmp	.+62     	; 0x1910 <LCD_VoidInit+0x122>
    18d2:	fe 01       	movw	r30, r28
    18d4:	ef 5b       	subi	r30, 0xBF	; 191
    18d6:	ff 4f       	sbci	r31, 0xFF	; 255
    18d8:	88 ec       	ldi	r24, 0xC8	; 200
    18da:	90 e0       	ldi	r25, 0x00	; 0
    18dc:	91 83       	std	Z+1, r25	; 0x01
    18de:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    18e0:	fe 01       	movw	r30, r28
    18e2:	ef 5b       	subi	r30, 0xBF	; 191
    18e4:	ff 4f       	sbci	r31, 0xFF	; 255
    18e6:	80 81       	ld	r24, Z
    18e8:	91 81       	ldd	r25, Z+1	; 0x01
    18ea:	01 97       	sbiw	r24, 0x01	; 1
    18ec:	f1 f7       	brne	.-4      	; 0x18ea <LCD_VoidInit+0xfc>
    18ee:	fe 01       	movw	r30, r28
    18f0:	ef 5b       	subi	r30, 0xBF	; 191
    18f2:	ff 4f       	sbci	r31, 0xFF	; 255
    18f4:	91 83       	std	Z+1, r25	; 0x01
    18f6:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18f8:	de 01       	movw	r26, r28
    18fa:	ad 5b       	subi	r26, 0xBD	; 189
    18fc:	bf 4f       	sbci	r27, 0xFF	; 255
    18fe:	fe 01       	movw	r30, r28
    1900:	ed 5b       	subi	r30, 0xBD	; 189
    1902:	ff 4f       	sbci	r31, 0xFF	; 255
    1904:	80 81       	ld	r24, Z
    1906:	91 81       	ldd	r25, Z+1	; 0x01
    1908:	01 97       	sbiw	r24, 0x01	; 1
    190a:	11 96       	adiw	r26, 0x01	; 1
    190c:	9c 93       	st	X, r25
    190e:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1910:	fe 01       	movw	r30, r28
    1912:	ed 5b       	subi	r30, 0xBD	; 189
    1914:	ff 4f       	sbci	r31, 0xFF	; 255
    1916:	80 81       	ld	r24, Z
    1918:	91 81       	ldd	r25, Z+1	; 0x01
    191a:	00 97       	sbiw	r24, 0x00	; 0
    191c:	d1 f6       	brne	.-76     	; 0x18d2 <LCD_VoidInit+0xe4>
    191e:	24 c0       	rjmp	.+72     	; 0x1968 <LCD_VoidInit+0x17a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1920:	8e 01       	movw	r16, r28
    1922:	0d 5b       	subi	r16, 0xBD	; 189
    1924:	1f 4f       	sbci	r17, 0xFF	; 255
    1926:	fe 01       	movw	r30, r28
    1928:	eb 5b       	subi	r30, 0xBB	; 187
    192a:	ff 4f       	sbci	r31, 0xFF	; 255
    192c:	60 81       	ld	r22, Z
    192e:	71 81       	ldd	r23, Z+1	; 0x01
    1930:	82 81       	ldd	r24, Z+2	; 0x02
    1932:	93 81       	ldd	r25, Z+3	; 0x03
    1934:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1938:	dc 01       	movw	r26, r24
    193a:	cb 01       	movw	r24, r22
    193c:	f8 01       	movw	r30, r16
    193e:	91 83       	std	Z+1, r25	; 0x01
    1940:	80 83       	st	Z, r24
    1942:	fe 01       	movw	r30, r28
    1944:	ed 5b       	subi	r30, 0xBD	; 189
    1946:	ff 4f       	sbci	r31, 0xFF	; 255
    1948:	80 81       	ld	r24, Z
    194a:	91 81       	ldd	r25, Z+1	; 0x01
    194c:	fe 01       	movw	r30, r28
    194e:	ff 96       	adiw	r30, 0x3f	; 63
    1950:	91 83       	std	Z+1, r25	; 0x01
    1952:	80 83       	st	Z, r24
    1954:	fe 01       	movw	r30, r28
    1956:	ff 96       	adiw	r30, 0x3f	; 63
    1958:	80 81       	ld	r24, Z
    195a:	91 81       	ldd	r25, Z+1	; 0x01
    195c:	01 97       	sbiw	r24, 0x01	; 1
    195e:	f1 f7       	brne	.-4      	; 0x195c <LCD_VoidInit+0x16e>
    1960:	fe 01       	movw	r30, r28
    1962:	ff 96       	adiw	r30, 0x3f	; 63
    1964:	91 83       	std	Z+1, r25	; 0x01
    1966:	80 83       	st	Z, r24

        _delay_ms(35);
        /* Function Set Cmnd 0b00111000*/

        LCD_CheckStatusSendCmnd(0b00111000);
    1968:	88 e3       	ldi	r24, 0x38	; 56
    196a:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
    196e:	80 e0       	ldi	r24, 0x00	; 0
    1970:	90 e0       	ldi	r25, 0x00	; 0
    1972:	a0 e2       	ldi	r26, 0x20	; 32
    1974:	b2 e4       	ldi	r27, 0x42	; 66
    1976:	8b af       	std	Y+59, r24	; 0x3b
    1978:	9c af       	std	Y+60, r25	; 0x3c
    197a:	ad af       	std	Y+61, r26	; 0x3d
    197c:	be af       	std	Y+62, r27	; 0x3e
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    197e:	6b ad       	ldd	r22, Y+59	; 0x3b
    1980:	7c ad       	ldd	r23, Y+60	; 0x3c
    1982:	8d ad       	ldd	r24, Y+61	; 0x3d
    1984:	9e ad       	ldd	r25, Y+62	; 0x3e
    1986:	2b ea       	ldi	r18, 0xAB	; 171
    1988:	3a ea       	ldi	r19, 0xAA	; 170
    198a:	4a e2       	ldi	r20, 0x2A	; 42
    198c:	50 e4       	ldi	r21, 0x40	; 64
    198e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1992:	dc 01       	movw	r26, r24
    1994:	cb 01       	movw	r24, r22
    1996:	8f ab       	std	Y+55, r24	; 0x37
    1998:	98 af       	std	Y+56, r25	; 0x38
    199a:	a9 af       	std	Y+57, r26	; 0x39
    199c:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
    199e:	6f a9       	ldd	r22, Y+55	; 0x37
    19a0:	78 ad       	ldd	r23, Y+56	; 0x38
    19a2:	89 ad       	ldd	r24, Y+57	; 0x39
    19a4:	9a ad       	ldd	r25, Y+58	; 0x3a
    19a6:	20 e0       	ldi	r18, 0x00	; 0
    19a8:	30 e0       	ldi	r19, 0x00	; 0
    19aa:	40 e8       	ldi	r20, 0x80	; 128
    19ac:	5f e3       	ldi	r21, 0x3F	; 63
    19ae:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    19b2:	88 23       	and	r24, r24
    19b4:	1c f4       	brge	.+6      	; 0x19bc <LCD_VoidInit+0x1ce>
		__ticks = 1;
    19b6:	81 e0       	ldi	r24, 0x01	; 1
    19b8:	8e ab       	std	Y+54, r24	; 0x36
    19ba:	91 c0       	rjmp	.+290    	; 0x1ade <LCD_VoidInit+0x2f0>
	else if (__tmp > 255)
    19bc:	6f a9       	ldd	r22, Y+55	; 0x37
    19be:	78 ad       	ldd	r23, Y+56	; 0x38
    19c0:	89 ad       	ldd	r24, Y+57	; 0x39
    19c2:	9a ad       	ldd	r25, Y+58	; 0x3a
    19c4:	20 e0       	ldi	r18, 0x00	; 0
    19c6:	30 e0       	ldi	r19, 0x00	; 0
    19c8:	4f e7       	ldi	r20, 0x7F	; 127
    19ca:	53 e4       	ldi	r21, 0x43	; 67
    19cc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    19d0:	18 16       	cp	r1, r24
    19d2:	0c f0       	brlt	.+2      	; 0x19d6 <LCD_VoidInit+0x1e8>
    19d4:	7b c0       	rjmp	.+246    	; 0x1acc <LCD_VoidInit+0x2de>
	{
		_delay_ms(__us / 1000.0);
    19d6:	6b ad       	ldd	r22, Y+59	; 0x3b
    19d8:	7c ad       	ldd	r23, Y+60	; 0x3c
    19da:	8d ad       	ldd	r24, Y+61	; 0x3d
    19dc:	9e ad       	ldd	r25, Y+62	; 0x3e
    19de:	20 e0       	ldi	r18, 0x00	; 0
    19e0:	30 e0       	ldi	r19, 0x00	; 0
    19e2:	4a e7       	ldi	r20, 0x7A	; 122
    19e4:	54 e4       	ldi	r21, 0x44	; 68
    19e6:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    19ea:	dc 01       	movw	r26, r24
    19ec:	cb 01       	movw	r24, r22
    19ee:	8a ab       	std	Y+50, r24	; 0x32
    19f0:	9b ab       	std	Y+51, r25	; 0x33
    19f2:	ac ab       	std	Y+52, r26	; 0x34
    19f4:	bd ab       	std	Y+53, r27	; 0x35
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    19f6:	6a a9       	ldd	r22, Y+50	; 0x32
    19f8:	7b a9       	ldd	r23, Y+51	; 0x33
    19fa:	8c a9       	ldd	r24, Y+52	; 0x34
    19fc:	9d a9       	ldd	r25, Y+53	; 0x35
    19fe:	20 e0       	ldi	r18, 0x00	; 0
    1a00:	30 e0       	ldi	r19, 0x00	; 0
    1a02:	4a ef       	ldi	r20, 0xFA	; 250
    1a04:	54 e4       	ldi	r21, 0x44	; 68
    1a06:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a0a:	dc 01       	movw	r26, r24
    1a0c:	cb 01       	movw	r24, r22
    1a0e:	8e a7       	std	Y+46, r24	; 0x2e
    1a10:	9f a7       	std	Y+47, r25	; 0x2f
    1a12:	a8 ab       	std	Y+48, r26	; 0x30
    1a14:	b9 ab       	std	Y+49, r27	; 0x31
	if (__tmp < 1.0)
    1a16:	6e a5       	ldd	r22, Y+46	; 0x2e
    1a18:	7f a5       	ldd	r23, Y+47	; 0x2f
    1a1a:	88 a9       	ldd	r24, Y+48	; 0x30
    1a1c:	99 a9       	ldd	r25, Y+49	; 0x31
    1a1e:	20 e0       	ldi	r18, 0x00	; 0
    1a20:	30 e0       	ldi	r19, 0x00	; 0
    1a22:	40 e8       	ldi	r20, 0x80	; 128
    1a24:	5f e3       	ldi	r21, 0x3F	; 63
    1a26:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1a2a:	88 23       	and	r24, r24
    1a2c:	2c f4       	brge	.+10     	; 0x1a38 <LCD_VoidInit+0x24a>
		__ticks = 1;
    1a2e:	81 e0       	ldi	r24, 0x01	; 1
    1a30:	90 e0       	ldi	r25, 0x00	; 0
    1a32:	9d a7       	std	Y+45, r25	; 0x2d
    1a34:	8c a7       	std	Y+44, r24	; 0x2c
    1a36:	3f c0       	rjmp	.+126    	; 0x1ab6 <LCD_VoidInit+0x2c8>
	else if (__tmp > 65535)
    1a38:	6e a5       	ldd	r22, Y+46	; 0x2e
    1a3a:	7f a5       	ldd	r23, Y+47	; 0x2f
    1a3c:	88 a9       	ldd	r24, Y+48	; 0x30
    1a3e:	99 a9       	ldd	r25, Y+49	; 0x31
    1a40:	20 e0       	ldi	r18, 0x00	; 0
    1a42:	3f ef       	ldi	r19, 0xFF	; 255
    1a44:	4f e7       	ldi	r20, 0x7F	; 127
    1a46:	57 e4       	ldi	r21, 0x47	; 71
    1a48:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1a4c:	18 16       	cp	r1, r24
    1a4e:	4c f5       	brge	.+82     	; 0x1aa2 <LCD_VoidInit+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a50:	6a a9       	ldd	r22, Y+50	; 0x32
    1a52:	7b a9       	ldd	r23, Y+51	; 0x33
    1a54:	8c a9       	ldd	r24, Y+52	; 0x34
    1a56:	9d a9       	ldd	r25, Y+53	; 0x35
    1a58:	20 e0       	ldi	r18, 0x00	; 0
    1a5a:	30 e0       	ldi	r19, 0x00	; 0
    1a5c:	40 e2       	ldi	r20, 0x20	; 32
    1a5e:	51 e4       	ldi	r21, 0x41	; 65
    1a60:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a64:	dc 01       	movw	r26, r24
    1a66:	cb 01       	movw	r24, r22
    1a68:	bc 01       	movw	r22, r24
    1a6a:	cd 01       	movw	r24, r26
    1a6c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a70:	dc 01       	movw	r26, r24
    1a72:	cb 01       	movw	r24, r22
    1a74:	9d a7       	std	Y+45, r25	; 0x2d
    1a76:	8c a7       	std	Y+44, r24	; 0x2c
    1a78:	0f c0       	rjmp	.+30     	; 0x1a98 <LCD_VoidInit+0x2aa>
    1a7a:	88 ec       	ldi	r24, 0xC8	; 200
    1a7c:	90 e0       	ldi	r25, 0x00	; 0
    1a7e:	9b a7       	std	Y+43, r25	; 0x2b
    1a80:	8a a7       	std	Y+42, r24	; 0x2a
    1a82:	8a a5       	ldd	r24, Y+42	; 0x2a
    1a84:	9b a5       	ldd	r25, Y+43	; 0x2b
    1a86:	01 97       	sbiw	r24, 0x01	; 1
    1a88:	f1 f7       	brne	.-4      	; 0x1a86 <LCD_VoidInit+0x298>
    1a8a:	9b a7       	std	Y+43, r25	; 0x2b
    1a8c:	8a a7       	std	Y+42, r24	; 0x2a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a8e:	8c a5       	ldd	r24, Y+44	; 0x2c
    1a90:	9d a5       	ldd	r25, Y+45	; 0x2d
    1a92:	01 97       	sbiw	r24, 0x01	; 1
    1a94:	9d a7       	std	Y+45, r25	; 0x2d
    1a96:	8c a7       	std	Y+44, r24	; 0x2c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a98:	8c a5       	ldd	r24, Y+44	; 0x2c
    1a9a:	9d a5       	ldd	r25, Y+45	; 0x2d
    1a9c:	00 97       	sbiw	r24, 0x00	; 0
    1a9e:	69 f7       	brne	.-38     	; 0x1a7a <LCD_VoidInit+0x28c>
    1aa0:	24 c0       	rjmp	.+72     	; 0x1aea <LCD_VoidInit+0x2fc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1aa2:	6e a5       	ldd	r22, Y+46	; 0x2e
    1aa4:	7f a5       	ldd	r23, Y+47	; 0x2f
    1aa6:	88 a9       	ldd	r24, Y+48	; 0x30
    1aa8:	99 a9       	ldd	r25, Y+49	; 0x31
    1aaa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1aae:	dc 01       	movw	r26, r24
    1ab0:	cb 01       	movw	r24, r22
    1ab2:	9d a7       	std	Y+45, r25	; 0x2d
    1ab4:	8c a7       	std	Y+44, r24	; 0x2c
    1ab6:	8c a5       	ldd	r24, Y+44	; 0x2c
    1ab8:	9d a5       	ldd	r25, Y+45	; 0x2d
    1aba:	99 a7       	std	Y+41, r25	; 0x29
    1abc:	88 a7       	std	Y+40, r24	; 0x28
    1abe:	88 a5       	ldd	r24, Y+40	; 0x28
    1ac0:	99 a5       	ldd	r25, Y+41	; 0x29
    1ac2:	01 97       	sbiw	r24, 0x01	; 1
    1ac4:	f1 f7       	brne	.-4      	; 0x1ac2 <LCD_VoidInit+0x2d4>
    1ac6:	99 a7       	std	Y+41, r25	; 0x29
    1ac8:	88 a7       	std	Y+40, r24	; 0x28
    1aca:	0f c0       	rjmp	.+30     	; 0x1aea <LCD_VoidInit+0x2fc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1acc:	6f a9       	ldd	r22, Y+55	; 0x37
    1ace:	78 ad       	ldd	r23, Y+56	; 0x38
    1ad0:	89 ad       	ldd	r24, Y+57	; 0x39
    1ad2:	9a ad       	ldd	r25, Y+58	; 0x3a
    1ad4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ad8:	dc 01       	movw	r26, r24
    1ada:	cb 01       	movw	r24, r22
    1adc:	8e ab       	std	Y+54, r24	; 0x36
    1ade:	8e a9       	ldd	r24, Y+54	; 0x36
    1ae0:	8f a3       	std	Y+39, r24	; 0x27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1ae2:	8f a1       	ldd	r24, Y+39	; 0x27
    1ae4:	8a 95       	dec	r24
    1ae6:	f1 f7       	brne	.-4      	; 0x1ae4 <LCD_VoidInit+0x2f6>
    1ae8:	8f a3       	std	Y+39, r24	; 0x27
        _delay_us(40);
        LCD_CheckStatusSendCmnd(0b00001111);
    1aea:	8f e0       	ldi	r24, 0x0F	; 15
    1aec:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
    1af0:	80 e0       	ldi	r24, 0x00	; 0
    1af2:	90 e0       	ldi	r25, 0x00	; 0
    1af4:	a0 e2       	ldi	r26, 0x20	; 32
    1af6:	b2 e4       	ldi	r27, 0x42	; 66
    1af8:	8b a3       	std	Y+35, r24	; 0x23
    1afa:	9c a3       	std	Y+36, r25	; 0x24
    1afc:	ad a3       	std	Y+37, r26	; 0x25
    1afe:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1b00:	6b a1       	ldd	r22, Y+35	; 0x23
    1b02:	7c a1       	ldd	r23, Y+36	; 0x24
    1b04:	8d a1       	ldd	r24, Y+37	; 0x25
    1b06:	9e a1       	ldd	r25, Y+38	; 0x26
    1b08:	2b ea       	ldi	r18, 0xAB	; 171
    1b0a:	3a ea       	ldi	r19, 0xAA	; 170
    1b0c:	4a e2       	ldi	r20, 0x2A	; 42
    1b0e:	50 e4       	ldi	r21, 0x40	; 64
    1b10:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b14:	dc 01       	movw	r26, r24
    1b16:	cb 01       	movw	r24, r22
    1b18:	8f 8f       	std	Y+31, r24	; 0x1f
    1b1a:	98 a3       	std	Y+32, r25	; 0x20
    1b1c:	a9 a3       	std	Y+33, r26	; 0x21
    1b1e:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    1b20:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1b22:	78 a1       	ldd	r23, Y+32	; 0x20
    1b24:	89 a1       	ldd	r24, Y+33	; 0x21
    1b26:	9a a1       	ldd	r25, Y+34	; 0x22
    1b28:	20 e0       	ldi	r18, 0x00	; 0
    1b2a:	30 e0       	ldi	r19, 0x00	; 0
    1b2c:	40 e8       	ldi	r20, 0x80	; 128
    1b2e:	5f e3       	ldi	r21, 0x3F	; 63
    1b30:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1b34:	88 23       	and	r24, r24
    1b36:	1c f4       	brge	.+6      	; 0x1b3e <LCD_VoidInit+0x350>
		__ticks = 1;
    1b38:	81 e0       	ldi	r24, 0x01	; 1
    1b3a:	8e 8f       	std	Y+30, r24	; 0x1e
    1b3c:	91 c0       	rjmp	.+290    	; 0x1c60 <LCD_VoidInit+0x472>
	else if (__tmp > 255)
    1b3e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1b40:	78 a1       	ldd	r23, Y+32	; 0x20
    1b42:	89 a1       	ldd	r24, Y+33	; 0x21
    1b44:	9a a1       	ldd	r25, Y+34	; 0x22
    1b46:	20 e0       	ldi	r18, 0x00	; 0
    1b48:	30 e0       	ldi	r19, 0x00	; 0
    1b4a:	4f e7       	ldi	r20, 0x7F	; 127
    1b4c:	53 e4       	ldi	r21, 0x43	; 67
    1b4e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1b52:	18 16       	cp	r1, r24
    1b54:	0c f0       	brlt	.+2      	; 0x1b58 <LCD_VoidInit+0x36a>
    1b56:	7b c0       	rjmp	.+246    	; 0x1c4e <LCD_VoidInit+0x460>
	{
		_delay_ms(__us / 1000.0);
    1b58:	6b a1       	ldd	r22, Y+35	; 0x23
    1b5a:	7c a1       	ldd	r23, Y+36	; 0x24
    1b5c:	8d a1       	ldd	r24, Y+37	; 0x25
    1b5e:	9e a1       	ldd	r25, Y+38	; 0x26
    1b60:	20 e0       	ldi	r18, 0x00	; 0
    1b62:	30 e0       	ldi	r19, 0x00	; 0
    1b64:	4a e7       	ldi	r20, 0x7A	; 122
    1b66:	54 e4       	ldi	r21, 0x44	; 68
    1b68:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1b6c:	dc 01       	movw	r26, r24
    1b6e:	cb 01       	movw	r24, r22
    1b70:	8a 8f       	std	Y+26, r24	; 0x1a
    1b72:	9b 8f       	std	Y+27, r25	; 0x1b
    1b74:	ac 8f       	std	Y+28, r26	; 0x1c
    1b76:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1b78:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1b7a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1b7c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1b7e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1b80:	20 e0       	ldi	r18, 0x00	; 0
    1b82:	30 e0       	ldi	r19, 0x00	; 0
    1b84:	4a ef       	ldi	r20, 0xFA	; 250
    1b86:	54 e4       	ldi	r21, 0x44	; 68
    1b88:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b8c:	dc 01       	movw	r26, r24
    1b8e:	cb 01       	movw	r24, r22
    1b90:	8e 8b       	std	Y+22, r24	; 0x16
    1b92:	9f 8b       	std	Y+23, r25	; 0x17
    1b94:	a8 8f       	std	Y+24, r26	; 0x18
    1b96:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    1b98:	6e 89       	ldd	r22, Y+22	; 0x16
    1b9a:	7f 89       	ldd	r23, Y+23	; 0x17
    1b9c:	88 8d       	ldd	r24, Y+24	; 0x18
    1b9e:	99 8d       	ldd	r25, Y+25	; 0x19
    1ba0:	20 e0       	ldi	r18, 0x00	; 0
    1ba2:	30 e0       	ldi	r19, 0x00	; 0
    1ba4:	40 e8       	ldi	r20, 0x80	; 128
    1ba6:	5f e3       	ldi	r21, 0x3F	; 63
    1ba8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1bac:	88 23       	and	r24, r24
    1bae:	2c f4       	brge	.+10     	; 0x1bba <LCD_VoidInit+0x3cc>
		__ticks = 1;
    1bb0:	81 e0       	ldi	r24, 0x01	; 1
    1bb2:	90 e0       	ldi	r25, 0x00	; 0
    1bb4:	9d 8b       	std	Y+21, r25	; 0x15
    1bb6:	8c 8b       	std	Y+20, r24	; 0x14
    1bb8:	3f c0       	rjmp	.+126    	; 0x1c38 <LCD_VoidInit+0x44a>
	else if (__tmp > 65535)
    1bba:	6e 89       	ldd	r22, Y+22	; 0x16
    1bbc:	7f 89       	ldd	r23, Y+23	; 0x17
    1bbe:	88 8d       	ldd	r24, Y+24	; 0x18
    1bc0:	99 8d       	ldd	r25, Y+25	; 0x19
    1bc2:	20 e0       	ldi	r18, 0x00	; 0
    1bc4:	3f ef       	ldi	r19, 0xFF	; 255
    1bc6:	4f e7       	ldi	r20, 0x7F	; 127
    1bc8:	57 e4       	ldi	r21, 0x47	; 71
    1bca:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1bce:	18 16       	cp	r1, r24
    1bd0:	4c f5       	brge	.+82     	; 0x1c24 <LCD_VoidInit+0x436>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1bd2:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1bd4:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1bd6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1bd8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1bda:	20 e0       	ldi	r18, 0x00	; 0
    1bdc:	30 e0       	ldi	r19, 0x00	; 0
    1bde:	40 e2       	ldi	r20, 0x20	; 32
    1be0:	51 e4       	ldi	r21, 0x41	; 65
    1be2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1be6:	dc 01       	movw	r26, r24
    1be8:	cb 01       	movw	r24, r22
    1bea:	bc 01       	movw	r22, r24
    1bec:	cd 01       	movw	r24, r26
    1bee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bf2:	dc 01       	movw	r26, r24
    1bf4:	cb 01       	movw	r24, r22
    1bf6:	9d 8b       	std	Y+21, r25	; 0x15
    1bf8:	8c 8b       	std	Y+20, r24	; 0x14
    1bfa:	0f c0       	rjmp	.+30     	; 0x1c1a <LCD_VoidInit+0x42c>
    1bfc:	88 ec       	ldi	r24, 0xC8	; 200
    1bfe:	90 e0       	ldi	r25, 0x00	; 0
    1c00:	9b 8b       	std	Y+19, r25	; 0x13
    1c02:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1c04:	8a 89       	ldd	r24, Y+18	; 0x12
    1c06:	9b 89       	ldd	r25, Y+19	; 0x13
    1c08:	01 97       	sbiw	r24, 0x01	; 1
    1c0a:	f1 f7       	brne	.-4      	; 0x1c08 <LCD_VoidInit+0x41a>
    1c0c:	9b 8b       	std	Y+19, r25	; 0x13
    1c0e:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c10:	8c 89       	ldd	r24, Y+20	; 0x14
    1c12:	9d 89       	ldd	r25, Y+21	; 0x15
    1c14:	01 97       	sbiw	r24, 0x01	; 1
    1c16:	9d 8b       	std	Y+21, r25	; 0x15
    1c18:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c1a:	8c 89       	ldd	r24, Y+20	; 0x14
    1c1c:	9d 89       	ldd	r25, Y+21	; 0x15
    1c1e:	00 97       	sbiw	r24, 0x00	; 0
    1c20:	69 f7       	brne	.-38     	; 0x1bfc <LCD_VoidInit+0x40e>
    1c22:	24 c0       	rjmp	.+72     	; 0x1c6c <LCD_VoidInit+0x47e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c24:	6e 89       	ldd	r22, Y+22	; 0x16
    1c26:	7f 89       	ldd	r23, Y+23	; 0x17
    1c28:	88 8d       	ldd	r24, Y+24	; 0x18
    1c2a:	99 8d       	ldd	r25, Y+25	; 0x19
    1c2c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c30:	dc 01       	movw	r26, r24
    1c32:	cb 01       	movw	r24, r22
    1c34:	9d 8b       	std	Y+21, r25	; 0x15
    1c36:	8c 8b       	std	Y+20, r24	; 0x14
    1c38:	8c 89       	ldd	r24, Y+20	; 0x14
    1c3a:	9d 89       	ldd	r25, Y+21	; 0x15
    1c3c:	99 8b       	std	Y+17, r25	; 0x11
    1c3e:	88 8b       	std	Y+16, r24	; 0x10
    1c40:	88 89       	ldd	r24, Y+16	; 0x10
    1c42:	99 89       	ldd	r25, Y+17	; 0x11
    1c44:	01 97       	sbiw	r24, 0x01	; 1
    1c46:	f1 f7       	brne	.-4      	; 0x1c44 <LCD_VoidInit+0x456>
    1c48:	99 8b       	std	Y+17, r25	; 0x11
    1c4a:	88 8b       	std	Y+16, r24	; 0x10
    1c4c:	0f c0       	rjmp	.+30     	; 0x1c6c <LCD_VoidInit+0x47e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1c4e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1c50:	78 a1       	ldd	r23, Y+32	; 0x20
    1c52:	89 a1       	ldd	r24, Y+33	; 0x21
    1c54:	9a a1       	ldd	r25, Y+34	; 0x22
    1c56:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c5a:	dc 01       	movw	r26, r24
    1c5c:	cb 01       	movw	r24, r22
    1c5e:	8e 8f       	std	Y+30, r24	; 0x1e
    1c60:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c62:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1c64:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c66:	8a 95       	dec	r24
    1c68:	f1 f7       	brne	.-4      	; 0x1c66 <LCD_VoidInit+0x478>
    1c6a:	8f 87       	std	Y+15, r24	; 0x0f
        _delay_us(40);
        LCD_CheckStatusSendCmnd(0b00000001);
    1c6c:	81 e0       	ldi	r24, 0x01	; 1
    1c6e:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
    1c72:	80 e0       	ldi	r24, 0x00	; 0
    1c74:	90 e0       	ldi	r25, 0x00	; 0
    1c76:	a0 e0       	ldi	r26, 0x00	; 0
    1c78:	b0 e4       	ldi	r27, 0x40	; 64
    1c7a:	8b 87       	std	Y+11, r24	; 0x0b
    1c7c:	9c 87       	std	Y+12, r25	; 0x0c
    1c7e:	ad 87       	std	Y+13, r26	; 0x0d
    1c80:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c82:	6b 85       	ldd	r22, Y+11	; 0x0b
    1c84:	7c 85       	ldd	r23, Y+12	; 0x0c
    1c86:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c88:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c8a:	20 e0       	ldi	r18, 0x00	; 0
    1c8c:	30 e0       	ldi	r19, 0x00	; 0
    1c8e:	4a ef       	ldi	r20, 0xFA	; 250
    1c90:	54 e4       	ldi	r21, 0x44	; 68
    1c92:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c96:	dc 01       	movw	r26, r24
    1c98:	cb 01       	movw	r24, r22
    1c9a:	8f 83       	std	Y+7, r24	; 0x07
    1c9c:	98 87       	std	Y+8, r25	; 0x08
    1c9e:	a9 87       	std	Y+9, r26	; 0x09
    1ca0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1ca2:	6f 81       	ldd	r22, Y+7	; 0x07
    1ca4:	78 85       	ldd	r23, Y+8	; 0x08
    1ca6:	89 85       	ldd	r24, Y+9	; 0x09
    1ca8:	9a 85       	ldd	r25, Y+10	; 0x0a
    1caa:	20 e0       	ldi	r18, 0x00	; 0
    1cac:	30 e0       	ldi	r19, 0x00	; 0
    1cae:	40 e8       	ldi	r20, 0x80	; 128
    1cb0:	5f e3       	ldi	r21, 0x3F	; 63
    1cb2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1cb6:	88 23       	and	r24, r24
    1cb8:	2c f4       	brge	.+10     	; 0x1cc4 <LCD_VoidInit+0x4d6>
		__ticks = 1;
    1cba:	81 e0       	ldi	r24, 0x01	; 1
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	9e 83       	std	Y+6, r25	; 0x06
    1cc0:	8d 83       	std	Y+5, r24	; 0x05
    1cc2:	3f c0       	rjmp	.+126    	; 0x1d42 <LCD_VoidInit+0x554>
	else if (__tmp > 65535)
    1cc4:	6f 81       	ldd	r22, Y+7	; 0x07
    1cc6:	78 85       	ldd	r23, Y+8	; 0x08
    1cc8:	89 85       	ldd	r24, Y+9	; 0x09
    1cca:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ccc:	20 e0       	ldi	r18, 0x00	; 0
    1cce:	3f ef       	ldi	r19, 0xFF	; 255
    1cd0:	4f e7       	ldi	r20, 0x7F	; 127
    1cd2:	57 e4       	ldi	r21, 0x47	; 71
    1cd4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1cd8:	18 16       	cp	r1, r24
    1cda:	4c f5       	brge	.+82     	; 0x1d2e <LCD_VoidInit+0x540>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1cdc:	6b 85       	ldd	r22, Y+11	; 0x0b
    1cde:	7c 85       	ldd	r23, Y+12	; 0x0c
    1ce0:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ce2:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ce4:	20 e0       	ldi	r18, 0x00	; 0
    1ce6:	30 e0       	ldi	r19, 0x00	; 0
    1ce8:	40 e2       	ldi	r20, 0x20	; 32
    1cea:	51 e4       	ldi	r21, 0x41	; 65
    1cec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cf0:	dc 01       	movw	r26, r24
    1cf2:	cb 01       	movw	r24, r22
    1cf4:	bc 01       	movw	r22, r24
    1cf6:	cd 01       	movw	r24, r26
    1cf8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cfc:	dc 01       	movw	r26, r24
    1cfe:	cb 01       	movw	r24, r22
    1d00:	9e 83       	std	Y+6, r25	; 0x06
    1d02:	8d 83       	std	Y+5, r24	; 0x05
    1d04:	0f c0       	rjmp	.+30     	; 0x1d24 <LCD_VoidInit+0x536>
    1d06:	88 ec       	ldi	r24, 0xC8	; 200
    1d08:	90 e0       	ldi	r25, 0x00	; 0
    1d0a:	9c 83       	std	Y+4, r25	; 0x04
    1d0c:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d10:	9c 81       	ldd	r25, Y+4	; 0x04
    1d12:	01 97       	sbiw	r24, 0x01	; 1
    1d14:	f1 f7       	brne	.-4      	; 0x1d12 <LCD_VoidInit+0x524>
    1d16:	9c 83       	std	Y+4, r25	; 0x04
    1d18:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d1a:	8d 81       	ldd	r24, Y+5	; 0x05
    1d1c:	9e 81       	ldd	r25, Y+6	; 0x06
    1d1e:	01 97       	sbiw	r24, 0x01	; 1
    1d20:	9e 83       	std	Y+6, r25	; 0x06
    1d22:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d24:	8d 81       	ldd	r24, Y+5	; 0x05
    1d26:	9e 81       	ldd	r25, Y+6	; 0x06
    1d28:	00 97       	sbiw	r24, 0x00	; 0
    1d2a:	69 f7       	brne	.-38     	; 0x1d06 <LCD_VoidInit+0x518>
    1d2c:	14 c0       	rjmp	.+40     	; 0x1d56 <LCD_VoidInit+0x568>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d2e:	6f 81       	ldd	r22, Y+7	; 0x07
    1d30:	78 85       	ldd	r23, Y+8	; 0x08
    1d32:	89 85       	ldd	r24, Y+9	; 0x09
    1d34:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d36:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d3a:	dc 01       	movw	r26, r24
    1d3c:	cb 01       	movw	r24, r22
    1d3e:	9e 83       	std	Y+6, r25	; 0x06
    1d40:	8d 83       	std	Y+5, r24	; 0x05
    1d42:	8d 81       	ldd	r24, Y+5	; 0x05
    1d44:	9e 81       	ldd	r25, Y+6	; 0x06
    1d46:	9a 83       	std	Y+2, r25	; 0x02
    1d48:	89 83       	std	Y+1, r24	; 0x01
    1d4a:	89 81       	ldd	r24, Y+1	; 0x01
    1d4c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d4e:	01 97       	sbiw	r24, 0x01	; 1
    1d50:	f1 f7       	brne	.-4      	; 0x1d4e <LCD_VoidInit+0x560>
    1d52:	9a 83       	std	Y+2, r25	; 0x02
    1d54:	89 83       	std	Y+1, r24	; 0x01
        _delay_ms(2);
        LCD_CheckStatusSendCmnd(0b00000110);
    1d56:	86 e0       	ldi	r24, 0x06	; 6
    1d58:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
}
    1d5c:	c4 5b       	subi	r28, 0xB4	; 180
    1d5e:	df 4f       	sbci	r29, 0xFF	; 255
    1d60:	0f b6       	in	r0, 0x3f	; 63
    1d62:	f8 94       	cli
    1d64:	de bf       	out	0x3e, r29	; 62
    1d66:	0f be       	out	0x3f, r0	; 63
    1d68:	cd bf       	out	0x3d, r28	; 61
    1d6a:	cf 91       	pop	r28
    1d6c:	df 91       	pop	r29
    1d6e:	1f 91       	pop	r17
    1d70:	0f 91       	pop	r16
    1d72:	08 95       	ret

00001d74 <LCD_CheckStatusSendCmnd>:
CheckStatus LCD_CheckStatusSendCmnd(_uint8 Copy__Uint8Cmnd)
{
    1d74:	df 93       	push	r29
    1d76:	cf 93       	push	r28
    1d78:	cd b7       	in	r28, 0x3d	; 61
    1d7a:	de b7       	in	r29, 0x3e	; 62
    1d7c:	e2 97       	sbiw	r28, 0x32	; 50
    1d7e:	0f b6       	in	r0, 0x3f	; 63
    1d80:	f8 94       	cli
    1d82:	de bf       	out	0x3e, r29	; 62
    1d84:	0f be       	out	0x3f, r0	; 63
    1d86:	cd bf       	out	0x3d, r28	; 61
    1d88:	8a ab       	std	Y+50, r24	; 0x32
        CheckStatus Local_CheckStausReturnValue = CHECK_SUCCESS;
    1d8a:	19 aa       	std	Y+49, r1	; 0x31
         3-Send CMND byte  to the Data Pins of LCD
         4-PULSE of Enable E = 1 ,E = 0
        */
        if (Copy__Uint8Cmnd <= 255)
        {
                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_RS_PIN, DIO__UINT8_LOW);
    1d8c:	83 e0       	ldi	r24, 0x03	; 3
    1d8e:	60 e0       	ldi	r22, 0x00	; 0
    1d90:	40 e0       	ldi	r20, 0x00	; 0
    1d92:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_RW_PIN, DIO__UINT8_LOW);
    1d96:	83 e0       	ldi	r24, 0x03	; 3
    1d98:	61 e0       	ldi	r22, 0x01	; 1
    1d9a:	40 e0       	ldi	r20, 0x00	; 0
    1d9c:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>

                DIO__CheckStatusSetPortValue(LCD__UINT8_DATA_PORT, Copy__Uint8Cmnd);
    1da0:	82 e0       	ldi	r24, 0x02	; 2
    1da2:	6a a9       	ldd	r22, Y+50	; 0x32
    1da4:	0e 94 4a 0b 	call	0x1694	; 0x1694 <DIO__CheckStatusSetPortValue>

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_E_PIN, DIO__UINT8_HIGH);
    1da8:	83 e0       	ldi	r24, 0x03	; 3
    1daa:	62 e0       	ldi	r22, 0x02	; 2
    1dac:	41 e0       	ldi	r20, 0x01	; 1
    1dae:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>
    1db2:	80 e0       	ldi	r24, 0x00	; 0
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	a0 e8       	ldi	r26, 0x80	; 128
    1db8:	bf e3       	ldi	r27, 0x3F	; 63
    1dba:	8d a7       	std	Y+45, r24	; 0x2d
    1dbc:	9e a7       	std	Y+46, r25	; 0x2e
    1dbe:	af a7       	std	Y+47, r26	; 0x2f
    1dc0:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1dc2:	6d a5       	ldd	r22, Y+45	; 0x2d
    1dc4:	7e a5       	ldd	r23, Y+46	; 0x2e
    1dc6:	8f a5       	ldd	r24, Y+47	; 0x2f
    1dc8:	98 a9       	ldd	r25, Y+48	; 0x30
    1dca:	2b ea       	ldi	r18, 0xAB	; 171
    1dcc:	3a ea       	ldi	r19, 0xAA	; 170
    1dce:	4a e2       	ldi	r20, 0x2A	; 42
    1dd0:	50 e4       	ldi	r21, 0x40	; 64
    1dd2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1dd6:	dc 01       	movw	r26, r24
    1dd8:	cb 01       	movw	r24, r22
    1dda:	89 a7       	std	Y+41, r24	; 0x29
    1ddc:	9a a7       	std	Y+42, r25	; 0x2a
    1dde:	ab a7       	std	Y+43, r26	; 0x2b
    1de0:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    1de2:	69 a5       	ldd	r22, Y+41	; 0x29
    1de4:	7a a5       	ldd	r23, Y+42	; 0x2a
    1de6:	8b a5       	ldd	r24, Y+43	; 0x2b
    1de8:	9c a5       	ldd	r25, Y+44	; 0x2c
    1dea:	20 e0       	ldi	r18, 0x00	; 0
    1dec:	30 e0       	ldi	r19, 0x00	; 0
    1dee:	40 e8       	ldi	r20, 0x80	; 128
    1df0:	5f e3       	ldi	r21, 0x3F	; 63
    1df2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1df6:	88 23       	and	r24, r24
    1df8:	1c f4       	brge	.+6      	; 0x1e00 <LCD_CheckStatusSendCmnd+0x8c>
		__ticks = 1;
    1dfa:	81 e0       	ldi	r24, 0x01	; 1
    1dfc:	88 a7       	std	Y+40, r24	; 0x28
    1dfe:	91 c0       	rjmp	.+290    	; 0x1f22 <LCD_CheckStatusSendCmnd+0x1ae>
	else if (__tmp > 255)
    1e00:	69 a5       	ldd	r22, Y+41	; 0x29
    1e02:	7a a5       	ldd	r23, Y+42	; 0x2a
    1e04:	8b a5       	ldd	r24, Y+43	; 0x2b
    1e06:	9c a5       	ldd	r25, Y+44	; 0x2c
    1e08:	20 e0       	ldi	r18, 0x00	; 0
    1e0a:	30 e0       	ldi	r19, 0x00	; 0
    1e0c:	4f e7       	ldi	r20, 0x7F	; 127
    1e0e:	53 e4       	ldi	r21, 0x43	; 67
    1e10:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1e14:	18 16       	cp	r1, r24
    1e16:	0c f0       	brlt	.+2      	; 0x1e1a <LCD_CheckStatusSendCmnd+0xa6>
    1e18:	7b c0       	rjmp	.+246    	; 0x1f10 <LCD_CheckStatusSendCmnd+0x19c>
	{
		_delay_ms(__us / 1000.0);
    1e1a:	6d a5       	ldd	r22, Y+45	; 0x2d
    1e1c:	7e a5       	ldd	r23, Y+46	; 0x2e
    1e1e:	8f a5       	ldd	r24, Y+47	; 0x2f
    1e20:	98 a9       	ldd	r25, Y+48	; 0x30
    1e22:	20 e0       	ldi	r18, 0x00	; 0
    1e24:	30 e0       	ldi	r19, 0x00	; 0
    1e26:	4a e7       	ldi	r20, 0x7A	; 122
    1e28:	54 e4       	ldi	r21, 0x44	; 68
    1e2a:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1e2e:	dc 01       	movw	r26, r24
    1e30:	cb 01       	movw	r24, r22
    1e32:	8c a3       	std	Y+36, r24	; 0x24
    1e34:	9d a3       	std	Y+37, r25	; 0x25
    1e36:	ae a3       	std	Y+38, r26	; 0x26
    1e38:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1e3a:	6c a1       	ldd	r22, Y+36	; 0x24
    1e3c:	7d a1       	ldd	r23, Y+37	; 0x25
    1e3e:	8e a1       	ldd	r24, Y+38	; 0x26
    1e40:	9f a1       	ldd	r25, Y+39	; 0x27
    1e42:	20 e0       	ldi	r18, 0x00	; 0
    1e44:	30 e0       	ldi	r19, 0x00	; 0
    1e46:	4a ef       	ldi	r20, 0xFA	; 250
    1e48:	54 e4       	ldi	r21, 0x44	; 68
    1e4a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e4e:	dc 01       	movw	r26, r24
    1e50:	cb 01       	movw	r24, r22
    1e52:	88 a3       	std	Y+32, r24	; 0x20
    1e54:	99 a3       	std	Y+33, r25	; 0x21
    1e56:	aa a3       	std	Y+34, r26	; 0x22
    1e58:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    1e5a:	68 a1       	ldd	r22, Y+32	; 0x20
    1e5c:	79 a1       	ldd	r23, Y+33	; 0x21
    1e5e:	8a a1       	ldd	r24, Y+34	; 0x22
    1e60:	9b a1       	ldd	r25, Y+35	; 0x23
    1e62:	20 e0       	ldi	r18, 0x00	; 0
    1e64:	30 e0       	ldi	r19, 0x00	; 0
    1e66:	40 e8       	ldi	r20, 0x80	; 128
    1e68:	5f e3       	ldi	r21, 0x3F	; 63
    1e6a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1e6e:	88 23       	and	r24, r24
    1e70:	2c f4       	brge	.+10     	; 0x1e7c <LCD_CheckStatusSendCmnd+0x108>
		__ticks = 1;
    1e72:	81 e0       	ldi	r24, 0x01	; 1
    1e74:	90 e0       	ldi	r25, 0x00	; 0
    1e76:	9f 8f       	std	Y+31, r25	; 0x1f
    1e78:	8e 8f       	std	Y+30, r24	; 0x1e
    1e7a:	3f c0       	rjmp	.+126    	; 0x1efa <LCD_CheckStatusSendCmnd+0x186>
	else if (__tmp > 65535)
    1e7c:	68 a1       	ldd	r22, Y+32	; 0x20
    1e7e:	79 a1       	ldd	r23, Y+33	; 0x21
    1e80:	8a a1       	ldd	r24, Y+34	; 0x22
    1e82:	9b a1       	ldd	r25, Y+35	; 0x23
    1e84:	20 e0       	ldi	r18, 0x00	; 0
    1e86:	3f ef       	ldi	r19, 0xFF	; 255
    1e88:	4f e7       	ldi	r20, 0x7F	; 127
    1e8a:	57 e4       	ldi	r21, 0x47	; 71
    1e8c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1e90:	18 16       	cp	r1, r24
    1e92:	4c f5       	brge	.+82     	; 0x1ee6 <LCD_CheckStatusSendCmnd+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1e94:	6c a1       	ldd	r22, Y+36	; 0x24
    1e96:	7d a1       	ldd	r23, Y+37	; 0x25
    1e98:	8e a1       	ldd	r24, Y+38	; 0x26
    1e9a:	9f a1       	ldd	r25, Y+39	; 0x27
    1e9c:	20 e0       	ldi	r18, 0x00	; 0
    1e9e:	30 e0       	ldi	r19, 0x00	; 0
    1ea0:	40 e2       	ldi	r20, 0x20	; 32
    1ea2:	51 e4       	ldi	r21, 0x41	; 65
    1ea4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ea8:	dc 01       	movw	r26, r24
    1eaa:	cb 01       	movw	r24, r22
    1eac:	bc 01       	movw	r22, r24
    1eae:	cd 01       	movw	r24, r26
    1eb0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1eb4:	dc 01       	movw	r26, r24
    1eb6:	cb 01       	movw	r24, r22
    1eb8:	9f 8f       	std	Y+31, r25	; 0x1f
    1eba:	8e 8f       	std	Y+30, r24	; 0x1e
    1ebc:	0f c0       	rjmp	.+30     	; 0x1edc <LCD_CheckStatusSendCmnd+0x168>
    1ebe:	88 ec       	ldi	r24, 0xC8	; 200
    1ec0:	90 e0       	ldi	r25, 0x00	; 0
    1ec2:	9d 8f       	std	Y+29, r25	; 0x1d
    1ec4:	8c 8f       	std	Y+28, r24	; 0x1c
    1ec6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1ec8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1eca:	01 97       	sbiw	r24, 0x01	; 1
    1ecc:	f1 f7       	brne	.-4      	; 0x1eca <LCD_CheckStatusSendCmnd+0x156>
    1ece:	9d 8f       	std	Y+29, r25	; 0x1d
    1ed0:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ed2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ed4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1ed6:	01 97       	sbiw	r24, 0x01	; 1
    1ed8:	9f 8f       	std	Y+31, r25	; 0x1f
    1eda:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1edc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ede:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1ee0:	00 97       	sbiw	r24, 0x00	; 0
    1ee2:	69 f7       	brne	.-38     	; 0x1ebe <LCD_CheckStatusSendCmnd+0x14a>
    1ee4:	24 c0       	rjmp	.+72     	; 0x1f2e <LCD_CheckStatusSendCmnd+0x1ba>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ee6:	68 a1       	ldd	r22, Y+32	; 0x20
    1ee8:	79 a1       	ldd	r23, Y+33	; 0x21
    1eea:	8a a1       	ldd	r24, Y+34	; 0x22
    1eec:	9b a1       	ldd	r25, Y+35	; 0x23
    1eee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ef2:	dc 01       	movw	r26, r24
    1ef4:	cb 01       	movw	r24, r22
    1ef6:	9f 8f       	std	Y+31, r25	; 0x1f
    1ef8:	8e 8f       	std	Y+30, r24	; 0x1e
    1efa:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1efc:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1efe:	9b 8f       	std	Y+27, r25	; 0x1b
    1f00:	8a 8f       	std	Y+26, r24	; 0x1a
    1f02:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f04:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1f06:	01 97       	sbiw	r24, 0x01	; 1
    1f08:	f1 f7       	brne	.-4      	; 0x1f06 <LCD_CheckStatusSendCmnd+0x192>
    1f0a:	9b 8f       	std	Y+27, r25	; 0x1b
    1f0c:	8a 8f       	std	Y+26, r24	; 0x1a
    1f0e:	0f c0       	rjmp	.+30     	; 0x1f2e <LCD_CheckStatusSendCmnd+0x1ba>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1f10:	69 a5       	ldd	r22, Y+41	; 0x29
    1f12:	7a a5       	ldd	r23, Y+42	; 0x2a
    1f14:	8b a5       	ldd	r24, Y+43	; 0x2b
    1f16:	9c a5       	ldd	r25, Y+44	; 0x2c
    1f18:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f1c:	dc 01       	movw	r26, r24
    1f1e:	cb 01       	movw	r24, r22
    1f20:	88 a7       	std	Y+40, r24	; 0x28
    1f22:	88 a5       	ldd	r24, Y+40	; 0x28
    1f24:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1f26:	89 8d       	ldd	r24, Y+25	; 0x19
    1f28:	8a 95       	dec	r24
    1f2a:	f1 f7       	brne	.-4      	; 0x1f28 <LCD_CheckStatusSendCmnd+0x1b4>
    1f2c:	89 8f       	std	Y+25, r24	; 0x19
                _delay_us(1);
                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_E_PIN, DIO__UINT8_LOW);
    1f2e:	83 e0       	ldi	r24, 0x03	; 3
    1f30:	62 e0       	ldi	r22, 0x02	; 2
    1f32:	40 e0       	ldi	r20, 0x00	; 0
    1f34:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>
    1f38:	80 e0       	ldi	r24, 0x00	; 0
    1f3a:	90 e0       	ldi	r25, 0x00	; 0
    1f3c:	a0 e8       	ldi	r26, 0x80	; 128
    1f3e:	bf e3       	ldi	r27, 0x3F	; 63
    1f40:	8d 8b       	std	Y+21, r24	; 0x15
    1f42:	9e 8b       	std	Y+22, r25	; 0x16
    1f44:	af 8b       	std	Y+23, r26	; 0x17
    1f46:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1f48:	6d 89       	ldd	r22, Y+21	; 0x15
    1f4a:	7e 89       	ldd	r23, Y+22	; 0x16
    1f4c:	8f 89       	ldd	r24, Y+23	; 0x17
    1f4e:	98 8d       	ldd	r25, Y+24	; 0x18
    1f50:	2b ea       	ldi	r18, 0xAB	; 171
    1f52:	3a ea       	ldi	r19, 0xAA	; 170
    1f54:	4a e2       	ldi	r20, 0x2A	; 42
    1f56:	50 e4       	ldi	r21, 0x40	; 64
    1f58:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f5c:	dc 01       	movw	r26, r24
    1f5e:	cb 01       	movw	r24, r22
    1f60:	89 8b       	std	Y+17, r24	; 0x11
    1f62:	9a 8b       	std	Y+18, r25	; 0x12
    1f64:	ab 8b       	std	Y+19, r26	; 0x13
    1f66:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    1f68:	69 89       	ldd	r22, Y+17	; 0x11
    1f6a:	7a 89       	ldd	r23, Y+18	; 0x12
    1f6c:	8b 89       	ldd	r24, Y+19	; 0x13
    1f6e:	9c 89       	ldd	r25, Y+20	; 0x14
    1f70:	20 e0       	ldi	r18, 0x00	; 0
    1f72:	30 e0       	ldi	r19, 0x00	; 0
    1f74:	40 e8       	ldi	r20, 0x80	; 128
    1f76:	5f e3       	ldi	r21, 0x3F	; 63
    1f78:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1f7c:	88 23       	and	r24, r24
    1f7e:	1c f4       	brge	.+6      	; 0x1f86 <LCD_CheckStatusSendCmnd+0x212>
		__ticks = 1;
    1f80:	81 e0       	ldi	r24, 0x01	; 1
    1f82:	88 8b       	std	Y+16, r24	; 0x10
    1f84:	91 c0       	rjmp	.+290    	; 0x20a8 <LCD_CheckStatusSendCmnd+0x334>
	else if (__tmp > 255)
    1f86:	69 89       	ldd	r22, Y+17	; 0x11
    1f88:	7a 89       	ldd	r23, Y+18	; 0x12
    1f8a:	8b 89       	ldd	r24, Y+19	; 0x13
    1f8c:	9c 89       	ldd	r25, Y+20	; 0x14
    1f8e:	20 e0       	ldi	r18, 0x00	; 0
    1f90:	30 e0       	ldi	r19, 0x00	; 0
    1f92:	4f e7       	ldi	r20, 0x7F	; 127
    1f94:	53 e4       	ldi	r21, 0x43	; 67
    1f96:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1f9a:	18 16       	cp	r1, r24
    1f9c:	0c f0       	brlt	.+2      	; 0x1fa0 <LCD_CheckStatusSendCmnd+0x22c>
    1f9e:	7b c0       	rjmp	.+246    	; 0x2096 <LCD_CheckStatusSendCmnd+0x322>
	{
		_delay_ms(__us / 1000.0);
    1fa0:	6d 89       	ldd	r22, Y+21	; 0x15
    1fa2:	7e 89       	ldd	r23, Y+22	; 0x16
    1fa4:	8f 89       	ldd	r24, Y+23	; 0x17
    1fa6:	98 8d       	ldd	r25, Y+24	; 0x18
    1fa8:	20 e0       	ldi	r18, 0x00	; 0
    1faa:	30 e0       	ldi	r19, 0x00	; 0
    1fac:	4a e7       	ldi	r20, 0x7A	; 122
    1fae:	54 e4       	ldi	r21, 0x44	; 68
    1fb0:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1fb4:	dc 01       	movw	r26, r24
    1fb6:	cb 01       	movw	r24, r22
    1fb8:	8c 87       	std	Y+12, r24	; 0x0c
    1fba:	9d 87       	std	Y+13, r25	; 0x0d
    1fbc:	ae 87       	std	Y+14, r26	; 0x0e
    1fbe:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1fc0:	6c 85       	ldd	r22, Y+12	; 0x0c
    1fc2:	7d 85       	ldd	r23, Y+13	; 0x0d
    1fc4:	8e 85       	ldd	r24, Y+14	; 0x0e
    1fc6:	9f 85       	ldd	r25, Y+15	; 0x0f
    1fc8:	20 e0       	ldi	r18, 0x00	; 0
    1fca:	30 e0       	ldi	r19, 0x00	; 0
    1fcc:	4a ef       	ldi	r20, 0xFA	; 250
    1fce:	54 e4       	ldi	r21, 0x44	; 68
    1fd0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1fd4:	dc 01       	movw	r26, r24
    1fd6:	cb 01       	movw	r24, r22
    1fd8:	88 87       	std	Y+8, r24	; 0x08
    1fda:	99 87       	std	Y+9, r25	; 0x09
    1fdc:	aa 87       	std	Y+10, r26	; 0x0a
    1fde:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    1fe0:	68 85       	ldd	r22, Y+8	; 0x08
    1fe2:	79 85       	ldd	r23, Y+9	; 0x09
    1fe4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1fe6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1fe8:	20 e0       	ldi	r18, 0x00	; 0
    1fea:	30 e0       	ldi	r19, 0x00	; 0
    1fec:	40 e8       	ldi	r20, 0x80	; 128
    1fee:	5f e3       	ldi	r21, 0x3F	; 63
    1ff0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1ff4:	88 23       	and	r24, r24
    1ff6:	2c f4       	brge	.+10     	; 0x2002 <LCD_CheckStatusSendCmnd+0x28e>
		__ticks = 1;
    1ff8:	81 e0       	ldi	r24, 0x01	; 1
    1ffa:	90 e0       	ldi	r25, 0x00	; 0
    1ffc:	9f 83       	std	Y+7, r25	; 0x07
    1ffe:	8e 83       	std	Y+6, r24	; 0x06
    2000:	3f c0       	rjmp	.+126    	; 0x2080 <LCD_CheckStatusSendCmnd+0x30c>
	else if (__tmp > 65535)
    2002:	68 85       	ldd	r22, Y+8	; 0x08
    2004:	79 85       	ldd	r23, Y+9	; 0x09
    2006:	8a 85       	ldd	r24, Y+10	; 0x0a
    2008:	9b 85       	ldd	r25, Y+11	; 0x0b
    200a:	20 e0       	ldi	r18, 0x00	; 0
    200c:	3f ef       	ldi	r19, 0xFF	; 255
    200e:	4f e7       	ldi	r20, 0x7F	; 127
    2010:	57 e4       	ldi	r21, 0x47	; 71
    2012:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2016:	18 16       	cp	r1, r24
    2018:	4c f5       	brge	.+82     	; 0x206c <LCD_CheckStatusSendCmnd+0x2f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    201a:	6c 85       	ldd	r22, Y+12	; 0x0c
    201c:	7d 85       	ldd	r23, Y+13	; 0x0d
    201e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2020:	9f 85       	ldd	r25, Y+15	; 0x0f
    2022:	20 e0       	ldi	r18, 0x00	; 0
    2024:	30 e0       	ldi	r19, 0x00	; 0
    2026:	40 e2       	ldi	r20, 0x20	; 32
    2028:	51 e4       	ldi	r21, 0x41	; 65
    202a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    202e:	dc 01       	movw	r26, r24
    2030:	cb 01       	movw	r24, r22
    2032:	bc 01       	movw	r22, r24
    2034:	cd 01       	movw	r24, r26
    2036:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    203a:	dc 01       	movw	r26, r24
    203c:	cb 01       	movw	r24, r22
    203e:	9f 83       	std	Y+7, r25	; 0x07
    2040:	8e 83       	std	Y+6, r24	; 0x06
    2042:	0f c0       	rjmp	.+30     	; 0x2062 <LCD_CheckStatusSendCmnd+0x2ee>
    2044:	88 ec       	ldi	r24, 0xC8	; 200
    2046:	90 e0       	ldi	r25, 0x00	; 0
    2048:	9d 83       	std	Y+5, r25	; 0x05
    204a:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    204c:	8c 81       	ldd	r24, Y+4	; 0x04
    204e:	9d 81       	ldd	r25, Y+5	; 0x05
    2050:	01 97       	sbiw	r24, 0x01	; 1
    2052:	f1 f7       	brne	.-4      	; 0x2050 <LCD_CheckStatusSendCmnd+0x2dc>
    2054:	9d 83       	std	Y+5, r25	; 0x05
    2056:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2058:	8e 81       	ldd	r24, Y+6	; 0x06
    205a:	9f 81       	ldd	r25, Y+7	; 0x07
    205c:	01 97       	sbiw	r24, 0x01	; 1
    205e:	9f 83       	std	Y+7, r25	; 0x07
    2060:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2062:	8e 81       	ldd	r24, Y+6	; 0x06
    2064:	9f 81       	ldd	r25, Y+7	; 0x07
    2066:	00 97       	sbiw	r24, 0x00	; 0
    2068:	69 f7       	brne	.-38     	; 0x2044 <LCD_CheckStatusSendCmnd+0x2d0>
    206a:	24 c0       	rjmp	.+72     	; 0x20b4 <LCD_CheckStatusSendCmnd+0x340>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    206c:	68 85       	ldd	r22, Y+8	; 0x08
    206e:	79 85       	ldd	r23, Y+9	; 0x09
    2070:	8a 85       	ldd	r24, Y+10	; 0x0a
    2072:	9b 85       	ldd	r25, Y+11	; 0x0b
    2074:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2078:	dc 01       	movw	r26, r24
    207a:	cb 01       	movw	r24, r22
    207c:	9f 83       	std	Y+7, r25	; 0x07
    207e:	8e 83       	std	Y+6, r24	; 0x06
    2080:	8e 81       	ldd	r24, Y+6	; 0x06
    2082:	9f 81       	ldd	r25, Y+7	; 0x07
    2084:	9b 83       	std	Y+3, r25	; 0x03
    2086:	8a 83       	std	Y+2, r24	; 0x02
    2088:	8a 81       	ldd	r24, Y+2	; 0x02
    208a:	9b 81       	ldd	r25, Y+3	; 0x03
    208c:	01 97       	sbiw	r24, 0x01	; 1
    208e:	f1 f7       	brne	.-4      	; 0x208c <LCD_CheckStatusSendCmnd+0x318>
    2090:	9b 83       	std	Y+3, r25	; 0x03
    2092:	8a 83       	std	Y+2, r24	; 0x02
    2094:	0f c0       	rjmp	.+30     	; 0x20b4 <LCD_CheckStatusSendCmnd+0x340>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2096:	69 89       	ldd	r22, Y+17	; 0x11
    2098:	7a 89       	ldd	r23, Y+18	; 0x12
    209a:	8b 89       	ldd	r24, Y+19	; 0x13
    209c:	9c 89       	ldd	r25, Y+20	; 0x14
    209e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    20a2:	dc 01       	movw	r26, r24
    20a4:	cb 01       	movw	r24, r22
    20a6:	88 8b       	std	Y+16, r24	; 0x10
    20a8:	88 89       	ldd	r24, Y+16	; 0x10
    20aa:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    20ac:	89 81       	ldd	r24, Y+1	; 0x01
    20ae:	8a 95       	dec	r24
    20b0:	f1 f7       	brne	.-4      	; 0x20ae <LCD_CheckStatusSendCmnd+0x33a>
    20b2:	89 83       	std	Y+1, r24	; 0x01
        }
        else
        {
                Local_CheckStausReturnValue = CHECK_FAIL;
        }
        return Local_CheckStausReturnValue;
    20b4:	89 a9       	ldd	r24, Y+49	; 0x31
}
    20b6:	e2 96       	adiw	r28, 0x32	; 50
    20b8:	0f b6       	in	r0, 0x3f	; 63
    20ba:	f8 94       	cli
    20bc:	de bf       	out	0x3e, r29	; 62
    20be:	0f be       	out	0x3f, r0	; 63
    20c0:	cd bf       	out	0x3d, r28	; 61
    20c2:	cf 91       	pop	r28
    20c4:	df 91       	pop	r29
    20c6:	08 95       	ret

000020c8 <LCD_CheckStatusSendChar>:
CheckStatus LCD_CheckStatusSendChar(_uint8 Copy__Uint8Char)
{
    20c8:	df 93       	push	r29
    20ca:	cf 93       	push	r28
    20cc:	cd b7       	in	r28, 0x3d	; 61
    20ce:	de b7       	in	r29, 0x3e	; 62
    20d0:	e2 97       	sbiw	r28, 0x32	; 50
    20d2:	0f b6       	in	r0, 0x3f	; 63
    20d4:	f8 94       	cli
    20d6:	de bf       	out	0x3e, r29	; 62
    20d8:	0f be       	out	0x3f, r0	; 63
    20da:	cd bf       	out	0x3d, r28	; 61
    20dc:	8a ab       	std	Y+50, r24	; 0x32
        CheckStatus Local_CheckStausReturnValue = CHECK_SUCCESS;
    20de:	19 aa       	std	Y+49, r1	; 0x31
         3-Send CMND byte  to the Data Pins of LCD
         4-PULSE of Enable E = 1 ,E = 0
        */
        if (Copy__Uint8Char <= 255)
        {
                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_RS_PIN, DIO__UINT8_HIGH);
    20e0:	83 e0       	ldi	r24, 0x03	; 3
    20e2:	60 e0       	ldi	r22, 0x00	; 0
    20e4:	41 e0       	ldi	r20, 0x01	; 1
    20e6:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_RW_PIN, DIO__UINT8_LOW);
    20ea:	83 e0       	ldi	r24, 0x03	; 3
    20ec:	61 e0       	ldi	r22, 0x01	; 1
    20ee:	40 e0       	ldi	r20, 0x00	; 0
    20f0:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>

                DIO__CheckStatusSetPortValue(LCD__UINT8_DATA_PORT, Copy__Uint8Char);
    20f4:	82 e0       	ldi	r24, 0x02	; 2
    20f6:	6a a9       	ldd	r22, Y+50	; 0x32
    20f8:	0e 94 4a 0b 	call	0x1694	; 0x1694 <DIO__CheckStatusSetPortValue>

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_E_PIN, DIO__UINT8_HIGH);
    20fc:	83 e0       	ldi	r24, 0x03	; 3
    20fe:	62 e0       	ldi	r22, 0x02	; 2
    2100:	41 e0       	ldi	r20, 0x01	; 1
    2102:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>
    2106:	80 e0       	ldi	r24, 0x00	; 0
    2108:	90 e0       	ldi	r25, 0x00	; 0
    210a:	a0 e8       	ldi	r26, 0x80	; 128
    210c:	bf e3       	ldi	r27, 0x3F	; 63
    210e:	8d a7       	std	Y+45, r24	; 0x2d
    2110:	9e a7       	std	Y+46, r25	; 0x2e
    2112:	af a7       	std	Y+47, r26	; 0x2f
    2114:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    2116:	6d a5       	ldd	r22, Y+45	; 0x2d
    2118:	7e a5       	ldd	r23, Y+46	; 0x2e
    211a:	8f a5       	ldd	r24, Y+47	; 0x2f
    211c:	98 a9       	ldd	r25, Y+48	; 0x30
    211e:	2b ea       	ldi	r18, 0xAB	; 171
    2120:	3a ea       	ldi	r19, 0xAA	; 170
    2122:	4a e2       	ldi	r20, 0x2A	; 42
    2124:	50 e4       	ldi	r21, 0x40	; 64
    2126:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    212a:	dc 01       	movw	r26, r24
    212c:	cb 01       	movw	r24, r22
    212e:	89 a7       	std	Y+41, r24	; 0x29
    2130:	9a a7       	std	Y+42, r25	; 0x2a
    2132:	ab a7       	std	Y+43, r26	; 0x2b
    2134:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    2136:	69 a5       	ldd	r22, Y+41	; 0x29
    2138:	7a a5       	ldd	r23, Y+42	; 0x2a
    213a:	8b a5       	ldd	r24, Y+43	; 0x2b
    213c:	9c a5       	ldd	r25, Y+44	; 0x2c
    213e:	20 e0       	ldi	r18, 0x00	; 0
    2140:	30 e0       	ldi	r19, 0x00	; 0
    2142:	40 e8       	ldi	r20, 0x80	; 128
    2144:	5f e3       	ldi	r21, 0x3F	; 63
    2146:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    214a:	88 23       	and	r24, r24
    214c:	1c f4       	brge	.+6      	; 0x2154 <LCD_CheckStatusSendChar+0x8c>
		__ticks = 1;
    214e:	81 e0       	ldi	r24, 0x01	; 1
    2150:	88 a7       	std	Y+40, r24	; 0x28
    2152:	91 c0       	rjmp	.+290    	; 0x2276 <LCD_CheckStatusSendChar+0x1ae>
	else if (__tmp > 255)
    2154:	69 a5       	ldd	r22, Y+41	; 0x29
    2156:	7a a5       	ldd	r23, Y+42	; 0x2a
    2158:	8b a5       	ldd	r24, Y+43	; 0x2b
    215a:	9c a5       	ldd	r25, Y+44	; 0x2c
    215c:	20 e0       	ldi	r18, 0x00	; 0
    215e:	30 e0       	ldi	r19, 0x00	; 0
    2160:	4f e7       	ldi	r20, 0x7F	; 127
    2162:	53 e4       	ldi	r21, 0x43	; 67
    2164:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2168:	18 16       	cp	r1, r24
    216a:	0c f0       	brlt	.+2      	; 0x216e <LCD_CheckStatusSendChar+0xa6>
    216c:	7b c0       	rjmp	.+246    	; 0x2264 <LCD_CheckStatusSendChar+0x19c>
	{
		_delay_ms(__us / 1000.0);
    216e:	6d a5       	ldd	r22, Y+45	; 0x2d
    2170:	7e a5       	ldd	r23, Y+46	; 0x2e
    2172:	8f a5       	ldd	r24, Y+47	; 0x2f
    2174:	98 a9       	ldd	r25, Y+48	; 0x30
    2176:	20 e0       	ldi	r18, 0x00	; 0
    2178:	30 e0       	ldi	r19, 0x00	; 0
    217a:	4a e7       	ldi	r20, 0x7A	; 122
    217c:	54 e4       	ldi	r21, 0x44	; 68
    217e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2182:	dc 01       	movw	r26, r24
    2184:	cb 01       	movw	r24, r22
    2186:	8c a3       	std	Y+36, r24	; 0x24
    2188:	9d a3       	std	Y+37, r25	; 0x25
    218a:	ae a3       	std	Y+38, r26	; 0x26
    218c:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    218e:	6c a1       	ldd	r22, Y+36	; 0x24
    2190:	7d a1       	ldd	r23, Y+37	; 0x25
    2192:	8e a1       	ldd	r24, Y+38	; 0x26
    2194:	9f a1       	ldd	r25, Y+39	; 0x27
    2196:	20 e0       	ldi	r18, 0x00	; 0
    2198:	30 e0       	ldi	r19, 0x00	; 0
    219a:	4a ef       	ldi	r20, 0xFA	; 250
    219c:	54 e4       	ldi	r21, 0x44	; 68
    219e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21a2:	dc 01       	movw	r26, r24
    21a4:	cb 01       	movw	r24, r22
    21a6:	88 a3       	std	Y+32, r24	; 0x20
    21a8:	99 a3       	std	Y+33, r25	; 0x21
    21aa:	aa a3       	std	Y+34, r26	; 0x22
    21ac:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    21ae:	68 a1       	ldd	r22, Y+32	; 0x20
    21b0:	79 a1       	ldd	r23, Y+33	; 0x21
    21b2:	8a a1       	ldd	r24, Y+34	; 0x22
    21b4:	9b a1       	ldd	r25, Y+35	; 0x23
    21b6:	20 e0       	ldi	r18, 0x00	; 0
    21b8:	30 e0       	ldi	r19, 0x00	; 0
    21ba:	40 e8       	ldi	r20, 0x80	; 128
    21bc:	5f e3       	ldi	r21, 0x3F	; 63
    21be:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    21c2:	88 23       	and	r24, r24
    21c4:	2c f4       	brge	.+10     	; 0x21d0 <LCD_CheckStatusSendChar+0x108>
		__ticks = 1;
    21c6:	81 e0       	ldi	r24, 0x01	; 1
    21c8:	90 e0       	ldi	r25, 0x00	; 0
    21ca:	9f 8f       	std	Y+31, r25	; 0x1f
    21cc:	8e 8f       	std	Y+30, r24	; 0x1e
    21ce:	3f c0       	rjmp	.+126    	; 0x224e <LCD_CheckStatusSendChar+0x186>
	else if (__tmp > 65535)
    21d0:	68 a1       	ldd	r22, Y+32	; 0x20
    21d2:	79 a1       	ldd	r23, Y+33	; 0x21
    21d4:	8a a1       	ldd	r24, Y+34	; 0x22
    21d6:	9b a1       	ldd	r25, Y+35	; 0x23
    21d8:	20 e0       	ldi	r18, 0x00	; 0
    21da:	3f ef       	ldi	r19, 0xFF	; 255
    21dc:	4f e7       	ldi	r20, 0x7F	; 127
    21de:	57 e4       	ldi	r21, 0x47	; 71
    21e0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    21e4:	18 16       	cp	r1, r24
    21e6:	4c f5       	brge	.+82     	; 0x223a <LCD_CheckStatusSendChar+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    21e8:	6c a1       	ldd	r22, Y+36	; 0x24
    21ea:	7d a1       	ldd	r23, Y+37	; 0x25
    21ec:	8e a1       	ldd	r24, Y+38	; 0x26
    21ee:	9f a1       	ldd	r25, Y+39	; 0x27
    21f0:	20 e0       	ldi	r18, 0x00	; 0
    21f2:	30 e0       	ldi	r19, 0x00	; 0
    21f4:	40 e2       	ldi	r20, 0x20	; 32
    21f6:	51 e4       	ldi	r21, 0x41	; 65
    21f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21fc:	dc 01       	movw	r26, r24
    21fe:	cb 01       	movw	r24, r22
    2200:	bc 01       	movw	r22, r24
    2202:	cd 01       	movw	r24, r26
    2204:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2208:	dc 01       	movw	r26, r24
    220a:	cb 01       	movw	r24, r22
    220c:	9f 8f       	std	Y+31, r25	; 0x1f
    220e:	8e 8f       	std	Y+30, r24	; 0x1e
    2210:	0f c0       	rjmp	.+30     	; 0x2230 <LCD_CheckStatusSendChar+0x168>
    2212:	88 ec       	ldi	r24, 0xC8	; 200
    2214:	90 e0       	ldi	r25, 0x00	; 0
    2216:	9d 8f       	std	Y+29, r25	; 0x1d
    2218:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    221a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    221c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    221e:	01 97       	sbiw	r24, 0x01	; 1
    2220:	f1 f7       	brne	.-4      	; 0x221e <LCD_CheckStatusSendChar+0x156>
    2222:	9d 8f       	std	Y+29, r25	; 0x1d
    2224:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2226:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2228:	9f 8d       	ldd	r25, Y+31	; 0x1f
    222a:	01 97       	sbiw	r24, 0x01	; 1
    222c:	9f 8f       	std	Y+31, r25	; 0x1f
    222e:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2230:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2232:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2234:	00 97       	sbiw	r24, 0x00	; 0
    2236:	69 f7       	brne	.-38     	; 0x2212 <LCD_CheckStatusSendChar+0x14a>
    2238:	24 c0       	rjmp	.+72     	; 0x2282 <LCD_CheckStatusSendChar+0x1ba>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    223a:	68 a1       	ldd	r22, Y+32	; 0x20
    223c:	79 a1       	ldd	r23, Y+33	; 0x21
    223e:	8a a1       	ldd	r24, Y+34	; 0x22
    2240:	9b a1       	ldd	r25, Y+35	; 0x23
    2242:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2246:	dc 01       	movw	r26, r24
    2248:	cb 01       	movw	r24, r22
    224a:	9f 8f       	std	Y+31, r25	; 0x1f
    224c:	8e 8f       	std	Y+30, r24	; 0x1e
    224e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2250:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2252:	9b 8f       	std	Y+27, r25	; 0x1b
    2254:	8a 8f       	std	Y+26, r24	; 0x1a
    2256:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2258:	9b 8d       	ldd	r25, Y+27	; 0x1b
    225a:	01 97       	sbiw	r24, 0x01	; 1
    225c:	f1 f7       	brne	.-4      	; 0x225a <LCD_CheckStatusSendChar+0x192>
    225e:	9b 8f       	std	Y+27, r25	; 0x1b
    2260:	8a 8f       	std	Y+26, r24	; 0x1a
    2262:	0f c0       	rjmp	.+30     	; 0x2282 <LCD_CheckStatusSendChar+0x1ba>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2264:	69 a5       	ldd	r22, Y+41	; 0x29
    2266:	7a a5       	ldd	r23, Y+42	; 0x2a
    2268:	8b a5       	ldd	r24, Y+43	; 0x2b
    226a:	9c a5       	ldd	r25, Y+44	; 0x2c
    226c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2270:	dc 01       	movw	r26, r24
    2272:	cb 01       	movw	r24, r22
    2274:	88 a7       	std	Y+40, r24	; 0x28
    2276:	88 a5       	ldd	r24, Y+40	; 0x28
    2278:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    227a:	89 8d       	ldd	r24, Y+25	; 0x19
    227c:	8a 95       	dec	r24
    227e:	f1 f7       	brne	.-4      	; 0x227c <LCD_CheckStatusSendChar+0x1b4>
    2280:	89 8f       	std	Y+25, r24	; 0x19
                _delay_us(1);
                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_E_PIN, DIO__UINT8_LOW);
    2282:	83 e0       	ldi	r24, 0x03	; 3
    2284:	62 e0       	ldi	r22, 0x02	; 2
    2286:	40 e0       	ldi	r20, 0x00	; 0
    2288:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>
    228c:	80 e0       	ldi	r24, 0x00	; 0
    228e:	90 e0       	ldi	r25, 0x00	; 0
    2290:	a0 e8       	ldi	r26, 0x80	; 128
    2292:	bf e3       	ldi	r27, 0x3F	; 63
    2294:	8d 8b       	std	Y+21, r24	; 0x15
    2296:	9e 8b       	std	Y+22, r25	; 0x16
    2298:	af 8b       	std	Y+23, r26	; 0x17
    229a:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    229c:	6d 89       	ldd	r22, Y+21	; 0x15
    229e:	7e 89       	ldd	r23, Y+22	; 0x16
    22a0:	8f 89       	ldd	r24, Y+23	; 0x17
    22a2:	98 8d       	ldd	r25, Y+24	; 0x18
    22a4:	2b ea       	ldi	r18, 0xAB	; 171
    22a6:	3a ea       	ldi	r19, 0xAA	; 170
    22a8:	4a e2       	ldi	r20, 0x2A	; 42
    22aa:	50 e4       	ldi	r21, 0x40	; 64
    22ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22b0:	dc 01       	movw	r26, r24
    22b2:	cb 01       	movw	r24, r22
    22b4:	89 8b       	std	Y+17, r24	; 0x11
    22b6:	9a 8b       	std	Y+18, r25	; 0x12
    22b8:	ab 8b       	std	Y+19, r26	; 0x13
    22ba:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    22bc:	69 89       	ldd	r22, Y+17	; 0x11
    22be:	7a 89       	ldd	r23, Y+18	; 0x12
    22c0:	8b 89       	ldd	r24, Y+19	; 0x13
    22c2:	9c 89       	ldd	r25, Y+20	; 0x14
    22c4:	20 e0       	ldi	r18, 0x00	; 0
    22c6:	30 e0       	ldi	r19, 0x00	; 0
    22c8:	40 e8       	ldi	r20, 0x80	; 128
    22ca:	5f e3       	ldi	r21, 0x3F	; 63
    22cc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    22d0:	88 23       	and	r24, r24
    22d2:	1c f4       	brge	.+6      	; 0x22da <LCD_CheckStatusSendChar+0x212>
		__ticks = 1;
    22d4:	81 e0       	ldi	r24, 0x01	; 1
    22d6:	88 8b       	std	Y+16, r24	; 0x10
    22d8:	91 c0       	rjmp	.+290    	; 0x23fc <LCD_CheckStatusSendChar+0x334>
	else if (__tmp > 255)
    22da:	69 89       	ldd	r22, Y+17	; 0x11
    22dc:	7a 89       	ldd	r23, Y+18	; 0x12
    22de:	8b 89       	ldd	r24, Y+19	; 0x13
    22e0:	9c 89       	ldd	r25, Y+20	; 0x14
    22e2:	20 e0       	ldi	r18, 0x00	; 0
    22e4:	30 e0       	ldi	r19, 0x00	; 0
    22e6:	4f e7       	ldi	r20, 0x7F	; 127
    22e8:	53 e4       	ldi	r21, 0x43	; 67
    22ea:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    22ee:	18 16       	cp	r1, r24
    22f0:	0c f0       	brlt	.+2      	; 0x22f4 <LCD_CheckStatusSendChar+0x22c>
    22f2:	7b c0       	rjmp	.+246    	; 0x23ea <LCD_CheckStatusSendChar+0x322>
	{
		_delay_ms(__us / 1000.0);
    22f4:	6d 89       	ldd	r22, Y+21	; 0x15
    22f6:	7e 89       	ldd	r23, Y+22	; 0x16
    22f8:	8f 89       	ldd	r24, Y+23	; 0x17
    22fa:	98 8d       	ldd	r25, Y+24	; 0x18
    22fc:	20 e0       	ldi	r18, 0x00	; 0
    22fe:	30 e0       	ldi	r19, 0x00	; 0
    2300:	4a e7       	ldi	r20, 0x7A	; 122
    2302:	54 e4       	ldi	r21, 0x44	; 68
    2304:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2308:	dc 01       	movw	r26, r24
    230a:	cb 01       	movw	r24, r22
    230c:	8c 87       	std	Y+12, r24	; 0x0c
    230e:	9d 87       	std	Y+13, r25	; 0x0d
    2310:	ae 87       	std	Y+14, r26	; 0x0e
    2312:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2314:	6c 85       	ldd	r22, Y+12	; 0x0c
    2316:	7d 85       	ldd	r23, Y+13	; 0x0d
    2318:	8e 85       	ldd	r24, Y+14	; 0x0e
    231a:	9f 85       	ldd	r25, Y+15	; 0x0f
    231c:	20 e0       	ldi	r18, 0x00	; 0
    231e:	30 e0       	ldi	r19, 0x00	; 0
    2320:	4a ef       	ldi	r20, 0xFA	; 250
    2322:	54 e4       	ldi	r21, 0x44	; 68
    2324:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2328:	dc 01       	movw	r26, r24
    232a:	cb 01       	movw	r24, r22
    232c:	88 87       	std	Y+8, r24	; 0x08
    232e:	99 87       	std	Y+9, r25	; 0x09
    2330:	aa 87       	std	Y+10, r26	; 0x0a
    2332:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    2334:	68 85       	ldd	r22, Y+8	; 0x08
    2336:	79 85       	ldd	r23, Y+9	; 0x09
    2338:	8a 85       	ldd	r24, Y+10	; 0x0a
    233a:	9b 85       	ldd	r25, Y+11	; 0x0b
    233c:	20 e0       	ldi	r18, 0x00	; 0
    233e:	30 e0       	ldi	r19, 0x00	; 0
    2340:	40 e8       	ldi	r20, 0x80	; 128
    2342:	5f e3       	ldi	r21, 0x3F	; 63
    2344:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2348:	88 23       	and	r24, r24
    234a:	2c f4       	brge	.+10     	; 0x2356 <LCD_CheckStatusSendChar+0x28e>
		__ticks = 1;
    234c:	81 e0       	ldi	r24, 0x01	; 1
    234e:	90 e0       	ldi	r25, 0x00	; 0
    2350:	9f 83       	std	Y+7, r25	; 0x07
    2352:	8e 83       	std	Y+6, r24	; 0x06
    2354:	3f c0       	rjmp	.+126    	; 0x23d4 <LCD_CheckStatusSendChar+0x30c>
	else if (__tmp > 65535)
    2356:	68 85       	ldd	r22, Y+8	; 0x08
    2358:	79 85       	ldd	r23, Y+9	; 0x09
    235a:	8a 85       	ldd	r24, Y+10	; 0x0a
    235c:	9b 85       	ldd	r25, Y+11	; 0x0b
    235e:	20 e0       	ldi	r18, 0x00	; 0
    2360:	3f ef       	ldi	r19, 0xFF	; 255
    2362:	4f e7       	ldi	r20, 0x7F	; 127
    2364:	57 e4       	ldi	r21, 0x47	; 71
    2366:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    236a:	18 16       	cp	r1, r24
    236c:	4c f5       	brge	.+82     	; 0x23c0 <LCD_CheckStatusSendChar+0x2f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    236e:	6c 85       	ldd	r22, Y+12	; 0x0c
    2370:	7d 85       	ldd	r23, Y+13	; 0x0d
    2372:	8e 85       	ldd	r24, Y+14	; 0x0e
    2374:	9f 85       	ldd	r25, Y+15	; 0x0f
    2376:	20 e0       	ldi	r18, 0x00	; 0
    2378:	30 e0       	ldi	r19, 0x00	; 0
    237a:	40 e2       	ldi	r20, 0x20	; 32
    237c:	51 e4       	ldi	r21, 0x41	; 65
    237e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2382:	dc 01       	movw	r26, r24
    2384:	cb 01       	movw	r24, r22
    2386:	bc 01       	movw	r22, r24
    2388:	cd 01       	movw	r24, r26
    238a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    238e:	dc 01       	movw	r26, r24
    2390:	cb 01       	movw	r24, r22
    2392:	9f 83       	std	Y+7, r25	; 0x07
    2394:	8e 83       	std	Y+6, r24	; 0x06
    2396:	0f c0       	rjmp	.+30     	; 0x23b6 <LCD_CheckStatusSendChar+0x2ee>
    2398:	88 ec       	ldi	r24, 0xC8	; 200
    239a:	90 e0       	ldi	r25, 0x00	; 0
    239c:	9d 83       	std	Y+5, r25	; 0x05
    239e:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    23a0:	8c 81       	ldd	r24, Y+4	; 0x04
    23a2:	9d 81       	ldd	r25, Y+5	; 0x05
    23a4:	01 97       	sbiw	r24, 0x01	; 1
    23a6:	f1 f7       	brne	.-4      	; 0x23a4 <LCD_CheckStatusSendChar+0x2dc>
    23a8:	9d 83       	std	Y+5, r25	; 0x05
    23aa:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    23ac:	8e 81       	ldd	r24, Y+6	; 0x06
    23ae:	9f 81       	ldd	r25, Y+7	; 0x07
    23b0:	01 97       	sbiw	r24, 0x01	; 1
    23b2:	9f 83       	std	Y+7, r25	; 0x07
    23b4:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    23b6:	8e 81       	ldd	r24, Y+6	; 0x06
    23b8:	9f 81       	ldd	r25, Y+7	; 0x07
    23ba:	00 97       	sbiw	r24, 0x00	; 0
    23bc:	69 f7       	brne	.-38     	; 0x2398 <LCD_CheckStatusSendChar+0x2d0>
    23be:	24 c0       	rjmp	.+72     	; 0x2408 <LCD_CheckStatusSendChar+0x340>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    23c0:	68 85       	ldd	r22, Y+8	; 0x08
    23c2:	79 85       	ldd	r23, Y+9	; 0x09
    23c4:	8a 85       	ldd	r24, Y+10	; 0x0a
    23c6:	9b 85       	ldd	r25, Y+11	; 0x0b
    23c8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23cc:	dc 01       	movw	r26, r24
    23ce:	cb 01       	movw	r24, r22
    23d0:	9f 83       	std	Y+7, r25	; 0x07
    23d2:	8e 83       	std	Y+6, r24	; 0x06
    23d4:	8e 81       	ldd	r24, Y+6	; 0x06
    23d6:	9f 81       	ldd	r25, Y+7	; 0x07
    23d8:	9b 83       	std	Y+3, r25	; 0x03
    23da:	8a 83       	std	Y+2, r24	; 0x02
    23dc:	8a 81       	ldd	r24, Y+2	; 0x02
    23de:	9b 81       	ldd	r25, Y+3	; 0x03
    23e0:	01 97       	sbiw	r24, 0x01	; 1
    23e2:	f1 f7       	brne	.-4      	; 0x23e0 <LCD_CheckStatusSendChar+0x318>
    23e4:	9b 83       	std	Y+3, r25	; 0x03
    23e6:	8a 83       	std	Y+2, r24	; 0x02
    23e8:	0f c0       	rjmp	.+30     	; 0x2408 <LCD_CheckStatusSendChar+0x340>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    23ea:	69 89       	ldd	r22, Y+17	; 0x11
    23ec:	7a 89       	ldd	r23, Y+18	; 0x12
    23ee:	8b 89       	ldd	r24, Y+19	; 0x13
    23f0:	9c 89       	ldd	r25, Y+20	; 0x14
    23f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23f6:	dc 01       	movw	r26, r24
    23f8:	cb 01       	movw	r24, r22
    23fa:	88 8b       	std	Y+16, r24	; 0x10
    23fc:	88 89       	ldd	r24, Y+16	; 0x10
    23fe:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2400:	89 81       	ldd	r24, Y+1	; 0x01
    2402:	8a 95       	dec	r24
    2404:	f1 f7       	brne	.-4      	; 0x2402 <LCD_CheckStatusSendChar+0x33a>
    2406:	89 83       	std	Y+1, r24	; 0x01
        }
        else
        {
                Local_CheckStausReturnValue = CHECK_FAIL;
        }
        return Local_CheckStausReturnValue;
    2408:	89 a9       	ldd	r24, Y+49	; 0x31
}
    240a:	e2 96       	adiw	r28, 0x32	; 50
    240c:	0f b6       	in	r0, 0x3f	; 63
    240e:	f8 94       	cli
    2410:	de bf       	out	0x3e, r29	; 62
    2412:	0f be       	out	0x3f, r0	; 63
    2414:	cd bf       	out	0x3d, r28	; 61
    2416:	cf 91       	pop	r28
    2418:	df 91       	pop	r29
    241a:	08 95       	ret

0000241c <LCD_CheckStatusWriteString>:

CheckStatus LCD_CheckStatusWriteString(_uint8 *Copy_p__Uint8String)
{
    241c:	df 93       	push	r29
    241e:	cf 93       	push	r28
    2420:	00 d0       	rcall	.+0      	; 0x2422 <LCD_CheckStatusWriteString+0x6>
    2422:	00 d0       	rcall	.+0      	; 0x2424 <LCD_CheckStatusWriteString+0x8>
    2424:	0f 92       	push	r0
    2426:	cd b7       	in	r28, 0x3d	; 61
    2428:	de b7       	in	r29, 0x3e	; 62
    242a:	9c 83       	std	Y+4, r25	; 0x04
    242c:	8b 83       	std	Y+3, r24	; 0x03
        CheckStatus Local_CheckStausReturnValue = CHECK_SUCCESS;
    242e:	1a 82       	std	Y+2, r1	; 0x02
        _uint8 Local__Uint8Index = DIO__UINT8_LOW;
    2430:	19 82       	std	Y+1, r1	; 0x01

        if (Copy_p__Uint8String != NULL)
    2432:	8b 81       	ldd	r24, Y+3	; 0x03
    2434:	9c 81       	ldd	r25, Y+4	; 0x04
    2436:	00 97       	sbiw	r24, 0x00	; 0
    2438:	f1 f0       	breq	.+60     	; 0x2476 <LCD_CheckStatusWriteString+0x5a>
        {
                for (Local__Uint8Index = DIO__UINT8_LOW; *(Copy_p__Uint8String + Local__Uint8Index) != '\0'; ++Local__Uint8Index)
    243a:	19 82       	std	Y+1, r1	; 0x01
    243c:	0e c0       	rjmp	.+28     	; 0x245a <LCD_CheckStatusWriteString+0x3e>
                {
                        LCD_CheckStatusSendChar4bit(*(Copy_p__Uint8String + Local__Uint8Index));
    243e:	89 81       	ldd	r24, Y+1	; 0x01
    2440:	28 2f       	mov	r18, r24
    2442:	30 e0       	ldi	r19, 0x00	; 0
    2444:	8b 81       	ldd	r24, Y+3	; 0x03
    2446:	9c 81       	ldd	r25, Y+4	; 0x04
    2448:	fc 01       	movw	r30, r24
    244a:	e2 0f       	add	r30, r18
    244c:	f3 1f       	adc	r31, r19
    244e:	80 81       	ld	r24, Z
    2450:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
        CheckStatus Local_CheckStausReturnValue = CHECK_SUCCESS;
        _uint8 Local__Uint8Index = DIO__UINT8_LOW;

        if (Copy_p__Uint8String != NULL)
        {
                for (Local__Uint8Index = DIO__UINT8_LOW; *(Copy_p__Uint8String + Local__Uint8Index) != '\0'; ++Local__Uint8Index)
    2454:	89 81       	ldd	r24, Y+1	; 0x01
    2456:	8f 5f       	subi	r24, 0xFF	; 255
    2458:	89 83       	std	Y+1, r24	; 0x01
    245a:	89 81       	ldd	r24, Y+1	; 0x01
    245c:	28 2f       	mov	r18, r24
    245e:	30 e0       	ldi	r19, 0x00	; 0
    2460:	8b 81       	ldd	r24, Y+3	; 0x03
    2462:	9c 81       	ldd	r25, Y+4	; 0x04
    2464:	fc 01       	movw	r30, r24
    2466:	e2 0f       	add	r30, r18
    2468:	f3 1f       	adc	r31, r19
    246a:	80 81       	ld	r24, Z
    246c:	88 23       	and	r24, r24
    246e:	39 f7       	brne	.-50     	; 0x243e <LCD_CheckStatusWriteString+0x22>
                {
                        LCD_CheckStatusSendChar4bit(*(Copy_p__Uint8String + Local__Uint8Index));
                }

                return Local_CheckStausReturnValue;
    2470:	8a 81       	ldd	r24, Y+2	; 0x02
    2472:	8d 83       	std	Y+5, r24	; 0x05
    2474:	04 c0       	rjmp	.+8      	; 0x247e <LCD_CheckStatusWriteString+0x62>
        }
        else
        {
                Local_CheckStausReturnValue = CHECK_FAIL;
    2476:	81 e0       	ldi	r24, 0x01	; 1
    2478:	8a 83       	std	Y+2, r24	; 0x02
                return Local_CheckStausReturnValue;
    247a:	8a 81       	ldd	r24, Y+2	; 0x02
    247c:	8d 83       	std	Y+5, r24	; 0x05
    247e:	8d 81       	ldd	r24, Y+5	; 0x05
        }
}
    2480:	0f 90       	pop	r0
    2482:	0f 90       	pop	r0
    2484:	0f 90       	pop	r0
    2486:	0f 90       	pop	r0
    2488:	0f 90       	pop	r0
    248a:	cf 91       	pop	r28
    248c:	df 91       	pop	r29
    248e:	08 95       	ret

00002490 <LCD_CheckStatusGoToXY>:
CheckStatus LCD_CheckStatusGoToXY(_uint8 Copy__Uint8LineNumber, _uint8 Copy__Uint8LocationNumber)
{
    2490:	df 93       	push	r29
    2492:	cf 93       	push	r28
    2494:	00 d0       	rcall	.+0      	; 0x2496 <LCD_CheckStatusGoToXY+0x6>
    2496:	00 d0       	rcall	.+0      	; 0x2498 <LCD_CheckStatusGoToXY+0x8>
    2498:	00 d0       	rcall	.+0      	; 0x249a <LCD_CheckStatusGoToXY+0xa>
    249a:	cd b7       	in	r28, 0x3d	; 61
    249c:	de b7       	in	r29, 0x3e	; 62
    249e:	8a 83       	std	Y+2, r24	; 0x02
    24a0:	6b 83       	std	Y+3, r22	; 0x03

        CheckStatus Local_CheckStausReturnValue = CHECK_SUCCESS;
    24a2:	19 82       	std	Y+1, r1	; 0x01

        if ((Copy__Uint8LineNumber <= 1) && (Copy__Uint8LocationNumber <= 39))
    24a4:	8a 81       	ldd	r24, Y+2	; 0x02
    24a6:	82 30       	cpi	r24, 0x02	; 2
    24a8:	f0 f4       	brcc	.+60     	; 0x24e6 <LCD_CheckStatusGoToXY+0x56>
    24aa:	8b 81       	ldd	r24, Y+3	; 0x03
    24ac:	88 32       	cpi	r24, 0x28	; 40
    24ae:	d8 f4       	brcc	.+54     	; 0x24e6 <LCD_CheckStatusGoToXY+0x56>
        {

                switch (Copy__Uint8LineNumber)
    24b0:	8a 81       	ldd	r24, Y+2	; 0x02
    24b2:	28 2f       	mov	r18, r24
    24b4:	30 e0       	ldi	r19, 0x00	; 0
    24b6:	3e 83       	std	Y+6, r19	; 0x06
    24b8:	2d 83       	std	Y+5, r18	; 0x05
    24ba:	8d 81       	ldd	r24, Y+5	; 0x05
    24bc:	9e 81       	ldd	r25, Y+6	; 0x06
    24be:	00 97       	sbiw	r24, 0x00	; 0
    24c0:	31 f0       	breq	.+12     	; 0x24ce <LCD_CheckStatusGoToXY+0x3e>
    24c2:	2d 81       	ldd	r18, Y+5	; 0x05
    24c4:	3e 81       	ldd	r19, Y+6	; 0x06
    24c6:	21 30       	cpi	r18, 0x01	; 1
    24c8:	31 05       	cpc	r19, r1
    24ca:	31 f0       	breq	.+12     	; 0x24d8 <LCD_CheckStatusGoToXY+0x48>
    24cc:	09 c0       	rjmp	.+18     	; 0x24e0 <LCD_CheckStatusGoToXY+0x50>
                {
                case LCD__UINT8_LINE1:
                        LCD_CheckStatusSendCmnd4bit(0x80 + Copy__Uint8LocationNumber); //BASE +OFFSET
    24ce:	8b 81       	ldd	r24, Y+3	; 0x03
    24d0:	80 58       	subi	r24, 0x80	; 128
    24d2:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
    24d6:	04 c0       	rjmp	.+8      	; 0x24e0 <LCD_CheckStatusGoToXY+0x50>
                        break;
                case LCD__UINT8_LINE2:
                        LCD_CheckStatusSendCmnd4bit(0xc0 + Copy__Uint8LocationNumber);
    24d8:	8b 81       	ldd	r24, Y+3	; 0x03
    24da:	80 54       	subi	r24, 0x40	; 64
    24dc:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
                        break;
                default:
                        break;
                }
                return Local_CheckStausReturnValue;
    24e0:	39 81       	ldd	r19, Y+1	; 0x01
    24e2:	3c 83       	std	Y+4, r19	; 0x04
    24e4:	04 c0       	rjmp	.+8      	; 0x24ee <LCD_CheckStatusGoToXY+0x5e>
        }
        else
        {
                Local_CheckStausReturnValue = CHECK_FAIL;
    24e6:	81 e0       	ldi	r24, 0x01	; 1
    24e8:	89 83       	std	Y+1, r24	; 0x01
                return Local_CheckStausReturnValue;
    24ea:	89 81       	ldd	r24, Y+1	; 0x01
    24ec:	8c 83       	std	Y+4, r24	; 0x04
    24ee:	8c 81       	ldd	r24, Y+4	; 0x04
        }
}
    24f0:	26 96       	adiw	r28, 0x06	; 6
    24f2:	0f b6       	in	r0, 0x3f	; 63
    24f4:	f8 94       	cli
    24f6:	de bf       	out	0x3e, r29	; 62
    24f8:	0f be       	out	0x3f, r0	; 63
    24fa:	cd bf       	out	0x3d, r28	; 61
    24fc:	cf 91       	pop	r28
    24fe:	df 91       	pop	r29
    2500:	08 95       	ret

00002502 <LCD_VoidClearDisplay>:

Void LCD_VoidClearDisplay(Void)
{
    2502:	df 93       	push	r29
    2504:	cf 93       	push	r28
    2506:	cd b7       	in	r28, 0x3d	; 61
    2508:	de b7       	in	r29, 0x3e	; 62
    250a:	2e 97       	sbiw	r28, 0x0e	; 14
    250c:	0f b6       	in	r0, 0x3f	; 63
    250e:	f8 94       	cli
    2510:	de bf       	out	0x3e, r29	; 62
    2512:	0f be       	out	0x3f, r0	; 63
    2514:	cd bf       	out	0x3d, r28	; 61
        LCD_CheckStatusSendCmnd4bit(0x01);
    2516:	81 e0       	ldi	r24, 0x01	; 1
    2518:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
    251c:	80 e0       	ldi	r24, 0x00	; 0
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	a0 e0       	ldi	r26, 0x00	; 0
    2522:	b0 e4       	ldi	r27, 0x40	; 64
    2524:	8b 87       	std	Y+11, r24	; 0x0b
    2526:	9c 87       	std	Y+12, r25	; 0x0c
    2528:	ad 87       	std	Y+13, r26	; 0x0d
    252a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    252c:	6b 85       	ldd	r22, Y+11	; 0x0b
    252e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2530:	8d 85       	ldd	r24, Y+13	; 0x0d
    2532:	9e 85       	ldd	r25, Y+14	; 0x0e
    2534:	20 e0       	ldi	r18, 0x00	; 0
    2536:	30 e0       	ldi	r19, 0x00	; 0
    2538:	4a ef       	ldi	r20, 0xFA	; 250
    253a:	54 e4       	ldi	r21, 0x44	; 68
    253c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2540:	dc 01       	movw	r26, r24
    2542:	cb 01       	movw	r24, r22
    2544:	8f 83       	std	Y+7, r24	; 0x07
    2546:	98 87       	std	Y+8, r25	; 0x08
    2548:	a9 87       	std	Y+9, r26	; 0x09
    254a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    254c:	6f 81       	ldd	r22, Y+7	; 0x07
    254e:	78 85       	ldd	r23, Y+8	; 0x08
    2550:	89 85       	ldd	r24, Y+9	; 0x09
    2552:	9a 85       	ldd	r25, Y+10	; 0x0a
    2554:	20 e0       	ldi	r18, 0x00	; 0
    2556:	30 e0       	ldi	r19, 0x00	; 0
    2558:	40 e8       	ldi	r20, 0x80	; 128
    255a:	5f e3       	ldi	r21, 0x3F	; 63
    255c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2560:	88 23       	and	r24, r24
    2562:	2c f4       	brge	.+10     	; 0x256e <LCD_VoidClearDisplay+0x6c>
		__ticks = 1;
    2564:	81 e0       	ldi	r24, 0x01	; 1
    2566:	90 e0       	ldi	r25, 0x00	; 0
    2568:	9e 83       	std	Y+6, r25	; 0x06
    256a:	8d 83       	std	Y+5, r24	; 0x05
    256c:	3f c0       	rjmp	.+126    	; 0x25ec <LCD_VoidClearDisplay+0xea>
	else if (__tmp > 65535)
    256e:	6f 81       	ldd	r22, Y+7	; 0x07
    2570:	78 85       	ldd	r23, Y+8	; 0x08
    2572:	89 85       	ldd	r24, Y+9	; 0x09
    2574:	9a 85       	ldd	r25, Y+10	; 0x0a
    2576:	20 e0       	ldi	r18, 0x00	; 0
    2578:	3f ef       	ldi	r19, 0xFF	; 255
    257a:	4f e7       	ldi	r20, 0x7F	; 127
    257c:	57 e4       	ldi	r21, 0x47	; 71
    257e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2582:	18 16       	cp	r1, r24
    2584:	4c f5       	brge	.+82     	; 0x25d8 <LCD_VoidClearDisplay+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2586:	6b 85       	ldd	r22, Y+11	; 0x0b
    2588:	7c 85       	ldd	r23, Y+12	; 0x0c
    258a:	8d 85       	ldd	r24, Y+13	; 0x0d
    258c:	9e 85       	ldd	r25, Y+14	; 0x0e
    258e:	20 e0       	ldi	r18, 0x00	; 0
    2590:	30 e0       	ldi	r19, 0x00	; 0
    2592:	40 e2       	ldi	r20, 0x20	; 32
    2594:	51 e4       	ldi	r21, 0x41	; 65
    2596:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    259a:	dc 01       	movw	r26, r24
    259c:	cb 01       	movw	r24, r22
    259e:	bc 01       	movw	r22, r24
    25a0:	cd 01       	movw	r24, r26
    25a2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    25a6:	dc 01       	movw	r26, r24
    25a8:	cb 01       	movw	r24, r22
    25aa:	9e 83       	std	Y+6, r25	; 0x06
    25ac:	8d 83       	std	Y+5, r24	; 0x05
    25ae:	0f c0       	rjmp	.+30     	; 0x25ce <LCD_VoidClearDisplay+0xcc>
    25b0:	88 ec       	ldi	r24, 0xC8	; 200
    25b2:	90 e0       	ldi	r25, 0x00	; 0
    25b4:	9c 83       	std	Y+4, r25	; 0x04
    25b6:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    25b8:	8b 81       	ldd	r24, Y+3	; 0x03
    25ba:	9c 81       	ldd	r25, Y+4	; 0x04
    25bc:	01 97       	sbiw	r24, 0x01	; 1
    25be:	f1 f7       	brne	.-4      	; 0x25bc <LCD_VoidClearDisplay+0xba>
    25c0:	9c 83       	std	Y+4, r25	; 0x04
    25c2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    25c4:	8d 81       	ldd	r24, Y+5	; 0x05
    25c6:	9e 81       	ldd	r25, Y+6	; 0x06
    25c8:	01 97       	sbiw	r24, 0x01	; 1
    25ca:	9e 83       	std	Y+6, r25	; 0x06
    25cc:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    25ce:	8d 81       	ldd	r24, Y+5	; 0x05
    25d0:	9e 81       	ldd	r25, Y+6	; 0x06
    25d2:	00 97       	sbiw	r24, 0x00	; 0
    25d4:	69 f7       	brne	.-38     	; 0x25b0 <LCD_VoidClearDisplay+0xae>
    25d6:	14 c0       	rjmp	.+40     	; 0x2600 <LCD_VoidClearDisplay+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    25d8:	6f 81       	ldd	r22, Y+7	; 0x07
    25da:	78 85       	ldd	r23, Y+8	; 0x08
    25dc:	89 85       	ldd	r24, Y+9	; 0x09
    25de:	9a 85       	ldd	r25, Y+10	; 0x0a
    25e0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    25e4:	dc 01       	movw	r26, r24
    25e6:	cb 01       	movw	r24, r22
    25e8:	9e 83       	std	Y+6, r25	; 0x06
    25ea:	8d 83       	std	Y+5, r24	; 0x05
    25ec:	8d 81       	ldd	r24, Y+5	; 0x05
    25ee:	9e 81       	ldd	r25, Y+6	; 0x06
    25f0:	9a 83       	std	Y+2, r25	; 0x02
    25f2:	89 83       	std	Y+1, r24	; 0x01
    25f4:	89 81       	ldd	r24, Y+1	; 0x01
    25f6:	9a 81       	ldd	r25, Y+2	; 0x02
    25f8:	01 97       	sbiw	r24, 0x01	; 1
    25fa:	f1 f7       	brne	.-4      	; 0x25f8 <LCD_VoidClearDisplay+0xf6>
    25fc:	9a 83       	std	Y+2, r25	; 0x02
    25fe:	89 83       	std	Y+1, r24	; 0x01
        _delay_ms(2);
}
    2600:	2e 96       	adiw	r28, 0x0e	; 14
    2602:	0f b6       	in	r0, 0x3f	; 63
    2604:	f8 94       	cli
    2606:	de bf       	out	0x3e, r29	; 62
    2608:	0f be       	out	0x3f, r0	; 63
    260a:	cd bf       	out	0x3d, r28	; 61
    260c:	cf 91       	pop	r28
    260e:	df 91       	pop	r29
    2610:	08 95       	ret

00002612 <LCD_CheckStatusSendNumber>:
CheckStatus LCD_CheckStatusSendNumber(_uint32 Copy__Uint32Number)
{
    2612:	df 93       	push	r29
    2614:	cf 93       	push	r28
    2616:	cd b7       	in	r28, 0x3d	; 61
    2618:	de b7       	in	r29, 0x3e	; 62
    261a:	2d 97       	sbiw	r28, 0x0d	; 13
    261c:	0f b6       	in	r0, 0x3f	; 63
    261e:	f8 94       	cli
    2620:	de bf       	out	0x3e, r29	; 62
    2622:	0f be       	out	0x3f, r0	; 63
    2624:	cd bf       	out	0x3d, r28	; 61
    2626:	68 87       	std	Y+8, r22	; 0x08
    2628:	79 87       	std	Y+9, r23	; 0x09
    262a:	8a 87       	std	Y+10, r24	; 0x0a
    262c:	9b 87       	std	Y+11, r25	; 0x0b
        CheckStatus Local_CheckStausReturnValue = CHECK_SUCCESS;
    262e:	1f 82       	std	Y+7, r1	; 0x07

        _uint8 Local__Uint8Remendier = 0x00;
    2630:	1e 82       	std	Y+6, r1	; 0x06
        _uint8 Local__Uint8Counter = 0x00;
    2632:	1d 82       	std	Y+5, r1	; 0x05
        _uint32 Local__Uint32Temporary = 0;
    2634:	19 82       	std	Y+1, r1	; 0x01
    2636:	1a 82       	std	Y+2, r1	; 0x02
    2638:	1b 82       	std	Y+3, r1	; 0x03
    263a:	1c 82       	std	Y+4, r1	; 0x04
    263c:	40 c0       	rjmp	.+128    	; 0x26be <LCD_CheckStatusSendNumber+0xac>
        if (Copy__Uint32Number <= 4294967296)
        {
                while (Copy__Uint32Number != 0)
                {
                        Local__Uint32Temporary = Local__Uint32Temporary * 0x0A;
    263e:	89 81       	ldd	r24, Y+1	; 0x01
    2640:	9a 81       	ldd	r25, Y+2	; 0x02
    2642:	ab 81       	ldd	r26, Y+3	; 0x03
    2644:	bc 81       	ldd	r27, Y+4	; 0x04
    2646:	2a e0       	ldi	r18, 0x0A	; 10
    2648:	30 e0       	ldi	r19, 0x00	; 0
    264a:	40 e0       	ldi	r20, 0x00	; 0
    264c:	50 e0       	ldi	r21, 0x00	; 0
    264e:	bc 01       	movw	r22, r24
    2650:	cd 01       	movw	r24, r26
    2652:	0e 94 79 35 	call	0x6af2	; 0x6af2 <__mulsi3>
    2656:	dc 01       	movw	r26, r24
    2658:	cb 01       	movw	r24, r22
    265a:	89 83       	std	Y+1, r24	; 0x01
    265c:	9a 83       	std	Y+2, r25	; 0x02
    265e:	ab 83       	std	Y+3, r26	; 0x03
    2660:	bc 83       	std	Y+4, r27	; 0x04
                        Local__Uint32Temporary = Local__Uint32Temporary + Copy__Uint32Number % 0x0A;
    2662:	88 85       	ldd	r24, Y+8	; 0x08
    2664:	99 85       	ldd	r25, Y+9	; 0x09
    2666:	aa 85       	ldd	r26, Y+10	; 0x0a
    2668:	bb 85       	ldd	r27, Y+11	; 0x0b
    266a:	2a e0       	ldi	r18, 0x0A	; 10
    266c:	30 e0       	ldi	r19, 0x00	; 0
    266e:	40 e0       	ldi	r20, 0x00	; 0
    2670:	50 e0       	ldi	r21, 0x00	; 0
    2672:	bc 01       	movw	r22, r24
    2674:	cd 01       	movw	r24, r26
    2676:	0e 94 98 35 	call	0x6b30	; 0x6b30 <__udivmodsi4>
    267a:	dc 01       	movw	r26, r24
    267c:	cb 01       	movw	r24, r22
    267e:	9c 01       	movw	r18, r24
    2680:	ad 01       	movw	r20, r26
    2682:	89 81       	ldd	r24, Y+1	; 0x01
    2684:	9a 81       	ldd	r25, Y+2	; 0x02
    2686:	ab 81       	ldd	r26, Y+3	; 0x03
    2688:	bc 81       	ldd	r27, Y+4	; 0x04
    268a:	82 0f       	add	r24, r18
    268c:	93 1f       	adc	r25, r19
    268e:	a4 1f       	adc	r26, r20
    2690:	b5 1f       	adc	r27, r21
    2692:	89 83       	std	Y+1, r24	; 0x01
    2694:	9a 83       	std	Y+2, r25	; 0x02
    2696:	ab 83       	std	Y+3, r26	; 0x03
    2698:	bc 83       	std	Y+4, r27	; 0x04
                        Copy__Uint32Number = Copy__Uint32Number / 0x0A;
    269a:	88 85       	ldd	r24, Y+8	; 0x08
    269c:	99 85       	ldd	r25, Y+9	; 0x09
    269e:	aa 85       	ldd	r26, Y+10	; 0x0a
    26a0:	bb 85       	ldd	r27, Y+11	; 0x0b
    26a2:	2a e0       	ldi	r18, 0x0A	; 10
    26a4:	30 e0       	ldi	r19, 0x00	; 0
    26a6:	40 e0       	ldi	r20, 0x00	; 0
    26a8:	50 e0       	ldi	r21, 0x00	; 0
    26aa:	bc 01       	movw	r22, r24
    26ac:	cd 01       	movw	r24, r26
    26ae:	0e 94 98 35 	call	0x6b30	; 0x6b30 <__udivmodsi4>
    26b2:	da 01       	movw	r26, r20
    26b4:	c9 01       	movw	r24, r18
    26b6:	88 87       	std	Y+8, r24	; 0x08
    26b8:	99 87       	std	Y+9, r25	; 0x09
    26ba:	aa 87       	std	Y+10, r26	; 0x0a
    26bc:	bb 87       	std	Y+11, r27	; 0x0b
        _uint8 Local__Uint8Remendier = 0x00;
        _uint8 Local__Uint8Counter = 0x00;
        _uint32 Local__Uint32Temporary = 0;
        if (Copy__Uint32Number <= 4294967296)
        {
                while (Copy__Uint32Number != 0)
    26be:	88 85       	ldd	r24, Y+8	; 0x08
    26c0:	99 85       	ldd	r25, Y+9	; 0x09
    26c2:	aa 85       	ldd	r26, Y+10	; 0x0a
    26c4:	bb 85       	ldd	r27, Y+11	; 0x0b
    26c6:	00 97       	sbiw	r24, 0x00	; 0
    26c8:	a1 05       	cpc	r26, r1
    26ca:	b1 05       	cpc	r27, r1
    26cc:	09 f0       	breq	.+2      	; 0x26d0 <LCD_CheckStatusSendNumber+0xbe>
    26ce:	b7 cf       	rjmp	.-146    	; 0x263e <LCD_CheckStatusSendNumber+0x2c>
                        Local__Uint32Temporary = Local__Uint32Temporary * 0x0A;
                        Local__Uint32Temporary = Local__Uint32Temporary + Copy__Uint32Number % 0x0A;
                        Copy__Uint32Number = Copy__Uint32Number / 0x0A;
                }

                for (Local__Uint8Counter = 0; Local__Uint32Temporary != 0; ++Local__Uint8Counter)
    26d0:	1d 82       	std	Y+5, r1	; 0x05
    26d2:	95 c0       	rjmp	.+298    	; 0x27fe <LCD_CheckStatusSendNumber+0x1ec>
                {
                        Local__Uint8Remendier = Local__Uint32Temporary % 0x0A;
    26d4:	89 81       	ldd	r24, Y+1	; 0x01
    26d6:	9a 81       	ldd	r25, Y+2	; 0x02
    26d8:	ab 81       	ldd	r26, Y+3	; 0x03
    26da:	bc 81       	ldd	r27, Y+4	; 0x04
    26dc:	2a e0       	ldi	r18, 0x0A	; 10
    26de:	30 e0       	ldi	r19, 0x00	; 0
    26e0:	40 e0       	ldi	r20, 0x00	; 0
    26e2:	50 e0       	ldi	r21, 0x00	; 0
    26e4:	bc 01       	movw	r22, r24
    26e6:	cd 01       	movw	r24, r26
    26e8:	0e 94 98 35 	call	0x6b30	; 0x6b30 <__udivmodsi4>
    26ec:	dc 01       	movw	r26, r24
    26ee:	cb 01       	movw	r24, r22
    26f0:	8e 83       	std	Y+6, r24	; 0x06
                        Local__Uint32Temporary = Local__Uint32Temporary / 0x0A;
    26f2:	89 81       	ldd	r24, Y+1	; 0x01
    26f4:	9a 81       	ldd	r25, Y+2	; 0x02
    26f6:	ab 81       	ldd	r26, Y+3	; 0x03
    26f8:	bc 81       	ldd	r27, Y+4	; 0x04
    26fa:	2a e0       	ldi	r18, 0x0A	; 10
    26fc:	30 e0       	ldi	r19, 0x00	; 0
    26fe:	40 e0       	ldi	r20, 0x00	; 0
    2700:	50 e0       	ldi	r21, 0x00	; 0
    2702:	bc 01       	movw	r22, r24
    2704:	cd 01       	movw	r24, r26
    2706:	0e 94 98 35 	call	0x6b30	; 0x6b30 <__udivmodsi4>
    270a:	da 01       	movw	r26, r20
    270c:	c9 01       	movw	r24, r18
    270e:	89 83       	std	Y+1, r24	; 0x01
    2710:	9a 83       	std	Y+2, r25	; 0x02
    2712:	ab 83       	std	Y+3, r26	; 0x03
    2714:	bc 83       	std	Y+4, r27	; 0x04
                        switch (Local__Uint8Remendier)
    2716:	8e 81       	ldd	r24, Y+6	; 0x06
    2718:	28 2f       	mov	r18, r24
    271a:	30 e0       	ldi	r19, 0x00	; 0
    271c:	3d 87       	std	Y+13, r19	; 0x0d
    271e:	2c 87       	std	Y+12, r18	; 0x0c
    2720:	8c 85       	ldd	r24, Y+12	; 0x0c
    2722:	9d 85       	ldd	r25, Y+13	; 0x0d
    2724:	84 30       	cpi	r24, 0x04	; 4
    2726:	91 05       	cpc	r25, r1
    2728:	09 f4       	brne	.+2      	; 0x272c <LCD_CheckStatusSendNumber+0x11a>
    272a:	4f c0       	rjmp	.+158    	; 0x27ca <LCD_CheckStatusSendNumber+0x1b8>
    272c:	2c 85       	ldd	r18, Y+12	; 0x0c
    272e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2730:	25 30       	cpi	r18, 0x05	; 5
    2732:	31 05       	cpc	r19, r1
    2734:	d4 f4       	brge	.+52     	; 0x276a <LCD_CheckStatusSendNumber+0x158>
    2736:	8c 85       	ldd	r24, Y+12	; 0x0c
    2738:	9d 85       	ldd	r25, Y+13	; 0x0d
    273a:	81 30       	cpi	r24, 0x01	; 1
    273c:	91 05       	cpc	r25, r1
    273e:	c9 f1       	breq	.+114    	; 0x27b2 <LCD_CheckStatusSendNumber+0x1a0>
    2740:	2c 85       	ldd	r18, Y+12	; 0x0c
    2742:	3d 85       	ldd	r19, Y+13	; 0x0d
    2744:	22 30       	cpi	r18, 0x02	; 2
    2746:	31 05       	cpc	r19, r1
    2748:	2c f4       	brge	.+10     	; 0x2754 <LCD_CheckStatusSendNumber+0x142>
    274a:	8c 85       	ldd	r24, Y+12	; 0x0c
    274c:	9d 85       	ldd	r25, Y+13	; 0x0d
    274e:	00 97       	sbiw	r24, 0x00	; 0
    2750:	61 f1       	breq	.+88     	; 0x27aa <LCD_CheckStatusSendNumber+0x198>
    2752:	52 c0       	rjmp	.+164    	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
    2754:	2c 85       	ldd	r18, Y+12	; 0x0c
    2756:	3d 85       	ldd	r19, Y+13	; 0x0d
    2758:	22 30       	cpi	r18, 0x02	; 2
    275a:	31 05       	cpc	r19, r1
    275c:	71 f1       	breq	.+92     	; 0x27ba <LCD_CheckStatusSendNumber+0x1a8>
    275e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2760:	9d 85       	ldd	r25, Y+13	; 0x0d
    2762:	83 30       	cpi	r24, 0x03	; 3
    2764:	91 05       	cpc	r25, r1
    2766:	69 f1       	breq	.+90     	; 0x27c2 <LCD_CheckStatusSendNumber+0x1b0>
    2768:	47 c0       	rjmp	.+142    	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
    276a:	2c 85       	ldd	r18, Y+12	; 0x0c
    276c:	3d 85       	ldd	r19, Y+13	; 0x0d
    276e:	27 30       	cpi	r18, 0x07	; 7
    2770:	31 05       	cpc	r19, r1
    2772:	b9 f1       	breq	.+110    	; 0x27e2 <LCD_CheckStatusSendNumber+0x1d0>
    2774:	8c 85       	ldd	r24, Y+12	; 0x0c
    2776:	9d 85       	ldd	r25, Y+13	; 0x0d
    2778:	88 30       	cpi	r24, 0x08	; 8
    277a:	91 05       	cpc	r25, r1
    277c:	5c f4       	brge	.+22     	; 0x2794 <LCD_CheckStatusSendNumber+0x182>
    277e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2780:	3d 85       	ldd	r19, Y+13	; 0x0d
    2782:	25 30       	cpi	r18, 0x05	; 5
    2784:	31 05       	cpc	r19, r1
    2786:	29 f1       	breq	.+74     	; 0x27d2 <LCD_CheckStatusSendNumber+0x1c0>
    2788:	8c 85       	ldd	r24, Y+12	; 0x0c
    278a:	9d 85       	ldd	r25, Y+13	; 0x0d
    278c:	86 30       	cpi	r24, 0x06	; 6
    278e:	91 05       	cpc	r25, r1
    2790:	21 f1       	breq	.+72     	; 0x27da <LCD_CheckStatusSendNumber+0x1c8>
    2792:	32 c0       	rjmp	.+100    	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
    2794:	2c 85       	ldd	r18, Y+12	; 0x0c
    2796:	3d 85       	ldd	r19, Y+13	; 0x0d
    2798:	28 30       	cpi	r18, 0x08	; 8
    279a:	31 05       	cpc	r19, r1
    279c:	31 f1       	breq	.+76     	; 0x27ea <LCD_CheckStatusSendNumber+0x1d8>
    279e:	8c 85       	ldd	r24, Y+12	; 0x0c
    27a0:	9d 85       	ldd	r25, Y+13	; 0x0d
    27a2:	89 30       	cpi	r24, 0x09	; 9
    27a4:	91 05       	cpc	r25, r1
    27a6:	29 f1       	breq	.+74     	; 0x27f2 <LCD_CheckStatusSendNumber+0x1e0>
    27a8:	27 c0       	rjmp	.+78     	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
                        {
                        case 0:
                                LCD_CheckStatusSendChar4bit('0');
    27aa:	80 e3       	ldi	r24, 0x30	; 48
    27ac:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    27b0:	23 c0       	rjmp	.+70     	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
                                break;
                        case 1:
                                LCD_CheckStatusSendChar4bit('1');
    27b2:	81 e3       	ldi	r24, 0x31	; 49
    27b4:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    27b8:	1f c0       	rjmp	.+62     	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
                                break;
                        case 2:
                                LCD_CheckStatusSendChar4bit('2');
    27ba:	82 e3       	ldi	r24, 0x32	; 50
    27bc:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    27c0:	1b c0       	rjmp	.+54     	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
                                break;
                        case 3:
                                LCD_CheckStatusSendChar4bit('3');
    27c2:	83 e3       	ldi	r24, 0x33	; 51
    27c4:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    27c8:	17 c0       	rjmp	.+46     	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
                                break;
                        case 4:
                                LCD_CheckStatusSendChar4bit('4');
    27ca:	84 e3       	ldi	r24, 0x34	; 52
    27cc:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    27d0:	13 c0       	rjmp	.+38     	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
                                break;
                        case 5:
                                LCD_CheckStatusSendChar4bit('5');
    27d2:	85 e3       	ldi	r24, 0x35	; 53
    27d4:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    27d8:	0f c0       	rjmp	.+30     	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
                                break;
                        case 6:
                                LCD_CheckStatusSendChar4bit('6');
    27da:	86 e3       	ldi	r24, 0x36	; 54
    27dc:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    27e0:	0b c0       	rjmp	.+22     	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
                                break;
                        case 7:
                                LCD_CheckStatusSendChar4bit('7');
    27e2:	87 e3       	ldi	r24, 0x37	; 55
    27e4:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    27e8:	07 c0       	rjmp	.+14     	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
                                break;
                        case 8:
                                LCD_CheckStatusSendChar4bit('8');
    27ea:	88 e3       	ldi	r24, 0x38	; 56
    27ec:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    27f0:	03 c0       	rjmp	.+6      	; 0x27f8 <LCD_CheckStatusSendNumber+0x1e6>
                                break;
                        case 9:
                                LCD_CheckStatusSendChar4bit('9');
    27f2:	89 e3       	ldi	r24, 0x39	; 57
    27f4:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
                        Local__Uint32Temporary = Local__Uint32Temporary * 0x0A;
                        Local__Uint32Temporary = Local__Uint32Temporary + Copy__Uint32Number % 0x0A;
                        Copy__Uint32Number = Copy__Uint32Number / 0x0A;
                }

                for (Local__Uint8Counter = 0; Local__Uint32Temporary != 0; ++Local__Uint8Counter)
    27f8:	8d 81       	ldd	r24, Y+5	; 0x05
    27fa:	8f 5f       	subi	r24, 0xFF	; 255
    27fc:	8d 83       	std	Y+5, r24	; 0x05
    27fe:	89 81       	ldd	r24, Y+1	; 0x01
    2800:	9a 81       	ldd	r25, Y+2	; 0x02
    2802:	ab 81       	ldd	r26, Y+3	; 0x03
    2804:	bc 81       	ldd	r27, Y+4	; 0x04
    2806:	00 97       	sbiw	r24, 0x00	; 0
    2808:	a1 05       	cpc	r26, r1
    280a:	b1 05       	cpc	r27, r1
    280c:	09 f0       	breq	.+2      	; 0x2810 <LCD_CheckStatusSendNumber+0x1fe>
    280e:	62 cf       	rjmp	.-316    	; 0x26d4 <LCD_CheckStatusSendNumber+0xc2>
        }
        else
        {
                Local_CheckStausReturnValue = CHECK_FAIL;
        }
        return Local_CheckStausReturnValue;
    2810:	8f 81       	ldd	r24, Y+7	; 0x07
}
    2812:	2d 96       	adiw	r28, 0x0d	; 13
    2814:	0f b6       	in	r0, 0x3f	; 63
    2816:	f8 94       	cli
    2818:	de bf       	out	0x3e, r29	; 62
    281a:	0f be       	out	0x3f, r0	; 63
    281c:	cd bf       	out	0x3d, r28	; 61
    281e:	cf 91       	pop	r28
    2820:	df 91       	pop	r29
    2822:	08 95       	ret

00002824 <LCD_CheckStatusSpecialChar>:

CheckStatus LCD_CheckStatusSpecialChar(_uint8 Copy__Uint8CGRamLocation, _uint8 Copy__Uint8LCDLine, _uint8 Copy__Uint8DDRamLocation)
{
    2824:	df 93       	push	r29
    2826:	cf 93       	push	r28
    2828:	cd b7       	in	r28, 0x3d	; 61
    282a:	de b7       	in	r29, 0x3e	; 62
    282c:	27 97       	sbiw	r28, 0x07	; 7
    282e:	0f b6       	in	r0, 0x3f	; 63
    2830:	f8 94       	cli
    2832:	de bf       	out	0x3e, r29	; 62
    2834:	0f be       	out	0x3f, r0	; 63
    2836:	cd bf       	out	0x3d, r28	; 61
    2838:	8b 83       	std	Y+3, r24	; 0x03
    283a:	6c 83       	std	Y+4, r22	; 0x04
    283c:	4d 83       	std	Y+5, r20	; 0x05
        CheckStatus Local_CheckStausReturnValue = CHECK_SUCCESS;
    283e:	1a 82       	std	Y+2, r1	; 0x02

        _uint8 Local__Uint8CounterJ = 0x00;
    2840:	19 82       	std	Y+1, r1	; 0x01
        if ((Copy__Uint8CGRamLocation <= LCD__UINT8_CG_RAMLOCATION7) && (Copy__Uint8DDRamLocation <= LCD__UINT8_LOCATION_NUMBER39))
    2842:	8b 81       	ldd	r24, Y+3	; 0x03
    2844:	88 30       	cpi	r24, 0x08	; 8
    2846:	08 f0       	brcs	.+2      	; 0x284a <LCD_CheckStatusSpecialChar+0x26>
    2848:	0b c1       	rjmp	.+534    	; 0x2a60 <LCD_CheckStatusSpecialChar+0x23c>
    284a:	8d 81       	ldd	r24, Y+5	; 0x05
    284c:	88 32       	cpi	r24, 0x28	; 40
    284e:	08 f0       	brcs	.+2      	; 0x2852 <LCD_CheckStatusSpecialChar+0x2e>
    2850:	07 c1       	rjmp	.+526    	; 0x2a60 <LCD_CheckStatusSpecialChar+0x23c>
        {

                switch (Copy__Uint8CGRamLocation)
    2852:	8b 81       	ldd	r24, Y+3	; 0x03
    2854:	28 2f       	mov	r18, r24
    2856:	30 e0       	ldi	r19, 0x00	; 0
    2858:	3f 83       	std	Y+7, r19	; 0x07
    285a:	2e 83       	std	Y+6, r18	; 0x06
    285c:	8e 81       	ldd	r24, Y+6	; 0x06
    285e:	9f 81       	ldd	r25, Y+7	; 0x07
    2860:	84 30       	cpi	r24, 0x04	; 4
    2862:	91 05       	cpc	r25, r1
    2864:	09 f4       	brne	.+2      	; 0x2868 <LCD_CheckStatusSpecialChar+0x44>
    2866:	7b c0       	rjmp	.+246    	; 0x295e <LCD_CheckStatusSpecialChar+0x13a>
    2868:	2e 81       	ldd	r18, Y+6	; 0x06
    286a:	3f 81       	ldd	r19, Y+7	; 0x07
    286c:	25 30       	cpi	r18, 0x05	; 5
    286e:	31 05       	cpc	r19, r1
    2870:	94 f4       	brge	.+36     	; 0x2896 <LCD_CheckStatusSpecialChar+0x72>
    2872:	8e 81       	ldd	r24, Y+6	; 0x06
    2874:	9f 81       	ldd	r25, Y+7	; 0x07
    2876:	82 30       	cpi	r24, 0x02	; 2
    2878:	91 05       	cpc	r25, r1
    287a:	09 f4       	brne	.+2      	; 0x287e <LCD_CheckStatusSpecialChar+0x5a>
    287c:	3e c0       	rjmp	.+124    	; 0x28fa <LCD_CheckStatusSpecialChar+0xd6>
    287e:	2e 81       	ldd	r18, Y+6	; 0x06
    2880:	3f 81       	ldd	r19, Y+7	; 0x07
    2882:	23 30       	cpi	r18, 0x03	; 3
    2884:	31 05       	cpc	r19, r1
    2886:	0c f0       	brlt	.+2      	; 0x288a <LCD_CheckStatusSpecialChar+0x66>
    2888:	51 c0       	rjmp	.+162    	; 0x292c <LCD_CheckStatusSpecialChar+0x108>
    288a:	8e 81       	ldd	r24, Y+6	; 0x06
    288c:	9f 81       	ldd	r25, Y+7	; 0x07
    288e:	81 30       	cpi	r24, 0x01	; 1
    2890:	91 05       	cpc	r25, r1
    2892:	d1 f0       	breq	.+52     	; 0x28c8 <LCD_CheckStatusSpecialChar+0xa4>
    2894:	e0 c0       	rjmp	.+448    	; 0x2a56 <LCD_CheckStatusSpecialChar+0x232>
    2896:	2e 81       	ldd	r18, Y+6	; 0x06
    2898:	3f 81       	ldd	r19, Y+7	; 0x07
    289a:	26 30       	cpi	r18, 0x06	; 6
    289c:	31 05       	cpc	r19, r1
    289e:	09 f4       	brne	.+2      	; 0x28a2 <LCD_CheckStatusSpecialChar+0x7e>
    28a0:	90 c0       	rjmp	.+288    	; 0x29c2 <LCD_CheckStatusSpecialChar+0x19e>
    28a2:	8e 81       	ldd	r24, Y+6	; 0x06
    28a4:	9f 81       	ldd	r25, Y+7	; 0x07
    28a6:	86 30       	cpi	r24, 0x06	; 6
    28a8:	91 05       	cpc	r25, r1
    28aa:	0c f4       	brge	.+2      	; 0x28ae <LCD_CheckStatusSpecialChar+0x8a>
    28ac:	71 c0       	rjmp	.+226    	; 0x2990 <LCD_CheckStatusSpecialChar+0x16c>
    28ae:	2e 81       	ldd	r18, Y+6	; 0x06
    28b0:	3f 81       	ldd	r19, Y+7	; 0x07
    28b2:	27 30       	cpi	r18, 0x07	; 7
    28b4:	31 05       	cpc	r19, r1
    28b6:	09 f4       	brne	.+2      	; 0x28ba <LCD_CheckStatusSpecialChar+0x96>
    28b8:	9d c0       	rjmp	.+314    	; 0x29f4 <LCD_CheckStatusSpecialChar+0x1d0>
    28ba:	8e 81       	ldd	r24, Y+6	; 0x06
    28bc:	9f 81       	ldd	r25, Y+7	; 0x07
    28be:	88 30       	cpi	r24, 0x08	; 8
    28c0:	91 05       	cpc	r25, r1
    28c2:	09 f4       	brne	.+2      	; 0x28c6 <LCD_CheckStatusSpecialChar+0xa2>
    28c4:	b0 c0       	rjmp	.+352    	; 0x2a26 <LCD_CheckStatusSpecialChar+0x202>
    28c6:	c7 c0       	rjmp	.+398    	; 0x2a56 <LCD_CheckStatusSpecialChar+0x232>
                {

                case 1:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE0);
    28c8:	80 e4       	ldi	r24, 0x40	; 64
    28ca:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    28ce:	19 82       	std	Y+1, r1	; 0x01
    28d0:	10 c0       	rjmp	.+32     	; 0x28f2 <LCD_CheckStatusSpecialChar+0xce>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[0][Local__Uint8CounterJ]);
    28d2:	20 91 bb 01 	lds	r18, 0x01BB
    28d6:	30 91 bc 01 	lds	r19, 0x01BC
    28da:	89 81       	ldd	r24, Y+1	; 0x01
    28dc:	88 2f       	mov	r24, r24
    28de:	90 e0       	ldi	r25, 0x00	; 0
    28e0:	f9 01       	movw	r30, r18
    28e2:	e8 0f       	add	r30, r24
    28e4:	f9 1f       	adc	r31, r25
    28e6:	80 81       	ld	r24, Z
    28e8:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
                switch (Copy__Uint8CGRamLocation)
                {

                case 1:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE0);
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    28ec:	89 81       	ldd	r24, Y+1	; 0x01
    28ee:	8f 5f       	subi	r24, 0xFF	; 255
    28f0:	89 83       	std	Y+1, r24	; 0x01
    28f2:	89 81       	ldd	r24, Y+1	; 0x01
    28f4:	88 30       	cpi	r24, 0x08	; 8
    28f6:	68 f3       	brcs	.-38     	; 0x28d2 <LCD_CheckStatusSpecialChar+0xae>
    28f8:	ae c0       	rjmp	.+348    	; 0x2a56 <LCD_CheckStatusSpecialChar+0x232>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[0][Local__Uint8CounterJ]);
                        }
                        break;
                case 2:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE1);
    28fa:	88 e4       	ldi	r24, 0x48	; 72
    28fc:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    2900:	19 82       	std	Y+1, r1	; 0x01
    2902:	10 c0       	rjmp	.+32     	; 0x2924 <LCD_CheckStatusSpecialChar+0x100>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[1][Local__Uint8CounterJ]);
    2904:	20 91 bd 01 	lds	r18, 0x01BD
    2908:	30 91 be 01 	lds	r19, 0x01BE
    290c:	89 81       	ldd	r24, Y+1	; 0x01
    290e:	88 2f       	mov	r24, r24
    2910:	90 e0       	ldi	r25, 0x00	; 0
    2912:	f9 01       	movw	r30, r18
    2914:	e8 0f       	add	r30, r24
    2916:	f9 1f       	adc	r31, r25
    2918:	80 81       	ld	r24, Z
    291a:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[0][Local__Uint8CounterJ]);
                        }
                        break;
                case 2:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE1);
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    291e:	89 81       	ldd	r24, Y+1	; 0x01
    2920:	8f 5f       	subi	r24, 0xFF	; 255
    2922:	89 83       	std	Y+1, r24	; 0x01
    2924:	89 81       	ldd	r24, Y+1	; 0x01
    2926:	88 30       	cpi	r24, 0x08	; 8
    2928:	68 f3       	brcs	.-38     	; 0x2904 <LCD_CheckStatusSpecialChar+0xe0>
    292a:	95 c0       	rjmp	.+298    	; 0x2a56 <LCD_CheckStatusSpecialChar+0x232>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[1][Local__Uint8CounterJ]);
                        }
                        break;
                case 3:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE2);
    292c:	80 e5       	ldi	r24, 0x50	; 80
    292e:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    2932:	19 82       	std	Y+1, r1	; 0x01
    2934:	10 c0       	rjmp	.+32     	; 0x2956 <LCD_CheckStatusSpecialChar+0x132>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[2][Local__Uint8CounterJ]);
    2936:	20 91 bf 01 	lds	r18, 0x01BF
    293a:	30 91 c0 01 	lds	r19, 0x01C0
    293e:	89 81       	ldd	r24, Y+1	; 0x01
    2940:	88 2f       	mov	r24, r24
    2942:	90 e0       	ldi	r25, 0x00	; 0
    2944:	f9 01       	movw	r30, r18
    2946:	e8 0f       	add	r30, r24
    2948:	f9 1f       	adc	r31, r25
    294a:	80 81       	ld	r24, Z
    294c:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[1][Local__Uint8CounterJ]);
                        }
                        break;
                case 3:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE2);
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    2950:	89 81       	ldd	r24, Y+1	; 0x01
    2952:	8f 5f       	subi	r24, 0xFF	; 255
    2954:	89 83       	std	Y+1, r24	; 0x01
    2956:	89 81       	ldd	r24, Y+1	; 0x01
    2958:	88 30       	cpi	r24, 0x08	; 8
    295a:	68 f3       	brcs	.-38     	; 0x2936 <LCD_CheckStatusSpecialChar+0x112>
    295c:	7c c0       	rjmp	.+248    	; 0x2a56 <LCD_CheckStatusSpecialChar+0x232>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[2][Local__Uint8CounterJ]);
                        }
                        break;
                case 4:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE3);
    295e:	88 e5       	ldi	r24, 0x58	; 88
    2960:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    2964:	19 82       	std	Y+1, r1	; 0x01
    2966:	10 c0       	rjmp	.+32     	; 0x2988 <LCD_CheckStatusSpecialChar+0x164>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[3][Local__Uint8CounterJ]);
    2968:	20 91 c1 01 	lds	r18, 0x01C1
    296c:	30 91 c2 01 	lds	r19, 0x01C2
    2970:	89 81       	ldd	r24, Y+1	; 0x01
    2972:	88 2f       	mov	r24, r24
    2974:	90 e0       	ldi	r25, 0x00	; 0
    2976:	f9 01       	movw	r30, r18
    2978:	e8 0f       	add	r30, r24
    297a:	f9 1f       	adc	r31, r25
    297c:	80 81       	ld	r24, Z
    297e:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[2][Local__Uint8CounterJ]);
                        }
                        break;
                case 4:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE3);
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    2982:	89 81       	ldd	r24, Y+1	; 0x01
    2984:	8f 5f       	subi	r24, 0xFF	; 255
    2986:	89 83       	std	Y+1, r24	; 0x01
    2988:	89 81       	ldd	r24, Y+1	; 0x01
    298a:	88 30       	cpi	r24, 0x08	; 8
    298c:	68 f3       	brcs	.-38     	; 0x2968 <LCD_CheckStatusSpecialChar+0x144>
    298e:	63 c0       	rjmp	.+198    	; 0x2a56 <LCD_CheckStatusSpecialChar+0x232>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[3][Local__Uint8CounterJ]);
                        }
                        break;
                case 5:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE4);
    2990:	80 e6       	ldi	r24, 0x60	; 96
    2992:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    2996:	19 82       	std	Y+1, r1	; 0x01
    2998:	10 c0       	rjmp	.+32     	; 0x29ba <LCD_CheckStatusSpecialChar+0x196>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[4][Local__Uint8CounterJ]);
    299a:	20 91 c3 01 	lds	r18, 0x01C3
    299e:	30 91 c4 01 	lds	r19, 0x01C4
    29a2:	89 81       	ldd	r24, Y+1	; 0x01
    29a4:	88 2f       	mov	r24, r24
    29a6:	90 e0       	ldi	r25, 0x00	; 0
    29a8:	f9 01       	movw	r30, r18
    29aa:	e8 0f       	add	r30, r24
    29ac:	f9 1f       	adc	r31, r25
    29ae:	80 81       	ld	r24, Z
    29b0:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[3][Local__Uint8CounterJ]);
                        }
                        break;
                case 5:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE4);
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    29b4:	89 81       	ldd	r24, Y+1	; 0x01
    29b6:	8f 5f       	subi	r24, 0xFF	; 255
    29b8:	89 83       	std	Y+1, r24	; 0x01
    29ba:	89 81       	ldd	r24, Y+1	; 0x01
    29bc:	88 30       	cpi	r24, 0x08	; 8
    29be:	68 f3       	brcs	.-38     	; 0x299a <LCD_CheckStatusSpecialChar+0x176>
    29c0:	4a c0       	rjmp	.+148    	; 0x2a56 <LCD_CheckStatusSpecialChar+0x232>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[4][Local__Uint8CounterJ]);
                        }
                        break;
                case 6:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE5);
    29c2:	88 e6       	ldi	r24, 0x68	; 104
    29c4:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    29c8:	19 82       	std	Y+1, r1	; 0x01
    29ca:	10 c0       	rjmp	.+32     	; 0x29ec <LCD_CheckStatusSpecialChar+0x1c8>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[5][Local__Uint8CounterJ]);
    29cc:	20 91 c5 01 	lds	r18, 0x01C5
    29d0:	30 91 c6 01 	lds	r19, 0x01C6
    29d4:	89 81       	ldd	r24, Y+1	; 0x01
    29d6:	88 2f       	mov	r24, r24
    29d8:	90 e0       	ldi	r25, 0x00	; 0
    29da:	f9 01       	movw	r30, r18
    29dc:	e8 0f       	add	r30, r24
    29de:	f9 1f       	adc	r31, r25
    29e0:	80 81       	ld	r24, Z
    29e2:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[4][Local__Uint8CounterJ]);
                        }
                        break;
                case 6:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE5);
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    29e6:	89 81       	ldd	r24, Y+1	; 0x01
    29e8:	8f 5f       	subi	r24, 0xFF	; 255
    29ea:	89 83       	std	Y+1, r24	; 0x01
    29ec:	89 81       	ldd	r24, Y+1	; 0x01
    29ee:	88 30       	cpi	r24, 0x08	; 8
    29f0:	68 f3       	brcs	.-38     	; 0x29cc <LCD_CheckStatusSpecialChar+0x1a8>
    29f2:	31 c0       	rjmp	.+98     	; 0x2a56 <LCD_CheckStatusSpecialChar+0x232>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[5][Local__Uint8CounterJ]);
                        }
                        break;
                case 7:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE6);
    29f4:	80 e7       	ldi	r24, 0x70	; 112
    29f6:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    29fa:	19 82       	std	Y+1, r1	; 0x01
    29fc:	10 c0       	rjmp	.+32     	; 0x2a1e <LCD_CheckStatusSpecialChar+0x1fa>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[6][Local__Uint8CounterJ]);
    29fe:	20 91 c7 01 	lds	r18, 0x01C7
    2a02:	30 91 c8 01 	lds	r19, 0x01C8
    2a06:	89 81       	ldd	r24, Y+1	; 0x01
    2a08:	88 2f       	mov	r24, r24
    2a0a:	90 e0       	ldi	r25, 0x00	; 0
    2a0c:	f9 01       	movw	r30, r18
    2a0e:	e8 0f       	add	r30, r24
    2a10:	f9 1f       	adc	r31, r25
    2a12:	80 81       	ld	r24, Z
    2a14:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[5][Local__Uint8CounterJ]);
                        }
                        break;
                case 7:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE6);
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    2a18:	89 81       	ldd	r24, Y+1	; 0x01
    2a1a:	8f 5f       	subi	r24, 0xFF	; 255
    2a1c:	89 83       	std	Y+1, r24	; 0x01
    2a1e:	89 81       	ldd	r24, Y+1	; 0x01
    2a20:	88 30       	cpi	r24, 0x08	; 8
    2a22:	68 f3       	brcs	.-38     	; 0x29fe <LCD_CheckStatusSpecialChar+0x1da>
    2a24:	18 c0       	rjmp	.+48     	; 0x2a56 <LCD_CheckStatusSpecialChar+0x232>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[6][Local__Uint8CounterJ]);
                        }
                        break;
                case 8:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE7);
    2a26:	88 e7       	ldi	r24, 0x78	; 120
    2a28:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    2a2c:	19 82       	std	Y+1, r1	; 0x01
    2a2e:	10 c0       	rjmp	.+32     	; 0x2a50 <LCD_CheckStatusSpecialChar+0x22c>
                        {
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[8][Local__Uint8CounterJ]);
    2a30:	20 91 cb 01 	lds	r18, 0x01CB
    2a34:	30 91 cc 01 	lds	r19, 0x01CC
    2a38:	89 81       	ldd	r24, Y+1	; 0x01
    2a3a:	88 2f       	mov	r24, r24
    2a3c:	90 e0       	ldi	r25, 0x00	; 0
    2a3e:	f9 01       	movw	r30, r18
    2a40:	e8 0f       	add	r30, r24
    2a42:	f9 1f       	adc	r31, r25
    2a44:	80 81       	ld	r24, Z
    2a46:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
                                LCD_CheckStatusSendChar4bit(LCD_A_UINT8SPECIALCHAR[6][Local__Uint8CounterJ]);
                        }
                        break;
                case 8:
                        LCD_CheckStatusSendCmnd4bit(LCD__UINT8_CGRAM_BYTE7);
                        for (Local__Uint8CounterJ = 0; Local__Uint8CounterJ < 8; ++Local__Uint8CounterJ)
    2a4a:	89 81       	ldd	r24, Y+1	; 0x01
    2a4c:	8f 5f       	subi	r24, 0xFF	; 255
    2a4e:	89 83       	std	Y+1, r24	; 0x01
    2a50:	89 81       	ldd	r24, Y+1	; 0x01
    2a52:	88 30       	cpi	r24, 0x08	; 8
    2a54:	68 f3       	brcs	.-38     	; 0x2a30 <LCD_CheckStatusSpecialChar+0x20c>
                        break;
                default:
                        break;
                }

                LCD_CheckStatusGoToXY(Copy__Uint8LCDLine, Copy__Uint8DDRamLocation);
    2a56:	8c 81       	ldd	r24, Y+4	; 0x04
    2a58:	6d 81       	ldd	r22, Y+5	; 0x05
    2a5a:	0e 94 48 12 	call	0x2490	; 0x2490 <LCD_CheckStatusGoToXY>
    2a5e:	02 c0       	rjmp	.+4      	; 0x2a64 <LCD_CheckStatusSpecialChar+0x240>
        }
        else
        {
                Local_CheckStausReturnValue = CHECK_FAIL;
    2a60:	81 e0       	ldi	r24, 0x01	; 1
    2a62:	8a 83       	std	Y+2, r24	; 0x02
        }
        return Local_CheckStausReturnValue;
    2a64:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2a66:	27 96       	adiw	r28, 0x07	; 7
    2a68:	0f b6       	in	r0, 0x3f	; 63
    2a6a:	f8 94       	cli
    2a6c:	de bf       	out	0x3e, r29	; 62
    2a6e:	0f be       	out	0x3f, r0	; 63
    2a70:	cd bf       	out	0x3d, r28	; 61
    2a72:	cf 91       	pop	r28
    2a74:	df 91       	pop	r29
    2a76:	08 95       	ret

00002a78 <LCD_VoidShiftRight>:
Void LCD_VoidShiftRight(_uint8 Copy__Uint8PositionValue, _uint32 Copy__Uint32DelayValue)
{
    2a78:	df 93       	push	r29
    2a7a:	cf 93       	push	r28
    2a7c:	cd b7       	in	r28, 0x3d	; 61
    2a7e:	de b7       	in	r29, 0x3e	; 62
    2a80:	64 97       	sbiw	r28, 0x14	; 20
    2a82:	0f b6       	in	r0, 0x3f	; 63
    2a84:	f8 94       	cli
    2a86:	de bf       	out	0x3e, r29	; 62
    2a88:	0f be       	out	0x3f, r0	; 63
    2a8a:	cd bf       	out	0x3d, r28	; 61
    2a8c:	88 8b       	std	Y+16, r24	; 0x10
    2a8e:	49 8b       	std	Y+17, r20	; 0x11
    2a90:	5a 8b       	std	Y+18, r21	; 0x12
    2a92:	6b 8b       	std	Y+19, r22	; 0x13
    2a94:	7c 8b       	std	Y+20, r23	; 0x14
        _uint8 Local__Uint8Counter;
        for (Local__Uint8Counter = 0; Local__Uint8Counter < Copy__Uint8PositionValue; ++Local__Uint8Counter)
    2a96:	1f 86       	std	Y+15, r1	; 0x0f
    2a98:	7c c0       	rjmp	.+248    	; 0x2b92 <LCD_VoidShiftRight+0x11a>
        {
                LCD_CheckStatusSendCmnd4bit(0b00011100);
    2a9a:	8c e1       	ldi	r24, 0x1C	; 28
    2a9c:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
                _delay_ms(Copy__Uint32DelayValue);
    2aa0:	69 89       	ldd	r22, Y+17	; 0x11
    2aa2:	7a 89       	ldd	r23, Y+18	; 0x12
    2aa4:	8b 89       	ldd	r24, Y+19	; 0x13
    2aa6:	9c 89       	ldd	r25, Y+20	; 0x14
    2aa8:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    2aac:	dc 01       	movw	r26, r24
    2aae:	cb 01       	movw	r24, r22
    2ab0:	8b 87       	std	Y+11, r24	; 0x0b
    2ab2:	9c 87       	std	Y+12, r25	; 0x0c
    2ab4:	ad 87       	std	Y+13, r26	; 0x0d
    2ab6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2ab8:	6b 85       	ldd	r22, Y+11	; 0x0b
    2aba:	7c 85       	ldd	r23, Y+12	; 0x0c
    2abc:	8d 85       	ldd	r24, Y+13	; 0x0d
    2abe:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ac0:	20 e0       	ldi	r18, 0x00	; 0
    2ac2:	30 e0       	ldi	r19, 0x00	; 0
    2ac4:	4a ef       	ldi	r20, 0xFA	; 250
    2ac6:	54 e4       	ldi	r21, 0x44	; 68
    2ac8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2acc:	dc 01       	movw	r26, r24
    2ace:	cb 01       	movw	r24, r22
    2ad0:	8f 83       	std	Y+7, r24	; 0x07
    2ad2:	98 87       	std	Y+8, r25	; 0x08
    2ad4:	a9 87       	std	Y+9, r26	; 0x09
    2ad6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2ad8:	6f 81       	ldd	r22, Y+7	; 0x07
    2ada:	78 85       	ldd	r23, Y+8	; 0x08
    2adc:	89 85       	ldd	r24, Y+9	; 0x09
    2ade:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ae0:	20 e0       	ldi	r18, 0x00	; 0
    2ae2:	30 e0       	ldi	r19, 0x00	; 0
    2ae4:	40 e8       	ldi	r20, 0x80	; 128
    2ae6:	5f e3       	ldi	r21, 0x3F	; 63
    2ae8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2aec:	88 23       	and	r24, r24
    2aee:	2c f4       	brge	.+10     	; 0x2afa <LCD_VoidShiftRight+0x82>
		__ticks = 1;
    2af0:	81 e0       	ldi	r24, 0x01	; 1
    2af2:	90 e0       	ldi	r25, 0x00	; 0
    2af4:	9e 83       	std	Y+6, r25	; 0x06
    2af6:	8d 83       	std	Y+5, r24	; 0x05
    2af8:	3f c0       	rjmp	.+126    	; 0x2b78 <LCD_VoidShiftRight+0x100>
	else if (__tmp > 65535)
    2afa:	6f 81       	ldd	r22, Y+7	; 0x07
    2afc:	78 85       	ldd	r23, Y+8	; 0x08
    2afe:	89 85       	ldd	r24, Y+9	; 0x09
    2b00:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b02:	20 e0       	ldi	r18, 0x00	; 0
    2b04:	3f ef       	ldi	r19, 0xFF	; 255
    2b06:	4f e7       	ldi	r20, 0x7F	; 127
    2b08:	57 e4       	ldi	r21, 0x47	; 71
    2b0a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2b0e:	18 16       	cp	r1, r24
    2b10:	4c f5       	brge	.+82     	; 0x2b64 <LCD_VoidShiftRight+0xec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2b12:	6b 85       	ldd	r22, Y+11	; 0x0b
    2b14:	7c 85       	ldd	r23, Y+12	; 0x0c
    2b16:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b18:	9e 85       	ldd	r25, Y+14	; 0x0e
    2b1a:	20 e0       	ldi	r18, 0x00	; 0
    2b1c:	30 e0       	ldi	r19, 0x00	; 0
    2b1e:	40 e2       	ldi	r20, 0x20	; 32
    2b20:	51 e4       	ldi	r21, 0x41	; 65
    2b22:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2b26:	dc 01       	movw	r26, r24
    2b28:	cb 01       	movw	r24, r22
    2b2a:	bc 01       	movw	r22, r24
    2b2c:	cd 01       	movw	r24, r26
    2b2e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2b32:	dc 01       	movw	r26, r24
    2b34:	cb 01       	movw	r24, r22
    2b36:	9e 83       	std	Y+6, r25	; 0x06
    2b38:	8d 83       	std	Y+5, r24	; 0x05
    2b3a:	0f c0       	rjmp	.+30     	; 0x2b5a <LCD_VoidShiftRight+0xe2>
    2b3c:	88 ec       	ldi	r24, 0xC8	; 200
    2b3e:	90 e0       	ldi	r25, 0x00	; 0
    2b40:	9c 83       	std	Y+4, r25	; 0x04
    2b42:	8b 83       	std	Y+3, r24	; 0x03
    2b44:	8b 81       	ldd	r24, Y+3	; 0x03
    2b46:	9c 81       	ldd	r25, Y+4	; 0x04
    2b48:	01 97       	sbiw	r24, 0x01	; 1
    2b4a:	f1 f7       	brne	.-4      	; 0x2b48 <LCD_VoidShiftRight+0xd0>
    2b4c:	9c 83       	std	Y+4, r25	; 0x04
    2b4e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2b50:	8d 81       	ldd	r24, Y+5	; 0x05
    2b52:	9e 81       	ldd	r25, Y+6	; 0x06
    2b54:	01 97       	sbiw	r24, 0x01	; 1
    2b56:	9e 83       	std	Y+6, r25	; 0x06
    2b58:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2b5a:	8d 81       	ldd	r24, Y+5	; 0x05
    2b5c:	9e 81       	ldd	r25, Y+6	; 0x06
    2b5e:	00 97       	sbiw	r24, 0x00	; 0
    2b60:	69 f7       	brne	.-38     	; 0x2b3c <LCD_VoidShiftRight+0xc4>
    2b62:	14 c0       	rjmp	.+40     	; 0x2b8c <LCD_VoidShiftRight+0x114>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2b64:	6f 81       	ldd	r22, Y+7	; 0x07
    2b66:	78 85       	ldd	r23, Y+8	; 0x08
    2b68:	89 85       	ldd	r24, Y+9	; 0x09
    2b6a:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b6c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2b70:	dc 01       	movw	r26, r24
    2b72:	cb 01       	movw	r24, r22
    2b74:	9e 83       	std	Y+6, r25	; 0x06
    2b76:	8d 83       	std	Y+5, r24	; 0x05
    2b78:	8d 81       	ldd	r24, Y+5	; 0x05
    2b7a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b7c:	9a 83       	std	Y+2, r25	; 0x02
    2b7e:	89 83       	std	Y+1, r24	; 0x01
    2b80:	89 81       	ldd	r24, Y+1	; 0x01
    2b82:	9a 81       	ldd	r25, Y+2	; 0x02
    2b84:	01 97       	sbiw	r24, 0x01	; 1
    2b86:	f1 f7       	brne	.-4      	; 0x2b84 <LCD_VoidShiftRight+0x10c>
    2b88:	9a 83       	std	Y+2, r25	; 0x02
    2b8a:	89 83       	std	Y+1, r24	; 0x01
        return Local_CheckStausReturnValue;
}
Void LCD_VoidShiftRight(_uint8 Copy__Uint8PositionValue, _uint32 Copy__Uint32DelayValue)
{
        _uint8 Local__Uint8Counter;
        for (Local__Uint8Counter = 0; Local__Uint8Counter < Copy__Uint8PositionValue; ++Local__Uint8Counter)
    2b8c:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b8e:	8f 5f       	subi	r24, 0xFF	; 255
    2b90:	8f 87       	std	Y+15, r24	; 0x0f
    2b92:	9f 85       	ldd	r25, Y+15	; 0x0f
    2b94:	88 89       	ldd	r24, Y+16	; 0x10
    2b96:	98 17       	cp	r25, r24
    2b98:	08 f4       	brcc	.+2      	; 0x2b9c <LCD_VoidShiftRight+0x124>
    2b9a:	7f cf       	rjmp	.-258    	; 0x2a9a <LCD_VoidShiftRight+0x22>
        {
                LCD_CheckStatusSendCmnd4bit(0b00011100);
                _delay_ms(Copy__Uint32DelayValue);
        }
}
    2b9c:	64 96       	adiw	r28, 0x14	; 20
    2b9e:	0f b6       	in	r0, 0x3f	; 63
    2ba0:	f8 94       	cli
    2ba2:	de bf       	out	0x3e, r29	; 62
    2ba4:	0f be       	out	0x3f, r0	; 63
    2ba6:	cd bf       	out	0x3d, r28	; 61
    2ba8:	cf 91       	pop	r28
    2baa:	df 91       	pop	r29
    2bac:	08 95       	ret

00002bae <LCD_CheckStatusShiftRightOrLeft>:
CheckStatus LCD_CheckStatusShiftRightOrLeft(_uint32 Copy__Uint32DelayValue)
{
    2bae:	df 93       	push	r29
    2bb0:	cf 93       	push	r28
    2bb2:	cd b7       	in	r28, 0x3d	; 61
    2bb4:	de b7       	in	r29, 0x3e	; 62
    2bb6:	63 97       	sbiw	r28, 0x13	; 19
    2bb8:	0f b6       	in	r0, 0x3f	; 63
    2bba:	f8 94       	cli
    2bbc:	de bf       	out	0x3e, r29	; 62
    2bbe:	0f be       	out	0x3f, r0	; 63
    2bc0:	cd bf       	out	0x3d, r28	; 61
    2bc2:	68 8b       	std	Y+16, r22	; 0x10
    2bc4:	79 8b       	std	Y+17, r23	; 0x11
    2bc6:	8a 8b       	std	Y+18, r24	; 0x12
    2bc8:	9b 8b       	std	Y+19, r25	; 0x13
        CheckStatus Local_CheckStausReturnValue = CHECK_SUCCESS;
    2bca:	1f 86       	std	Y+15, r1	; 0x0f
        {

                if (LCD__UINT8_SHIFT_ACTIVATE == 0)
                {
                        //right
                        LCD_CheckStatusSendCmnd4bit(0b00011100);
    2bcc:	8c e1       	ldi	r24, 0x1C	; 28
    2bce:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
                        _delay_ms(Copy__Uint32DelayValue);
    2bd2:	68 89       	ldd	r22, Y+16	; 0x10
    2bd4:	79 89       	ldd	r23, Y+17	; 0x11
    2bd6:	8a 89       	ldd	r24, Y+18	; 0x12
    2bd8:	9b 89       	ldd	r25, Y+19	; 0x13
    2bda:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    2bde:	dc 01       	movw	r26, r24
    2be0:	cb 01       	movw	r24, r22
    2be2:	8b 87       	std	Y+11, r24	; 0x0b
    2be4:	9c 87       	std	Y+12, r25	; 0x0c
    2be6:	ad 87       	std	Y+13, r26	; 0x0d
    2be8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2bea:	6b 85       	ldd	r22, Y+11	; 0x0b
    2bec:	7c 85       	ldd	r23, Y+12	; 0x0c
    2bee:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bf0:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bf2:	20 e0       	ldi	r18, 0x00	; 0
    2bf4:	30 e0       	ldi	r19, 0x00	; 0
    2bf6:	4a ef       	ldi	r20, 0xFA	; 250
    2bf8:	54 e4       	ldi	r21, 0x44	; 68
    2bfa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2bfe:	dc 01       	movw	r26, r24
    2c00:	cb 01       	movw	r24, r22
    2c02:	8f 83       	std	Y+7, r24	; 0x07
    2c04:	98 87       	std	Y+8, r25	; 0x08
    2c06:	a9 87       	std	Y+9, r26	; 0x09
    2c08:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2c0a:	6f 81       	ldd	r22, Y+7	; 0x07
    2c0c:	78 85       	ldd	r23, Y+8	; 0x08
    2c0e:	89 85       	ldd	r24, Y+9	; 0x09
    2c10:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c12:	20 e0       	ldi	r18, 0x00	; 0
    2c14:	30 e0       	ldi	r19, 0x00	; 0
    2c16:	40 e8       	ldi	r20, 0x80	; 128
    2c18:	5f e3       	ldi	r21, 0x3F	; 63
    2c1a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2c1e:	88 23       	and	r24, r24
    2c20:	2c f4       	brge	.+10     	; 0x2c2c <LCD_CheckStatusShiftRightOrLeft+0x7e>
		__ticks = 1;
    2c22:	81 e0       	ldi	r24, 0x01	; 1
    2c24:	90 e0       	ldi	r25, 0x00	; 0
    2c26:	9e 83       	std	Y+6, r25	; 0x06
    2c28:	8d 83       	std	Y+5, r24	; 0x05
    2c2a:	3f c0       	rjmp	.+126    	; 0x2caa <LCD_CheckStatusShiftRightOrLeft+0xfc>
	else if (__tmp > 65535)
    2c2c:	6f 81       	ldd	r22, Y+7	; 0x07
    2c2e:	78 85       	ldd	r23, Y+8	; 0x08
    2c30:	89 85       	ldd	r24, Y+9	; 0x09
    2c32:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c34:	20 e0       	ldi	r18, 0x00	; 0
    2c36:	3f ef       	ldi	r19, 0xFF	; 255
    2c38:	4f e7       	ldi	r20, 0x7F	; 127
    2c3a:	57 e4       	ldi	r21, 0x47	; 71
    2c3c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2c40:	18 16       	cp	r1, r24
    2c42:	4c f5       	brge	.+82     	; 0x2c96 <LCD_CheckStatusShiftRightOrLeft+0xe8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2c44:	6b 85       	ldd	r22, Y+11	; 0x0b
    2c46:	7c 85       	ldd	r23, Y+12	; 0x0c
    2c48:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c4a:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c4c:	20 e0       	ldi	r18, 0x00	; 0
    2c4e:	30 e0       	ldi	r19, 0x00	; 0
    2c50:	40 e2       	ldi	r20, 0x20	; 32
    2c52:	51 e4       	ldi	r21, 0x41	; 65
    2c54:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2c58:	dc 01       	movw	r26, r24
    2c5a:	cb 01       	movw	r24, r22
    2c5c:	bc 01       	movw	r22, r24
    2c5e:	cd 01       	movw	r24, r26
    2c60:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2c64:	dc 01       	movw	r26, r24
    2c66:	cb 01       	movw	r24, r22
    2c68:	9e 83       	std	Y+6, r25	; 0x06
    2c6a:	8d 83       	std	Y+5, r24	; 0x05
    2c6c:	0f c0       	rjmp	.+30     	; 0x2c8c <LCD_CheckStatusShiftRightOrLeft+0xde>
    2c6e:	88 ec       	ldi	r24, 0xC8	; 200
    2c70:	90 e0       	ldi	r25, 0x00	; 0
    2c72:	9c 83       	std	Y+4, r25	; 0x04
    2c74:	8b 83       	std	Y+3, r24	; 0x03
    2c76:	8b 81       	ldd	r24, Y+3	; 0x03
    2c78:	9c 81       	ldd	r25, Y+4	; 0x04
    2c7a:	01 97       	sbiw	r24, 0x01	; 1
    2c7c:	f1 f7       	brne	.-4      	; 0x2c7a <LCD_CheckStatusShiftRightOrLeft+0xcc>
    2c7e:	9c 83       	std	Y+4, r25	; 0x04
    2c80:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2c82:	8d 81       	ldd	r24, Y+5	; 0x05
    2c84:	9e 81       	ldd	r25, Y+6	; 0x06
    2c86:	01 97       	sbiw	r24, 0x01	; 1
    2c88:	9e 83       	std	Y+6, r25	; 0x06
    2c8a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2c8c:	8d 81       	ldd	r24, Y+5	; 0x05
    2c8e:	9e 81       	ldd	r25, Y+6	; 0x06
    2c90:	00 97       	sbiw	r24, 0x00	; 0
    2c92:	69 f7       	brne	.-38     	; 0x2c6e <LCD_CheckStatusShiftRightOrLeft+0xc0>
    2c94:	14 c0       	rjmp	.+40     	; 0x2cbe <LCD_CheckStatusShiftRightOrLeft+0x110>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2c96:	6f 81       	ldd	r22, Y+7	; 0x07
    2c98:	78 85       	ldd	r23, Y+8	; 0x08
    2c9a:	89 85       	ldd	r24, Y+9	; 0x09
    2c9c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c9e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2ca2:	dc 01       	movw	r26, r24
    2ca4:	cb 01       	movw	r24, r22
    2ca6:	9e 83       	std	Y+6, r25	; 0x06
    2ca8:	8d 83       	std	Y+5, r24	; 0x05
    2caa:	8d 81       	ldd	r24, Y+5	; 0x05
    2cac:	9e 81       	ldd	r25, Y+6	; 0x06
    2cae:	9a 83       	std	Y+2, r25	; 0x02
    2cb0:	89 83       	std	Y+1, r24	; 0x01
    2cb2:	89 81       	ldd	r24, Y+1	; 0x01
    2cb4:	9a 81       	ldd	r25, Y+2	; 0x02
    2cb6:	01 97       	sbiw	r24, 0x01	; 1
    2cb8:	f1 f7       	brne	.-4      	; 0x2cb6 <LCD_CheckStatusShiftRightOrLeft+0x108>
    2cba:	9a 83       	std	Y+2, r25	; 0x02
    2cbc:	89 83       	std	Y+1, r24	; 0x01
        }
        else
        {
                Local_CheckStausReturnValue = CHECK_FAIL;
        }
        return Local_CheckStausReturnValue;
    2cbe:	8f 85       	ldd	r24, Y+15	; 0x0f
}
    2cc0:	63 96       	adiw	r28, 0x13	; 19
    2cc2:	0f b6       	in	r0, 0x3f	; 63
    2cc4:	f8 94       	cli
    2cc6:	de bf       	out	0x3e, r29	; 62
    2cc8:	0f be       	out	0x3f, r0	; 63
    2cca:	cd bf       	out	0x3d, r28	; 61
    2ccc:	cf 91       	pop	r28
    2cce:	df 91       	pop	r29
    2cd0:	08 95       	ret

00002cd2 <LCD_VoidShiftLeft>:
Void LCD_VoidShiftLeft(_uint8 Copy__Uint8PositionValue, _uint32 Copy__Uint32DelayValue)
{
    2cd2:	df 93       	push	r29
    2cd4:	cf 93       	push	r28
    2cd6:	cd b7       	in	r28, 0x3d	; 61
    2cd8:	de b7       	in	r29, 0x3e	; 62
    2cda:	64 97       	sbiw	r28, 0x14	; 20
    2cdc:	0f b6       	in	r0, 0x3f	; 63
    2cde:	f8 94       	cli
    2ce0:	de bf       	out	0x3e, r29	; 62
    2ce2:	0f be       	out	0x3f, r0	; 63
    2ce4:	cd bf       	out	0x3d, r28	; 61
    2ce6:	88 8b       	std	Y+16, r24	; 0x10
    2ce8:	49 8b       	std	Y+17, r20	; 0x11
    2cea:	5a 8b       	std	Y+18, r21	; 0x12
    2cec:	6b 8b       	std	Y+19, r22	; 0x13
    2cee:	7c 8b       	std	Y+20, r23	; 0x14
        _uint8 Local__Uint8Counter;
        for (Local__Uint8Counter = 0; Local__Uint8Counter < Copy__Uint8PositionValue; ++Local__Uint8Counter)
    2cf0:	1f 86       	std	Y+15, r1	; 0x0f
    2cf2:	7c c0       	rjmp	.+248    	; 0x2dec <LCD_VoidShiftLeft+0x11a>
        {
                LCD_CheckStatusSendCmnd4bit(0b00011000);
    2cf4:	88 e1       	ldi	r24, 0x18	; 24
    2cf6:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <LCD_CheckStatusSendCmnd4bit>
                _delay_ms(Copy__Uint32DelayValue);
    2cfa:	69 89       	ldd	r22, Y+17	; 0x11
    2cfc:	7a 89       	ldd	r23, Y+18	; 0x12
    2cfe:	8b 89       	ldd	r24, Y+19	; 0x13
    2d00:	9c 89       	ldd	r25, Y+20	; 0x14
    2d02:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    2d06:	dc 01       	movw	r26, r24
    2d08:	cb 01       	movw	r24, r22
    2d0a:	8b 87       	std	Y+11, r24	; 0x0b
    2d0c:	9c 87       	std	Y+12, r25	; 0x0c
    2d0e:	ad 87       	std	Y+13, r26	; 0x0d
    2d10:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2d12:	6b 85       	ldd	r22, Y+11	; 0x0b
    2d14:	7c 85       	ldd	r23, Y+12	; 0x0c
    2d16:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d18:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d1a:	20 e0       	ldi	r18, 0x00	; 0
    2d1c:	30 e0       	ldi	r19, 0x00	; 0
    2d1e:	4a ef       	ldi	r20, 0xFA	; 250
    2d20:	54 e4       	ldi	r21, 0x44	; 68
    2d22:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2d26:	dc 01       	movw	r26, r24
    2d28:	cb 01       	movw	r24, r22
    2d2a:	8f 83       	std	Y+7, r24	; 0x07
    2d2c:	98 87       	std	Y+8, r25	; 0x08
    2d2e:	a9 87       	std	Y+9, r26	; 0x09
    2d30:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2d32:	6f 81       	ldd	r22, Y+7	; 0x07
    2d34:	78 85       	ldd	r23, Y+8	; 0x08
    2d36:	89 85       	ldd	r24, Y+9	; 0x09
    2d38:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d3a:	20 e0       	ldi	r18, 0x00	; 0
    2d3c:	30 e0       	ldi	r19, 0x00	; 0
    2d3e:	40 e8       	ldi	r20, 0x80	; 128
    2d40:	5f e3       	ldi	r21, 0x3F	; 63
    2d42:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2d46:	88 23       	and	r24, r24
    2d48:	2c f4       	brge	.+10     	; 0x2d54 <LCD_VoidShiftLeft+0x82>
		__ticks = 1;
    2d4a:	81 e0       	ldi	r24, 0x01	; 1
    2d4c:	90 e0       	ldi	r25, 0x00	; 0
    2d4e:	9e 83       	std	Y+6, r25	; 0x06
    2d50:	8d 83       	std	Y+5, r24	; 0x05
    2d52:	3f c0       	rjmp	.+126    	; 0x2dd2 <LCD_VoidShiftLeft+0x100>
	else if (__tmp > 65535)
    2d54:	6f 81       	ldd	r22, Y+7	; 0x07
    2d56:	78 85       	ldd	r23, Y+8	; 0x08
    2d58:	89 85       	ldd	r24, Y+9	; 0x09
    2d5a:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d5c:	20 e0       	ldi	r18, 0x00	; 0
    2d5e:	3f ef       	ldi	r19, 0xFF	; 255
    2d60:	4f e7       	ldi	r20, 0x7F	; 127
    2d62:	57 e4       	ldi	r21, 0x47	; 71
    2d64:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2d68:	18 16       	cp	r1, r24
    2d6a:	4c f5       	brge	.+82     	; 0x2dbe <LCD_VoidShiftLeft+0xec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2d6c:	6b 85       	ldd	r22, Y+11	; 0x0b
    2d6e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2d70:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d72:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d74:	20 e0       	ldi	r18, 0x00	; 0
    2d76:	30 e0       	ldi	r19, 0x00	; 0
    2d78:	40 e2       	ldi	r20, 0x20	; 32
    2d7a:	51 e4       	ldi	r21, 0x41	; 65
    2d7c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2d80:	dc 01       	movw	r26, r24
    2d82:	cb 01       	movw	r24, r22
    2d84:	bc 01       	movw	r22, r24
    2d86:	cd 01       	movw	r24, r26
    2d88:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2d8c:	dc 01       	movw	r26, r24
    2d8e:	cb 01       	movw	r24, r22
    2d90:	9e 83       	std	Y+6, r25	; 0x06
    2d92:	8d 83       	std	Y+5, r24	; 0x05
    2d94:	0f c0       	rjmp	.+30     	; 0x2db4 <LCD_VoidShiftLeft+0xe2>
    2d96:	88 ec       	ldi	r24, 0xC8	; 200
    2d98:	90 e0       	ldi	r25, 0x00	; 0
    2d9a:	9c 83       	std	Y+4, r25	; 0x04
    2d9c:	8b 83       	std	Y+3, r24	; 0x03
    2d9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2da0:	9c 81       	ldd	r25, Y+4	; 0x04
    2da2:	01 97       	sbiw	r24, 0x01	; 1
    2da4:	f1 f7       	brne	.-4      	; 0x2da2 <LCD_VoidShiftLeft+0xd0>
    2da6:	9c 83       	std	Y+4, r25	; 0x04
    2da8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2daa:	8d 81       	ldd	r24, Y+5	; 0x05
    2dac:	9e 81       	ldd	r25, Y+6	; 0x06
    2dae:	01 97       	sbiw	r24, 0x01	; 1
    2db0:	9e 83       	std	Y+6, r25	; 0x06
    2db2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2db4:	8d 81       	ldd	r24, Y+5	; 0x05
    2db6:	9e 81       	ldd	r25, Y+6	; 0x06
    2db8:	00 97       	sbiw	r24, 0x00	; 0
    2dba:	69 f7       	brne	.-38     	; 0x2d96 <LCD_VoidShiftLeft+0xc4>
    2dbc:	14 c0       	rjmp	.+40     	; 0x2de6 <LCD_VoidShiftLeft+0x114>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2dbe:	6f 81       	ldd	r22, Y+7	; 0x07
    2dc0:	78 85       	ldd	r23, Y+8	; 0x08
    2dc2:	89 85       	ldd	r24, Y+9	; 0x09
    2dc4:	9a 85       	ldd	r25, Y+10	; 0x0a
    2dc6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2dca:	dc 01       	movw	r26, r24
    2dcc:	cb 01       	movw	r24, r22
    2dce:	9e 83       	std	Y+6, r25	; 0x06
    2dd0:	8d 83       	std	Y+5, r24	; 0x05
    2dd2:	8d 81       	ldd	r24, Y+5	; 0x05
    2dd4:	9e 81       	ldd	r25, Y+6	; 0x06
    2dd6:	9a 83       	std	Y+2, r25	; 0x02
    2dd8:	89 83       	std	Y+1, r24	; 0x01
    2dda:	89 81       	ldd	r24, Y+1	; 0x01
    2ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    2dde:	01 97       	sbiw	r24, 0x01	; 1
    2de0:	f1 f7       	brne	.-4      	; 0x2dde <LCD_VoidShiftLeft+0x10c>
    2de2:	9a 83       	std	Y+2, r25	; 0x02
    2de4:	89 83       	std	Y+1, r24	; 0x01
        return Local_CheckStausReturnValue;
}
Void LCD_VoidShiftLeft(_uint8 Copy__Uint8PositionValue, _uint32 Copy__Uint32DelayValue)
{
        _uint8 Local__Uint8Counter;
        for (Local__Uint8Counter = 0; Local__Uint8Counter < Copy__Uint8PositionValue; ++Local__Uint8Counter)
    2de6:	8f 85       	ldd	r24, Y+15	; 0x0f
    2de8:	8f 5f       	subi	r24, 0xFF	; 255
    2dea:	8f 87       	std	Y+15, r24	; 0x0f
    2dec:	9f 85       	ldd	r25, Y+15	; 0x0f
    2dee:	88 89       	ldd	r24, Y+16	; 0x10
    2df0:	98 17       	cp	r25, r24
    2df2:	08 f4       	brcc	.+2      	; 0x2df6 <LCD_VoidShiftLeft+0x124>
    2df4:	7f cf       	rjmp	.-258    	; 0x2cf4 <LCD_VoidShiftLeft+0x22>
        {
                LCD_CheckStatusSendCmnd4bit(0b00011000);
                _delay_ms(Copy__Uint32DelayValue);
        }
}
    2df6:	64 96       	adiw	r28, 0x14	; 20
    2df8:	0f b6       	in	r0, 0x3f	; 63
    2dfa:	f8 94       	cli
    2dfc:	de bf       	out	0x3e, r29	; 62
    2dfe:	0f be       	out	0x3f, r0	; 63
    2e00:	cd bf       	out	0x3d, r28	; 61
    2e02:	cf 91       	pop	r28
    2e04:	df 91       	pop	r29
    2e06:	08 95       	ret

00002e08 <LCD_CheckStatusDisplaySpecialChar>:
CheckStatus LCD_CheckStatusDisplaySpecialChar(_uint8 Copy__Uint8Char)
{
    2e08:	df 93       	push	r29
    2e0a:	cf 93       	push	r28
    2e0c:	00 d0       	rcall	.+0      	; 0x2e0e <LCD_CheckStatusDisplaySpecialChar+0x6>
    2e0e:	00 d0       	rcall	.+0      	; 0x2e10 <LCD_CheckStatusDisplaySpecialChar+0x8>
    2e10:	cd b7       	in	r28, 0x3d	; 61
    2e12:	de b7       	in	r29, 0x3e	; 62
    2e14:	8a 83       	std	Y+2, r24	; 0x02
        CheckStatus Local_CheckStausReturnValue = CHECK_SUCCESS;
    2e16:	19 82       	std	Y+1, r1	; 0x01
        if (Copy__Uint8Char <= 8)
    2e18:	8a 81       	ldd	r24, Y+2	; 0x02
    2e1a:	89 30       	cpi	r24, 0x09	; 9
    2e1c:	08 f0       	brcs	.+2      	; 0x2e20 <LCD_CheckStatusDisplaySpecialChar+0x18>
    2e1e:	54 c0       	rjmp	.+168    	; 0x2ec8 <LCD_CheckStatusDisplaySpecialChar+0xc0>
        {
                switch (Copy__Uint8Char)
    2e20:	8a 81       	ldd	r24, Y+2	; 0x02
    2e22:	28 2f       	mov	r18, r24
    2e24:	30 e0       	ldi	r19, 0x00	; 0
    2e26:	3c 83       	std	Y+4, r19	; 0x04
    2e28:	2b 83       	std	Y+3, r18	; 0x03
    2e2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e2e:	84 30       	cpi	r24, 0x04	; 4
    2e30:	91 05       	cpc	r25, r1
    2e32:	b1 f1       	breq	.+108    	; 0x2ea0 <LCD_CheckStatusDisplaySpecialChar+0x98>
    2e34:	2b 81       	ldd	r18, Y+3	; 0x03
    2e36:	3c 81       	ldd	r19, Y+4	; 0x04
    2e38:	25 30       	cpi	r18, 0x05	; 5
    2e3a:	31 05       	cpc	r19, r1
    2e3c:	84 f4       	brge	.+32     	; 0x2e5e <LCD_CheckStatusDisplaySpecialChar+0x56>
    2e3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e40:	9c 81       	ldd	r25, Y+4	; 0x04
    2e42:	82 30       	cpi	r24, 0x02	; 2
    2e44:	91 05       	cpc	r25, r1
    2e46:	21 f1       	breq	.+72     	; 0x2e90 <LCD_CheckStatusDisplaySpecialChar+0x88>
    2e48:	2b 81       	ldd	r18, Y+3	; 0x03
    2e4a:	3c 81       	ldd	r19, Y+4	; 0x04
    2e4c:	23 30       	cpi	r18, 0x03	; 3
    2e4e:	31 05       	cpc	r19, r1
    2e50:	1c f5       	brge	.+70     	; 0x2e98 <LCD_CheckStatusDisplaySpecialChar+0x90>
    2e52:	8b 81       	ldd	r24, Y+3	; 0x03
    2e54:	9c 81       	ldd	r25, Y+4	; 0x04
    2e56:	81 30       	cpi	r24, 0x01	; 1
    2e58:	91 05       	cpc	r25, r1
    2e5a:	b1 f0       	breq	.+44     	; 0x2e88 <LCD_CheckStatusDisplaySpecialChar+0x80>
    2e5c:	37 c0       	rjmp	.+110    	; 0x2ecc <LCD_CheckStatusDisplaySpecialChar+0xc4>
    2e5e:	2b 81       	ldd	r18, Y+3	; 0x03
    2e60:	3c 81       	ldd	r19, Y+4	; 0x04
    2e62:	26 30       	cpi	r18, 0x06	; 6
    2e64:	31 05       	cpc	r19, r1
    2e66:	21 f1       	breq	.+72     	; 0x2eb0 <LCD_CheckStatusDisplaySpecialChar+0xa8>
    2e68:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e6c:	86 30       	cpi	r24, 0x06	; 6
    2e6e:	91 05       	cpc	r25, r1
    2e70:	dc f0       	brlt	.+54     	; 0x2ea8 <LCD_CheckStatusDisplaySpecialChar+0xa0>
    2e72:	2b 81       	ldd	r18, Y+3	; 0x03
    2e74:	3c 81       	ldd	r19, Y+4	; 0x04
    2e76:	27 30       	cpi	r18, 0x07	; 7
    2e78:	31 05       	cpc	r19, r1
    2e7a:	f1 f0       	breq	.+60     	; 0x2eb8 <LCD_CheckStatusDisplaySpecialChar+0xb0>
    2e7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e80:	88 30       	cpi	r24, 0x08	; 8
    2e82:	91 05       	cpc	r25, r1
    2e84:	e9 f0       	breq	.+58     	; 0x2ec0 <LCD_CheckStatusDisplaySpecialChar+0xb8>
    2e86:	22 c0       	rjmp	.+68     	; 0x2ecc <LCD_CheckStatusDisplaySpecialChar+0xc4>
                {

                case 1:
                        LCD_CheckStatusSendChar4bit(0);
    2e88:	80 e0       	ldi	r24, 0x00	; 0
    2e8a:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    2e8e:	1e c0       	rjmp	.+60     	; 0x2ecc <LCD_CheckStatusDisplaySpecialChar+0xc4>
                        break;
                case 2:
                        LCD_CheckStatusSendChar4bit(1);
    2e90:	81 e0       	ldi	r24, 0x01	; 1
    2e92:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    2e96:	1a c0       	rjmp	.+52     	; 0x2ecc <LCD_CheckStatusDisplaySpecialChar+0xc4>
                        break;
                case 3:
                        LCD_CheckStatusSendChar4bit(2);
    2e98:	82 e0       	ldi	r24, 0x02	; 2
    2e9a:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    2e9e:	16 c0       	rjmp	.+44     	; 0x2ecc <LCD_CheckStatusDisplaySpecialChar+0xc4>

                        break;
                case 4:
                        LCD_CheckStatusSendChar4bit(3);
    2ea0:	83 e0       	ldi	r24, 0x03	; 3
    2ea2:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    2ea6:	12 c0       	rjmp	.+36     	; 0x2ecc <LCD_CheckStatusDisplaySpecialChar+0xc4>
                        break;
                case 5:
                        LCD_CheckStatusSendChar4bit(4);
    2ea8:	84 e0       	ldi	r24, 0x04	; 4
    2eaa:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    2eae:	0e c0       	rjmp	.+28     	; 0x2ecc <LCD_CheckStatusDisplaySpecialChar+0xc4>
                        break;
                case 6:
                        LCD_CheckStatusSendChar4bit(5);
    2eb0:	85 e0       	ldi	r24, 0x05	; 5
    2eb2:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    2eb6:	0a c0       	rjmp	.+20     	; 0x2ecc <LCD_CheckStatusDisplaySpecialChar+0xc4>
                        break;
                case 7:
                        LCD_CheckStatusSendChar4bit(6);
    2eb8:	86 e0       	ldi	r24, 0x06	; 6
    2eba:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    2ebe:	06 c0       	rjmp	.+12     	; 0x2ecc <LCD_CheckStatusDisplaySpecialChar+0xc4>
                        break;
                case 8:
                        LCD_CheckStatusSendChar4bit(7);
    2ec0:	87 e0       	ldi	r24, 0x07	; 7
    2ec2:	0e 94 40 1a 	call	0x3480	; 0x3480 <LCD_CheckStatusSendChar4bit>
    2ec6:	02 c0       	rjmp	.+4      	; 0x2ecc <LCD_CheckStatusDisplaySpecialChar+0xc4>
                        break;
                }
        }
        else
        {
                Local_CheckStausReturnValue = CHECK_FAIL;
    2ec8:	81 e0       	ldi	r24, 0x01	; 1
    2eca:	89 83       	std	Y+1, r24	; 0x01
        }
        return Local_CheckStausReturnValue;
    2ecc:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ece:	0f 90       	pop	r0
    2ed0:	0f 90       	pop	r0
    2ed2:	0f 90       	pop	r0
    2ed4:	0f 90       	pop	r0
    2ed6:	cf 91       	pop	r28
    2ed8:	df 91       	pop	r29
    2eda:	08 95       	ret

00002edc <LCD_VoidInit4bit>:
Void LCD_VoidInit4bit(Void)
{
    2edc:	0f 93       	push	r16
    2ede:	1f 93       	push	r17
    2ee0:	df 93       	push	r29
    2ee2:	cf 93       	push	r28
    2ee4:	cd b7       	in	r28, 0x3d	; 61
    2ee6:	de b7       	in	r29, 0x3e	; 62
    2ee8:	cc 54       	subi	r28, 0x4C	; 76
    2eea:	d0 40       	sbci	r29, 0x00	; 0
    2eec:	0f b6       	in	r0, 0x3f	; 63
    2eee:	f8 94       	cli
    2ef0:	de bf       	out	0x3e, r29	; 62
    2ef2:	0f be       	out	0x3f, r0	; 63
    2ef4:	cd bf       	out	0x3d, r28	; 61
    2ef6:	fe 01       	movw	r30, r28
    2ef8:	e7 5b       	subi	r30, 0xB7	; 183
    2efa:	ff 4f       	sbci	r31, 0xFF	; 255
    2efc:	80 e0       	ldi	r24, 0x00	; 0
    2efe:	90 e0       	ldi	r25, 0x00	; 0
    2f00:	ac e0       	ldi	r26, 0x0C	; 12
    2f02:	b2 e4       	ldi	r27, 0x42	; 66
    2f04:	80 83       	st	Z, r24
    2f06:	91 83       	std	Z+1, r25	; 0x01
    2f08:	a2 83       	std	Z+2, r26	; 0x02
    2f0a:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2f0c:	8e 01       	movw	r16, r28
    2f0e:	0b 5b       	subi	r16, 0xBB	; 187
    2f10:	1f 4f       	sbci	r17, 0xFF	; 255
    2f12:	fe 01       	movw	r30, r28
    2f14:	e7 5b       	subi	r30, 0xB7	; 183
    2f16:	ff 4f       	sbci	r31, 0xFF	; 255
    2f18:	60 81       	ld	r22, Z
    2f1a:	71 81       	ldd	r23, Z+1	; 0x01
    2f1c:	82 81       	ldd	r24, Z+2	; 0x02
    2f1e:	93 81       	ldd	r25, Z+3	; 0x03
    2f20:	20 e0       	ldi	r18, 0x00	; 0
    2f22:	30 e0       	ldi	r19, 0x00	; 0
    2f24:	4a ef       	ldi	r20, 0xFA	; 250
    2f26:	54 e4       	ldi	r21, 0x44	; 68
    2f28:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2f2c:	dc 01       	movw	r26, r24
    2f2e:	cb 01       	movw	r24, r22
    2f30:	f8 01       	movw	r30, r16
    2f32:	80 83       	st	Z, r24
    2f34:	91 83       	std	Z+1, r25	; 0x01
    2f36:	a2 83       	std	Z+2, r26	; 0x02
    2f38:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2f3a:	fe 01       	movw	r30, r28
    2f3c:	eb 5b       	subi	r30, 0xBB	; 187
    2f3e:	ff 4f       	sbci	r31, 0xFF	; 255
    2f40:	60 81       	ld	r22, Z
    2f42:	71 81       	ldd	r23, Z+1	; 0x01
    2f44:	82 81       	ldd	r24, Z+2	; 0x02
    2f46:	93 81       	ldd	r25, Z+3	; 0x03
    2f48:	20 e0       	ldi	r18, 0x00	; 0
    2f4a:	30 e0       	ldi	r19, 0x00	; 0
    2f4c:	40 e8       	ldi	r20, 0x80	; 128
    2f4e:	5f e3       	ldi	r21, 0x3F	; 63
    2f50:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2f54:	88 23       	and	r24, r24
    2f56:	44 f4       	brge	.+16     	; 0x2f68 <LCD_VoidInit4bit+0x8c>
		__ticks = 1;
    2f58:	fe 01       	movw	r30, r28
    2f5a:	ed 5b       	subi	r30, 0xBD	; 189
    2f5c:	ff 4f       	sbci	r31, 0xFF	; 255
    2f5e:	81 e0       	ldi	r24, 0x01	; 1
    2f60:	90 e0       	ldi	r25, 0x00	; 0
    2f62:	91 83       	std	Z+1, r25	; 0x01
    2f64:	80 83       	st	Z, r24
    2f66:	64 c0       	rjmp	.+200    	; 0x3030 <LCD_VoidInit4bit+0x154>
	else if (__tmp > 65535)
    2f68:	fe 01       	movw	r30, r28
    2f6a:	eb 5b       	subi	r30, 0xBB	; 187
    2f6c:	ff 4f       	sbci	r31, 0xFF	; 255
    2f6e:	60 81       	ld	r22, Z
    2f70:	71 81       	ldd	r23, Z+1	; 0x01
    2f72:	82 81       	ldd	r24, Z+2	; 0x02
    2f74:	93 81       	ldd	r25, Z+3	; 0x03
    2f76:	20 e0       	ldi	r18, 0x00	; 0
    2f78:	3f ef       	ldi	r19, 0xFF	; 255
    2f7a:	4f e7       	ldi	r20, 0x7F	; 127
    2f7c:	57 e4       	ldi	r21, 0x47	; 71
    2f7e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2f82:	18 16       	cp	r1, r24
    2f84:	0c f0       	brlt	.+2      	; 0x2f88 <LCD_VoidInit4bit+0xac>
    2f86:	43 c0       	rjmp	.+134    	; 0x300e <LCD_VoidInit4bit+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2f88:	fe 01       	movw	r30, r28
    2f8a:	e7 5b       	subi	r30, 0xB7	; 183
    2f8c:	ff 4f       	sbci	r31, 0xFF	; 255
    2f8e:	60 81       	ld	r22, Z
    2f90:	71 81       	ldd	r23, Z+1	; 0x01
    2f92:	82 81       	ldd	r24, Z+2	; 0x02
    2f94:	93 81       	ldd	r25, Z+3	; 0x03
    2f96:	20 e0       	ldi	r18, 0x00	; 0
    2f98:	30 e0       	ldi	r19, 0x00	; 0
    2f9a:	40 e2       	ldi	r20, 0x20	; 32
    2f9c:	51 e4       	ldi	r21, 0x41	; 65
    2f9e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2fa2:	dc 01       	movw	r26, r24
    2fa4:	cb 01       	movw	r24, r22
    2fa6:	8e 01       	movw	r16, r28
    2fa8:	0d 5b       	subi	r16, 0xBD	; 189
    2faa:	1f 4f       	sbci	r17, 0xFF	; 255
    2fac:	bc 01       	movw	r22, r24
    2fae:	cd 01       	movw	r24, r26
    2fb0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2fb4:	dc 01       	movw	r26, r24
    2fb6:	cb 01       	movw	r24, r22
    2fb8:	f8 01       	movw	r30, r16
    2fba:	91 83       	std	Z+1, r25	; 0x01
    2fbc:	80 83       	st	Z, r24
    2fbe:	1f c0       	rjmp	.+62     	; 0x2ffe <LCD_VoidInit4bit+0x122>
    2fc0:	fe 01       	movw	r30, r28
    2fc2:	ef 5b       	subi	r30, 0xBF	; 191
    2fc4:	ff 4f       	sbci	r31, 0xFF	; 255
    2fc6:	88 ec       	ldi	r24, 0xC8	; 200
    2fc8:	90 e0       	ldi	r25, 0x00	; 0
    2fca:	91 83       	std	Z+1, r25	; 0x01
    2fcc:	80 83       	st	Z, r24
    2fce:	fe 01       	movw	r30, r28
    2fd0:	ef 5b       	subi	r30, 0xBF	; 191
    2fd2:	ff 4f       	sbci	r31, 0xFF	; 255
    2fd4:	80 81       	ld	r24, Z
    2fd6:	91 81       	ldd	r25, Z+1	; 0x01
    2fd8:	01 97       	sbiw	r24, 0x01	; 1
    2fda:	f1 f7       	brne	.-4      	; 0x2fd8 <LCD_VoidInit4bit+0xfc>
    2fdc:	fe 01       	movw	r30, r28
    2fde:	ef 5b       	subi	r30, 0xBF	; 191
    2fe0:	ff 4f       	sbci	r31, 0xFF	; 255
    2fe2:	91 83       	std	Z+1, r25	; 0x01
    2fe4:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2fe6:	de 01       	movw	r26, r28
    2fe8:	ad 5b       	subi	r26, 0xBD	; 189
    2fea:	bf 4f       	sbci	r27, 0xFF	; 255
    2fec:	fe 01       	movw	r30, r28
    2fee:	ed 5b       	subi	r30, 0xBD	; 189
    2ff0:	ff 4f       	sbci	r31, 0xFF	; 255
    2ff2:	80 81       	ld	r24, Z
    2ff4:	91 81       	ldd	r25, Z+1	; 0x01
    2ff6:	01 97       	sbiw	r24, 0x01	; 1
    2ff8:	11 96       	adiw	r26, 0x01	; 1
    2ffa:	9c 93       	st	X, r25
    2ffc:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2ffe:	fe 01       	movw	r30, r28
    3000:	ed 5b       	subi	r30, 0xBD	; 189
    3002:	ff 4f       	sbci	r31, 0xFF	; 255
    3004:	80 81       	ld	r24, Z
    3006:	91 81       	ldd	r25, Z+1	; 0x01
    3008:	00 97       	sbiw	r24, 0x00	; 0
    300a:	d1 f6       	brne	.-76     	; 0x2fc0 <LCD_VoidInit4bit+0xe4>
    300c:	24 c0       	rjmp	.+72     	; 0x3056 <LCD_VoidInit4bit+0x17a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    300e:	8e 01       	movw	r16, r28
    3010:	0d 5b       	subi	r16, 0xBD	; 189
    3012:	1f 4f       	sbci	r17, 0xFF	; 255
    3014:	fe 01       	movw	r30, r28
    3016:	eb 5b       	subi	r30, 0xBB	; 187
    3018:	ff 4f       	sbci	r31, 0xFF	; 255
    301a:	60 81       	ld	r22, Z
    301c:	71 81       	ldd	r23, Z+1	; 0x01
    301e:	82 81       	ldd	r24, Z+2	; 0x02
    3020:	93 81       	ldd	r25, Z+3	; 0x03
    3022:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3026:	dc 01       	movw	r26, r24
    3028:	cb 01       	movw	r24, r22
    302a:	f8 01       	movw	r30, r16
    302c:	91 83       	std	Z+1, r25	; 0x01
    302e:	80 83       	st	Z, r24
    3030:	fe 01       	movw	r30, r28
    3032:	ed 5b       	subi	r30, 0xBD	; 189
    3034:	ff 4f       	sbci	r31, 0xFF	; 255
    3036:	80 81       	ld	r24, Z
    3038:	91 81       	ldd	r25, Z+1	; 0x01
    303a:	fe 01       	movw	r30, r28
    303c:	ff 96       	adiw	r30, 0x3f	; 63
    303e:	91 83       	std	Z+1, r25	; 0x01
    3040:	80 83       	st	Z, r24
    3042:	fe 01       	movw	r30, r28
    3044:	ff 96       	adiw	r30, 0x3f	; 63
    3046:	80 81       	ld	r24, Z
    3048:	91 81       	ldd	r25, Z+1	; 0x01
    304a:	01 97       	sbiw	r24, 0x01	; 1
    304c:	f1 f7       	brne	.-4      	; 0x304a <LCD_VoidInit4bit+0x16e>
    304e:	fe 01       	movw	r30, r28
    3050:	ff 96       	adiw	r30, 0x3f	; 63
    3052:	91 83       	std	Z+1, r25	; 0x01
    3054:	80 83       	st	Z, r24
        _delay_ms(35);
        LCD_CheckStatusSendCmnd(0b00100000);
    3056:	80 e2       	ldi	r24, 0x20	; 32
    3058:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
        LCD_CheckStatusSendCmnd(0b00100000);
    305c:	80 e2       	ldi	r24, 0x20	; 32
    305e:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
        LCD_CheckStatusSendCmnd(0b11000000);
    3062:	80 ec       	ldi	r24, 0xC0	; 192
    3064:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
    3068:	80 e0       	ldi	r24, 0x00	; 0
    306a:	90 e0       	ldi	r25, 0x00	; 0
    306c:	a0 e2       	ldi	r26, 0x20	; 32
    306e:	b2 e4       	ldi	r27, 0x42	; 66
    3070:	8b af       	std	Y+59, r24	; 0x3b
    3072:	9c af       	std	Y+60, r25	; 0x3c
    3074:	ad af       	std	Y+61, r26	; 0x3d
    3076:	be af       	std	Y+62, r27	; 0x3e
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3078:	6b ad       	ldd	r22, Y+59	; 0x3b
    307a:	7c ad       	ldd	r23, Y+60	; 0x3c
    307c:	8d ad       	ldd	r24, Y+61	; 0x3d
    307e:	9e ad       	ldd	r25, Y+62	; 0x3e
    3080:	2b ea       	ldi	r18, 0xAB	; 171
    3082:	3a ea       	ldi	r19, 0xAA	; 170
    3084:	4a e2       	ldi	r20, 0x2A	; 42
    3086:	50 e4       	ldi	r21, 0x40	; 64
    3088:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    308c:	dc 01       	movw	r26, r24
    308e:	cb 01       	movw	r24, r22
    3090:	8f ab       	std	Y+55, r24	; 0x37
    3092:	98 af       	std	Y+56, r25	; 0x38
    3094:	a9 af       	std	Y+57, r26	; 0x39
    3096:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
    3098:	6f a9       	ldd	r22, Y+55	; 0x37
    309a:	78 ad       	ldd	r23, Y+56	; 0x38
    309c:	89 ad       	ldd	r24, Y+57	; 0x39
    309e:	9a ad       	ldd	r25, Y+58	; 0x3a
    30a0:	20 e0       	ldi	r18, 0x00	; 0
    30a2:	30 e0       	ldi	r19, 0x00	; 0
    30a4:	40 e8       	ldi	r20, 0x80	; 128
    30a6:	5f e3       	ldi	r21, 0x3F	; 63
    30a8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    30ac:	88 23       	and	r24, r24
    30ae:	1c f4       	brge	.+6      	; 0x30b6 <LCD_VoidInit4bit+0x1da>
		__ticks = 1;
    30b0:	81 e0       	ldi	r24, 0x01	; 1
    30b2:	8e ab       	std	Y+54, r24	; 0x36
    30b4:	91 c0       	rjmp	.+290    	; 0x31d8 <LCD_VoidInit4bit+0x2fc>
	else if (__tmp > 255)
    30b6:	6f a9       	ldd	r22, Y+55	; 0x37
    30b8:	78 ad       	ldd	r23, Y+56	; 0x38
    30ba:	89 ad       	ldd	r24, Y+57	; 0x39
    30bc:	9a ad       	ldd	r25, Y+58	; 0x3a
    30be:	20 e0       	ldi	r18, 0x00	; 0
    30c0:	30 e0       	ldi	r19, 0x00	; 0
    30c2:	4f e7       	ldi	r20, 0x7F	; 127
    30c4:	53 e4       	ldi	r21, 0x43	; 67
    30c6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    30ca:	18 16       	cp	r1, r24
    30cc:	0c f0       	brlt	.+2      	; 0x30d0 <LCD_VoidInit4bit+0x1f4>
    30ce:	7b c0       	rjmp	.+246    	; 0x31c6 <LCD_VoidInit4bit+0x2ea>
	{
		_delay_ms(__us / 1000.0);
    30d0:	6b ad       	ldd	r22, Y+59	; 0x3b
    30d2:	7c ad       	ldd	r23, Y+60	; 0x3c
    30d4:	8d ad       	ldd	r24, Y+61	; 0x3d
    30d6:	9e ad       	ldd	r25, Y+62	; 0x3e
    30d8:	20 e0       	ldi	r18, 0x00	; 0
    30da:	30 e0       	ldi	r19, 0x00	; 0
    30dc:	4a e7       	ldi	r20, 0x7A	; 122
    30de:	54 e4       	ldi	r21, 0x44	; 68
    30e0:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    30e4:	dc 01       	movw	r26, r24
    30e6:	cb 01       	movw	r24, r22
    30e8:	8a ab       	std	Y+50, r24	; 0x32
    30ea:	9b ab       	std	Y+51, r25	; 0x33
    30ec:	ac ab       	std	Y+52, r26	; 0x34
    30ee:	bd ab       	std	Y+53, r27	; 0x35
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    30f0:	6a a9       	ldd	r22, Y+50	; 0x32
    30f2:	7b a9       	ldd	r23, Y+51	; 0x33
    30f4:	8c a9       	ldd	r24, Y+52	; 0x34
    30f6:	9d a9       	ldd	r25, Y+53	; 0x35
    30f8:	20 e0       	ldi	r18, 0x00	; 0
    30fa:	30 e0       	ldi	r19, 0x00	; 0
    30fc:	4a ef       	ldi	r20, 0xFA	; 250
    30fe:	54 e4       	ldi	r21, 0x44	; 68
    3100:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3104:	dc 01       	movw	r26, r24
    3106:	cb 01       	movw	r24, r22
    3108:	8e a7       	std	Y+46, r24	; 0x2e
    310a:	9f a7       	std	Y+47, r25	; 0x2f
    310c:	a8 ab       	std	Y+48, r26	; 0x30
    310e:	b9 ab       	std	Y+49, r27	; 0x31
	if (__tmp < 1.0)
    3110:	6e a5       	ldd	r22, Y+46	; 0x2e
    3112:	7f a5       	ldd	r23, Y+47	; 0x2f
    3114:	88 a9       	ldd	r24, Y+48	; 0x30
    3116:	99 a9       	ldd	r25, Y+49	; 0x31
    3118:	20 e0       	ldi	r18, 0x00	; 0
    311a:	30 e0       	ldi	r19, 0x00	; 0
    311c:	40 e8       	ldi	r20, 0x80	; 128
    311e:	5f e3       	ldi	r21, 0x3F	; 63
    3120:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3124:	88 23       	and	r24, r24
    3126:	2c f4       	brge	.+10     	; 0x3132 <LCD_VoidInit4bit+0x256>
		__ticks = 1;
    3128:	81 e0       	ldi	r24, 0x01	; 1
    312a:	90 e0       	ldi	r25, 0x00	; 0
    312c:	9d a7       	std	Y+45, r25	; 0x2d
    312e:	8c a7       	std	Y+44, r24	; 0x2c
    3130:	3f c0       	rjmp	.+126    	; 0x31b0 <LCD_VoidInit4bit+0x2d4>
	else if (__tmp > 65535)
    3132:	6e a5       	ldd	r22, Y+46	; 0x2e
    3134:	7f a5       	ldd	r23, Y+47	; 0x2f
    3136:	88 a9       	ldd	r24, Y+48	; 0x30
    3138:	99 a9       	ldd	r25, Y+49	; 0x31
    313a:	20 e0       	ldi	r18, 0x00	; 0
    313c:	3f ef       	ldi	r19, 0xFF	; 255
    313e:	4f e7       	ldi	r20, 0x7F	; 127
    3140:	57 e4       	ldi	r21, 0x47	; 71
    3142:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3146:	18 16       	cp	r1, r24
    3148:	4c f5       	brge	.+82     	; 0x319c <LCD_VoidInit4bit+0x2c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    314a:	6a a9       	ldd	r22, Y+50	; 0x32
    314c:	7b a9       	ldd	r23, Y+51	; 0x33
    314e:	8c a9       	ldd	r24, Y+52	; 0x34
    3150:	9d a9       	ldd	r25, Y+53	; 0x35
    3152:	20 e0       	ldi	r18, 0x00	; 0
    3154:	30 e0       	ldi	r19, 0x00	; 0
    3156:	40 e2       	ldi	r20, 0x20	; 32
    3158:	51 e4       	ldi	r21, 0x41	; 65
    315a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    315e:	dc 01       	movw	r26, r24
    3160:	cb 01       	movw	r24, r22
    3162:	bc 01       	movw	r22, r24
    3164:	cd 01       	movw	r24, r26
    3166:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    316a:	dc 01       	movw	r26, r24
    316c:	cb 01       	movw	r24, r22
    316e:	9d a7       	std	Y+45, r25	; 0x2d
    3170:	8c a7       	std	Y+44, r24	; 0x2c
    3172:	0f c0       	rjmp	.+30     	; 0x3192 <LCD_VoidInit4bit+0x2b6>
    3174:	88 ec       	ldi	r24, 0xC8	; 200
    3176:	90 e0       	ldi	r25, 0x00	; 0
    3178:	9b a7       	std	Y+43, r25	; 0x2b
    317a:	8a a7       	std	Y+42, r24	; 0x2a
    317c:	8a a5       	ldd	r24, Y+42	; 0x2a
    317e:	9b a5       	ldd	r25, Y+43	; 0x2b
    3180:	01 97       	sbiw	r24, 0x01	; 1
    3182:	f1 f7       	brne	.-4      	; 0x3180 <LCD_VoidInit4bit+0x2a4>
    3184:	9b a7       	std	Y+43, r25	; 0x2b
    3186:	8a a7       	std	Y+42, r24	; 0x2a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3188:	8c a5       	ldd	r24, Y+44	; 0x2c
    318a:	9d a5       	ldd	r25, Y+45	; 0x2d
    318c:	01 97       	sbiw	r24, 0x01	; 1
    318e:	9d a7       	std	Y+45, r25	; 0x2d
    3190:	8c a7       	std	Y+44, r24	; 0x2c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3192:	8c a5       	ldd	r24, Y+44	; 0x2c
    3194:	9d a5       	ldd	r25, Y+45	; 0x2d
    3196:	00 97       	sbiw	r24, 0x00	; 0
    3198:	69 f7       	brne	.-38     	; 0x3174 <LCD_VoidInit4bit+0x298>
    319a:	24 c0       	rjmp	.+72     	; 0x31e4 <LCD_VoidInit4bit+0x308>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    319c:	6e a5       	ldd	r22, Y+46	; 0x2e
    319e:	7f a5       	ldd	r23, Y+47	; 0x2f
    31a0:	88 a9       	ldd	r24, Y+48	; 0x30
    31a2:	99 a9       	ldd	r25, Y+49	; 0x31
    31a4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    31a8:	dc 01       	movw	r26, r24
    31aa:	cb 01       	movw	r24, r22
    31ac:	9d a7       	std	Y+45, r25	; 0x2d
    31ae:	8c a7       	std	Y+44, r24	; 0x2c
    31b0:	8c a5       	ldd	r24, Y+44	; 0x2c
    31b2:	9d a5       	ldd	r25, Y+45	; 0x2d
    31b4:	99 a7       	std	Y+41, r25	; 0x29
    31b6:	88 a7       	std	Y+40, r24	; 0x28
    31b8:	88 a5       	ldd	r24, Y+40	; 0x28
    31ba:	99 a5       	ldd	r25, Y+41	; 0x29
    31bc:	01 97       	sbiw	r24, 0x01	; 1
    31be:	f1 f7       	brne	.-4      	; 0x31bc <LCD_VoidInit4bit+0x2e0>
    31c0:	99 a7       	std	Y+41, r25	; 0x29
    31c2:	88 a7       	std	Y+40, r24	; 0x28
    31c4:	0f c0       	rjmp	.+30     	; 0x31e4 <LCD_VoidInit4bit+0x308>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    31c6:	6f a9       	ldd	r22, Y+55	; 0x37
    31c8:	78 ad       	ldd	r23, Y+56	; 0x38
    31ca:	89 ad       	ldd	r24, Y+57	; 0x39
    31cc:	9a ad       	ldd	r25, Y+58	; 0x3a
    31ce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    31d2:	dc 01       	movw	r26, r24
    31d4:	cb 01       	movw	r24, r22
    31d6:	8e ab       	std	Y+54, r24	; 0x36
    31d8:	8e a9       	ldd	r24, Y+54	; 0x36
    31da:	8f a3       	std	Y+39, r24	; 0x27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    31dc:	8f a1       	ldd	r24, Y+39	; 0x27
    31de:	8a 95       	dec	r24
    31e0:	f1 f7       	brne	.-4      	; 0x31de <LCD_VoidInit4bit+0x302>
    31e2:	8f a3       	std	Y+39, r24	; 0x27
        _delay_us(40);
        LCD_CheckStatusSendCmnd(0b00000000);
    31e4:	80 e0       	ldi	r24, 0x00	; 0
    31e6:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
        LCD_CheckStatusSendCmnd(0b11110000);
    31ea:	80 ef       	ldi	r24, 0xF0	; 240
    31ec:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
    31f0:	80 e0       	ldi	r24, 0x00	; 0
    31f2:	90 e0       	ldi	r25, 0x00	; 0
    31f4:	a0 e2       	ldi	r26, 0x20	; 32
    31f6:	b2 e4       	ldi	r27, 0x42	; 66
    31f8:	8b a3       	std	Y+35, r24	; 0x23
    31fa:	9c a3       	std	Y+36, r25	; 0x24
    31fc:	ad a3       	std	Y+37, r26	; 0x25
    31fe:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3200:	6b a1       	ldd	r22, Y+35	; 0x23
    3202:	7c a1       	ldd	r23, Y+36	; 0x24
    3204:	8d a1       	ldd	r24, Y+37	; 0x25
    3206:	9e a1       	ldd	r25, Y+38	; 0x26
    3208:	2b ea       	ldi	r18, 0xAB	; 171
    320a:	3a ea       	ldi	r19, 0xAA	; 170
    320c:	4a e2       	ldi	r20, 0x2A	; 42
    320e:	50 e4       	ldi	r21, 0x40	; 64
    3210:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3214:	dc 01       	movw	r26, r24
    3216:	cb 01       	movw	r24, r22
    3218:	8f 8f       	std	Y+31, r24	; 0x1f
    321a:	98 a3       	std	Y+32, r25	; 0x20
    321c:	a9 a3       	std	Y+33, r26	; 0x21
    321e:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    3220:	6f 8d       	ldd	r22, Y+31	; 0x1f
    3222:	78 a1       	ldd	r23, Y+32	; 0x20
    3224:	89 a1       	ldd	r24, Y+33	; 0x21
    3226:	9a a1       	ldd	r25, Y+34	; 0x22
    3228:	20 e0       	ldi	r18, 0x00	; 0
    322a:	30 e0       	ldi	r19, 0x00	; 0
    322c:	40 e8       	ldi	r20, 0x80	; 128
    322e:	5f e3       	ldi	r21, 0x3F	; 63
    3230:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3234:	88 23       	and	r24, r24
    3236:	1c f4       	brge	.+6      	; 0x323e <LCD_VoidInit4bit+0x362>
		__ticks = 1;
    3238:	81 e0       	ldi	r24, 0x01	; 1
    323a:	8e 8f       	std	Y+30, r24	; 0x1e
    323c:	91 c0       	rjmp	.+290    	; 0x3360 <LCD_VoidInit4bit+0x484>
	else if (__tmp > 255)
    323e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    3240:	78 a1       	ldd	r23, Y+32	; 0x20
    3242:	89 a1       	ldd	r24, Y+33	; 0x21
    3244:	9a a1       	ldd	r25, Y+34	; 0x22
    3246:	20 e0       	ldi	r18, 0x00	; 0
    3248:	30 e0       	ldi	r19, 0x00	; 0
    324a:	4f e7       	ldi	r20, 0x7F	; 127
    324c:	53 e4       	ldi	r21, 0x43	; 67
    324e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3252:	18 16       	cp	r1, r24
    3254:	0c f0       	brlt	.+2      	; 0x3258 <LCD_VoidInit4bit+0x37c>
    3256:	7b c0       	rjmp	.+246    	; 0x334e <LCD_VoidInit4bit+0x472>
	{
		_delay_ms(__us / 1000.0);
    3258:	6b a1       	ldd	r22, Y+35	; 0x23
    325a:	7c a1       	ldd	r23, Y+36	; 0x24
    325c:	8d a1       	ldd	r24, Y+37	; 0x25
    325e:	9e a1       	ldd	r25, Y+38	; 0x26
    3260:	20 e0       	ldi	r18, 0x00	; 0
    3262:	30 e0       	ldi	r19, 0x00	; 0
    3264:	4a e7       	ldi	r20, 0x7A	; 122
    3266:	54 e4       	ldi	r21, 0x44	; 68
    3268:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    326c:	dc 01       	movw	r26, r24
    326e:	cb 01       	movw	r24, r22
    3270:	8a 8f       	std	Y+26, r24	; 0x1a
    3272:	9b 8f       	std	Y+27, r25	; 0x1b
    3274:	ac 8f       	std	Y+28, r26	; 0x1c
    3276:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3278:	6a 8d       	ldd	r22, Y+26	; 0x1a
    327a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    327c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    327e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3280:	20 e0       	ldi	r18, 0x00	; 0
    3282:	30 e0       	ldi	r19, 0x00	; 0
    3284:	4a ef       	ldi	r20, 0xFA	; 250
    3286:	54 e4       	ldi	r21, 0x44	; 68
    3288:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    328c:	dc 01       	movw	r26, r24
    328e:	cb 01       	movw	r24, r22
    3290:	8e 8b       	std	Y+22, r24	; 0x16
    3292:	9f 8b       	std	Y+23, r25	; 0x17
    3294:	a8 8f       	std	Y+24, r26	; 0x18
    3296:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    3298:	6e 89       	ldd	r22, Y+22	; 0x16
    329a:	7f 89       	ldd	r23, Y+23	; 0x17
    329c:	88 8d       	ldd	r24, Y+24	; 0x18
    329e:	99 8d       	ldd	r25, Y+25	; 0x19
    32a0:	20 e0       	ldi	r18, 0x00	; 0
    32a2:	30 e0       	ldi	r19, 0x00	; 0
    32a4:	40 e8       	ldi	r20, 0x80	; 128
    32a6:	5f e3       	ldi	r21, 0x3F	; 63
    32a8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    32ac:	88 23       	and	r24, r24
    32ae:	2c f4       	brge	.+10     	; 0x32ba <LCD_VoidInit4bit+0x3de>
		__ticks = 1;
    32b0:	81 e0       	ldi	r24, 0x01	; 1
    32b2:	90 e0       	ldi	r25, 0x00	; 0
    32b4:	9d 8b       	std	Y+21, r25	; 0x15
    32b6:	8c 8b       	std	Y+20, r24	; 0x14
    32b8:	3f c0       	rjmp	.+126    	; 0x3338 <LCD_VoidInit4bit+0x45c>
	else if (__tmp > 65535)
    32ba:	6e 89       	ldd	r22, Y+22	; 0x16
    32bc:	7f 89       	ldd	r23, Y+23	; 0x17
    32be:	88 8d       	ldd	r24, Y+24	; 0x18
    32c0:	99 8d       	ldd	r25, Y+25	; 0x19
    32c2:	20 e0       	ldi	r18, 0x00	; 0
    32c4:	3f ef       	ldi	r19, 0xFF	; 255
    32c6:	4f e7       	ldi	r20, 0x7F	; 127
    32c8:	57 e4       	ldi	r21, 0x47	; 71
    32ca:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    32ce:	18 16       	cp	r1, r24
    32d0:	4c f5       	brge	.+82     	; 0x3324 <LCD_VoidInit4bit+0x448>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    32d2:	6a 8d       	ldd	r22, Y+26	; 0x1a
    32d4:	7b 8d       	ldd	r23, Y+27	; 0x1b
    32d6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    32d8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    32da:	20 e0       	ldi	r18, 0x00	; 0
    32dc:	30 e0       	ldi	r19, 0x00	; 0
    32de:	40 e2       	ldi	r20, 0x20	; 32
    32e0:	51 e4       	ldi	r21, 0x41	; 65
    32e2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    32e6:	dc 01       	movw	r26, r24
    32e8:	cb 01       	movw	r24, r22
    32ea:	bc 01       	movw	r22, r24
    32ec:	cd 01       	movw	r24, r26
    32ee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    32f2:	dc 01       	movw	r26, r24
    32f4:	cb 01       	movw	r24, r22
    32f6:	9d 8b       	std	Y+21, r25	; 0x15
    32f8:	8c 8b       	std	Y+20, r24	; 0x14
    32fa:	0f c0       	rjmp	.+30     	; 0x331a <LCD_VoidInit4bit+0x43e>
    32fc:	88 ec       	ldi	r24, 0xC8	; 200
    32fe:	90 e0       	ldi	r25, 0x00	; 0
    3300:	9b 8b       	std	Y+19, r25	; 0x13
    3302:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3304:	8a 89       	ldd	r24, Y+18	; 0x12
    3306:	9b 89       	ldd	r25, Y+19	; 0x13
    3308:	01 97       	sbiw	r24, 0x01	; 1
    330a:	f1 f7       	brne	.-4      	; 0x3308 <LCD_VoidInit4bit+0x42c>
    330c:	9b 8b       	std	Y+19, r25	; 0x13
    330e:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3310:	8c 89       	ldd	r24, Y+20	; 0x14
    3312:	9d 89       	ldd	r25, Y+21	; 0x15
    3314:	01 97       	sbiw	r24, 0x01	; 1
    3316:	9d 8b       	std	Y+21, r25	; 0x15
    3318:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    331a:	8c 89       	ldd	r24, Y+20	; 0x14
    331c:	9d 89       	ldd	r25, Y+21	; 0x15
    331e:	00 97       	sbiw	r24, 0x00	; 0
    3320:	69 f7       	brne	.-38     	; 0x32fc <LCD_VoidInit4bit+0x420>
    3322:	24 c0       	rjmp	.+72     	; 0x336c <LCD_VoidInit4bit+0x490>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3324:	6e 89       	ldd	r22, Y+22	; 0x16
    3326:	7f 89       	ldd	r23, Y+23	; 0x17
    3328:	88 8d       	ldd	r24, Y+24	; 0x18
    332a:	99 8d       	ldd	r25, Y+25	; 0x19
    332c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3330:	dc 01       	movw	r26, r24
    3332:	cb 01       	movw	r24, r22
    3334:	9d 8b       	std	Y+21, r25	; 0x15
    3336:	8c 8b       	std	Y+20, r24	; 0x14
    3338:	8c 89       	ldd	r24, Y+20	; 0x14
    333a:	9d 89       	ldd	r25, Y+21	; 0x15
    333c:	99 8b       	std	Y+17, r25	; 0x11
    333e:	88 8b       	std	Y+16, r24	; 0x10
    3340:	88 89       	ldd	r24, Y+16	; 0x10
    3342:	99 89       	ldd	r25, Y+17	; 0x11
    3344:	01 97       	sbiw	r24, 0x01	; 1
    3346:	f1 f7       	brne	.-4      	; 0x3344 <LCD_VoidInit4bit+0x468>
    3348:	99 8b       	std	Y+17, r25	; 0x11
    334a:	88 8b       	std	Y+16, r24	; 0x10
    334c:	0f c0       	rjmp	.+30     	; 0x336c <LCD_VoidInit4bit+0x490>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    334e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    3350:	78 a1       	ldd	r23, Y+32	; 0x20
    3352:	89 a1       	ldd	r24, Y+33	; 0x21
    3354:	9a a1       	ldd	r25, Y+34	; 0x22
    3356:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    335a:	dc 01       	movw	r26, r24
    335c:	cb 01       	movw	r24, r22
    335e:	8e 8f       	std	Y+30, r24	; 0x1e
    3360:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3362:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3364:	8f 85       	ldd	r24, Y+15	; 0x0f
    3366:	8a 95       	dec	r24
    3368:	f1 f7       	brne	.-4      	; 0x3366 <LCD_VoidInit4bit+0x48a>
    336a:	8f 87       	std	Y+15, r24	; 0x0f
        _delay_us(40);
        LCD_CheckStatusSendCmnd(0b00000000);
    336c:	80 e0       	ldi	r24, 0x00	; 0
    336e:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
        LCD_CheckStatusSendCmnd(0b00010000);
    3372:	80 e1       	ldi	r24, 0x10	; 16
    3374:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
    3378:	80 e0       	ldi	r24, 0x00	; 0
    337a:	90 e0       	ldi	r25, 0x00	; 0
    337c:	a0 e0       	ldi	r26, 0x00	; 0
    337e:	b0 e4       	ldi	r27, 0x40	; 64
    3380:	8b 87       	std	Y+11, r24	; 0x0b
    3382:	9c 87       	std	Y+12, r25	; 0x0c
    3384:	ad 87       	std	Y+13, r26	; 0x0d
    3386:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3388:	6b 85       	ldd	r22, Y+11	; 0x0b
    338a:	7c 85       	ldd	r23, Y+12	; 0x0c
    338c:	8d 85       	ldd	r24, Y+13	; 0x0d
    338e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3390:	20 e0       	ldi	r18, 0x00	; 0
    3392:	30 e0       	ldi	r19, 0x00	; 0
    3394:	4a ef       	ldi	r20, 0xFA	; 250
    3396:	54 e4       	ldi	r21, 0x44	; 68
    3398:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    339c:	dc 01       	movw	r26, r24
    339e:	cb 01       	movw	r24, r22
    33a0:	8f 83       	std	Y+7, r24	; 0x07
    33a2:	98 87       	std	Y+8, r25	; 0x08
    33a4:	a9 87       	std	Y+9, r26	; 0x09
    33a6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    33a8:	6f 81       	ldd	r22, Y+7	; 0x07
    33aa:	78 85       	ldd	r23, Y+8	; 0x08
    33ac:	89 85       	ldd	r24, Y+9	; 0x09
    33ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    33b0:	20 e0       	ldi	r18, 0x00	; 0
    33b2:	30 e0       	ldi	r19, 0x00	; 0
    33b4:	40 e8       	ldi	r20, 0x80	; 128
    33b6:	5f e3       	ldi	r21, 0x3F	; 63
    33b8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    33bc:	88 23       	and	r24, r24
    33be:	2c f4       	brge	.+10     	; 0x33ca <LCD_VoidInit4bit+0x4ee>
		__ticks = 1;
    33c0:	81 e0       	ldi	r24, 0x01	; 1
    33c2:	90 e0       	ldi	r25, 0x00	; 0
    33c4:	9e 83       	std	Y+6, r25	; 0x06
    33c6:	8d 83       	std	Y+5, r24	; 0x05
    33c8:	3f c0       	rjmp	.+126    	; 0x3448 <LCD_VoidInit4bit+0x56c>
	else if (__tmp > 65535)
    33ca:	6f 81       	ldd	r22, Y+7	; 0x07
    33cc:	78 85       	ldd	r23, Y+8	; 0x08
    33ce:	89 85       	ldd	r24, Y+9	; 0x09
    33d0:	9a 85       	ldd	r25, Y+10	; 0x0a
    33d2:	20 e0       	ldi	r18, 0x00	; 0
    33d4:	3f ef       	ldi	r19, 0xFF	; 255
    33d6:	4f e7       	ldi	r20, 0x7F	; 127
    33d8:	57 e4       	ldi	r21, 0x47	; 71
    33da:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    33de:	18 16       	cp	r1, r24
    33e0:	4c f5       	brge	.+82     	; 0x3434 <LCD_VoidInit4bit+0x558>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    33e2:	6b 85       	ldd	r22, Y+11	; 0x0b
    33e4:	7c 85       	ldd	r23, Y+12	; 0x0c
    33e6:	8d 85       	ldd	r24, Y+13	; 0x0d
    33e8:	9e 85       	ldd	r25, Y+14	; 0x0e
    33ea:	20 e0       	ldi	r18, 0x00	; 0
    33ec:	30 e0       	ldi	r19, 0x00	; 0
    33ee:	40 e2       	ldi	r20, 0x20	; 32
    33f0:	51 e4       	ldi	r21, 0x41	; 65
    33f2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    33f6:	dc 01       	movw	r26, r24
    33f8:	cb 01       	movw	r24, r22
    33fa:	bc 01       	movw	r22, r24
    33fc:	cd 01       	movw	r24, r26
    33fe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3402:	dc 01       	movw	r26, r24
    3404:	cb 01       	movw	r24, r22
    3406:	9e 83       	std	Y+6, r25	; 0x06
    3408:	8d 83       	std	Y+5, r24	; 0x05
    340a:	0f c0       	rjmp	.+30     	; 0x342a <LCD_VoidInit4bit+0x54e>
    340c:	88 ec       	ldi	r24, 0xC8	; 200
    340e:	90 e0       	ldi	r25, 0x00	; 0
    3410:	9c 83       	std	Y+4, r25	; 0x04
    3412:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3414:	8b 81       	ldd	r24, Y+3	; 0x03
    3416:	9c 81       	ldd	r25, Y+4	; 0x04
    3418:	01 97       	sbiw	r24, 0x01	; 1
    341a:	f1 f7       	brne	.-4      	; 0x3418 <LCD_VoidInit4bit+0x53c>
    341c:	9c 83       	std	Y+4, r25	; 0x04
    341e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3420:	8d 81       	ldd	r24, Y+5	; 0x05
    3422:	9e 81       	ldd	r25, Y+6	; 0x06
    3424:	01 97       	sbiw	r24, 0x01	; 1
    3426:	9e 83       	std	Y+6, r25	; 0x06
    3428:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    342a:	8d 81       	ldd	r24, Y+5	; 0x05
    342c:	9e 81       	ldd	r25, Y+6	; 0x06
    342e:	00 97       	sbiw	r24, 0x00	; 0
    3430:	69 f7       	brne	.-38     	; 0x340c <LCD_VoidInit4bit+0x530>
    3432:	14 c0       	rjmp	.+40     	; 0x345c <LCD_VoidInit4bit+0x580>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3434:	6f 81       	ldd	r22, Y+7	; 0x07
    3436:	78 85       	ldd	r23, Y+8	; 0x08
    3438:	89 85       	ldd	r24, Y+9	; 0x09
    343a:	9a 85       	ldd	r25, Y+10	; 0x0a
    343c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3440:	dc 01       	movw	r26, r24
    3442:	cb 01       	movw	r24, r22
    3444:	9e 83       	std	Y+6, r25	; 0x06
    3446:	8d 83       	std	Y+5, r24	; 0x05
    3448:	8d 81       	ldd	r24, Y+5	; 0x05
    344a:	9e 81       	ldd	r25, Y+6	; 0x06
    344c:	9a 83       	std	Y+2, r25	; 0x02
    344e:	89 83       	std	Y+1, r24	; 0x01
    3450:	89 81       	ldd	r24, Y+1	; 0x01
    3452:	9a 81       	ldd	r25, Y+2	; 0x02
    3454:	01 97       	sbiw	r24, 0x01	; 1
    3456:	f1 f7       	brne	.-4      	; 0x3454 <LCD_VoidInit4bit+0x578>
    3458:	9a 83       	std	Y+2, r25	; 0x02
    345a:	89 83       	std	Y+1, r24	; 0x01
        _delay_ms(2);
        LCD_CheckStatusSendCmnd(0b00000000);
    345c:	80 e0       	ldi	r24, 0x00	; 0
    345e:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
        LCD_CheckStatusSendCmnd(0b01100000);
    3462:	80 e6       	ldi	r24, 0x60	; 96
    3464:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <LCD_CheckStatusSendCmnd>
}
    3468:	c4 5b       	subi	r28, 0xB4	; 180
    346a:	df 4f       	sbci	r29, 0xFF	; 255
    346c:	0f b6       	in	r0, 0x3f	; 63
    346e:	f8 94       	cli
    3470:	de bf       	out	0x3e, r29	; 62
    3472:	0f be       	out	0x3f, r0	; 63
    3474:	cd bf       	out	0x3d, r28	; 61
    3476:	cf 91       	pop	r28
    3478:	df 91       	pop	r29
    347a:	1f 91       	pop	r17
    347c:	0f 91       	pop	r16
    347e:	08 95       	ret

00003480 <LCD_CheckStatusSendChar4bit>:

CheckStatus LCD_CheckStatusSendChar4bit(_uint8 Copy__Uint8Char)
{
    3480:	0f 93       	push	r16
    3482:	1f 93       	push	r17
    3484:	df 93       	push	r29
    3486:	cf 93       	push	r28
    3488:	cd b7       	in	r28, 0x3d	; 61
    348a:	de b7       	in	r29, 0x3e	; 62
    348c:	c2 56       	subi	r28, 0x62	; 98
    348e:	d0 40       	sbci	r29, 0x00	; 0
    3490:	0f b6       	in	r0, 0x3f	; 63
    3492:	f8 94       	cli
    3494:	de bf       	out	0x3e, r29	; 62
    3496:	0f be       	out	0x3f, r0	; 63
    3498:	cd bf       	out	0x3d, r28	; 61
    349a:	fe 01       	movw	r30, r28
    349c:	ee 59       	subi	r30, 0x9E	; 158
    349e:	ff 4f       	sbci	r31, 0xFF	; 255
    34a0:	80 83       	st	Z, r24
        CheckStatus Local_CheckStausReturnValue = CHECK_SUCCESS;
    34a2:	fe 01       	movw	r30, r28
    34a4:	ef 59       	subi	r30, 0x9F	; 159
    34a6:	ff 4f       	sbci	r31, 0xFF	; 255
    34a8:	10 82       	st	Z, r1
	         3-Send CHAR byte  to the Data Pins of LCD
	         4-PULSE of Enable E = 1 ,E = 0
	        */
        if (Copy__Uint8Char <= 255)
        {
                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_RS_PIN, DIO__UINT8_HIGH);
    34aa:	83 e0       	ldi	r24, 0x03	; 3
    34ac:	60 e0       	ldi	r22, 0x00	; 0
    34ae:	41 e0       	ldi	r20, 0x01	; 1
    34b0:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_RW_PIN, DIO__UINT8_LOW);
    34b4:	83 e0       	ldi	r24, 0x03	; 3
    34b6:	61 e0       	ldi	r22, 0x01	; 1
    34b8:	40 e0       	ldi	r20, 0x00	; 0
    34ba:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>

                DIO__CheckStatusSetPortValue(LCD__UINT8_DATA_PORT, Copy__Uint8Char & LCD__UINT8_DATA_PINS);
    34be:	fe 01       	movw	r30, r28
    34c0:	ee 59       	subi	r30, 0x9E	; 158
    34c2:	ff 4f       	sbci	r31, 0xFF	; 255
    34c4:	80 81       	ld	r24, Z
    34c6:	98 2f       	mov	r25, r24
    34c8:	90 7f       	andi	r25, 0xF0	; 240
    34ca:	82 e0       	ldi	r24, 0x02	; 2
    34cc:	69 2f       	mov	r22, r25
    34ce:	0e 94 4a 0b 	call	0x1694	; 0x1694 <DIO__CheckStatusSetPortValue>

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_E_PIN, DIO__UINT8_HIGH);
    34d2:	83 e0       	ldi	r24, 0x03	; 3
    34d4:	62 e0       	ldi	r22, 0x02	; 2
    34d6:	41 e0       	ldi	r20, 0x01	; 1
    34d8:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>
    34dc:	fe 01       	movw	r30, r28
    34de:	e3 5a       	subi	r30, 0xA3	; 163
    34e0:	ff 4f       	sbci	r31, 0xFF	; 255
    34e2:	80 e0       	ldi	r24, 0x00	; 0
    34e4:	90 e0       	ldi	r25, 0x00	; 0
    34e6:	a0 e8       	ldi	r26, 0x80	; 128
    34e8:	bf e3       	ldi	r27, 0x3F	; 63
    34ea:	80 83       	st	Z, r24
    34ec:	91 83       	std	Z+1, r25	; 0x01
    34ee:	a2 83       	std	Z+2, r26	; 0x02
    34f0:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    34f2:	8e 01       	movw	r16, r28
    34f4:	07 5a       	subi	r16, 0xA7	; 167
    34f6:	1f 4f       	sbci	r17, 0xFF	; 255
    34f8:	fe 01       	movw	r30, r28
    34fa:	e3 5a       	subi	r30, 0xA3	; 163
    34fc:	ff 4f       	sbci	r31, 0xFF	; 255
    34fe:	60 81       	ld	r22, Z
    3500:	71 81       	ldd	r23, Z+1	; 0x01
    3502:	82 81       	ldd	r24, Z+2	; 0x02
    3504:	93 81       	ldd	r25, Z+3	; 0x03
    3506:	2b ea       	ldi	r18, 0xAB	; 171
    3508:	3a ea       	ldi	r19, 0xAA	; 170
    350a:	4a e2       	ldi	r20, 0x2A	; 42
    350c:	50 e4       	ldi	r21, 0x40	; 64
    350e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3512:	dc 01       	movw	r26, r24
    3514:	cb 01       	movw	r24, r22
    3516:	f8 01       	movw	r30, r16
    3518:	80 83       	st	Z, r24
    351a:	91 83       	std	Z+1, r25	; 0x01
    351c:	a2 83       	std	Z+2, r26	; 0x02
    351e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3520:	fe 01       	movw	r30, r28
    3522:	e7 5a       	subi	r30, 0xA7	; 167
    3524:	ff 4f       	sbci	r31, 0xFF	; 255
    3526:	60 81       	ld	r22, Z
    3528:	71 81       	ldd	r23, Z+1	; 0x01
    352a:	82 81       	ldd	r24, Z+2	; 0x02
    352c:	93 81       	ldd	r25, Z+3	; 0x03
    352e:	20 e0       	ldi	r18, 0x00	; 0
    3530:	30 e0       	ldi	r19, 0x00	; 0
    3532:	40 e8       	ldi	r20, 0x80	; 128
    3534:	5f e3       	ldi	r21, 0x3F	; 63
    3536:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    353a:	88 23       	and	r24, r24
    353c:	34 f4       	brge	.+12     	; 0x354a <LCD_CheckStatusSendChar4bit+0xca>
		__ticks = 1;
    353e:	fe 01       	movw	r30, r28
    3540:	e8 5a       	subi	r30, 0xA8	; 168
    3542:	ff 4f       	sbci	r31, 0xFF	; 255
    3544:	81 e0       	ldi	r24, 0x01	; 1
    3546:	80 83       	st	Z, r24
    3548:	e0 c0       	rjmp	.+448    	; 0x370a <LCD_CheckStatusSendChar4bit+0x28a>
	else if (__tmp > 255)
    354a:	fe 01       	movw	r30, r28
    354c:	e7 5a       	subi	r30, 0xA7	; 167
    354e:	ff 4f       	sbci	r31, 0xFF	; 255
    3550:	60 81       	ld	r22, Z
    3552:	71 81       	ldd	r23, Z+1	; 0x01
    3554:	82 81       	ldd	r24, Z+2	; 0x02
    3556:	93 81       	ldd	r25, Z+3	; 0x03
    3558:	20 e0       	ldi	r18, 0x00	; 0
    355a:	30 e0       	ldi	r19, 0x00	; 0
    355c:	4f e7       	ldi	r20, 0x7F	; 127
    355e:	53 e4       	ldi	r21, 0x43	; 67
    3560:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3564:	18 16       	cp	r1, r24
    3566:	0c f0       	brlt	.+2      	; 0x356a <LCD_CheckStatusSendChar4bit+0xea>
    3568:	c0 c0       	rjmp	.+384    	; 0x36ea <LCD_CheckStatusSendChar4bit+0x26a>
	{
		_delay_ms(__us / 1000.0);
    356a:	fe 01       	movw	r30, r28
    356c:	e3 5a       	subi	r30, 0xA3	; 163
    356e:	ff 4f       	sbci	r31, 0xFF	; 255
    3570:	60 81       	ld	r22, Z
    3572:	71 81       	ldd	r23, Z+1	; 0x01
    3574:	82 81       	ldd	r24, Z+2	; 0x02
    3576:	93 81       	ldd	r25, Z+3	; 0x03
    3578:	20 e0       	ldi	r18, 0x00	; 0
    357a:	30 e0       	ldi	r19, 0x00	; 0
    357c:	4a e7       	ldi	r20, 0x7A	; 122
    357e:	54 e4       	ldi	r21, 0x44	; 68
    3580:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3584:	dc 01       	movw	r26, r24
    3586:	cb 01       	movw	r24, r22
    3588:	fe 01       	movw	r30, r28
    358a:	ec 5a       	subi	r30, 0xAC	; 172
    358c:	ff 4f       	sbci	r31, 0xFF	; 255
    358e:	80 83       	st	Z, r24
    3590:	91 83       	std	Z+1, r25	; 0x01
    3592:	a2 83       	std	Z+2, r26	; 0x02
    3594:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3596:	8e 01       	movw	r16, r28
    3598:	00 5b       	subi	r16, 0xB0	; 176
    359a:	1f 4f       	sbci	r17, 0xFF	; 255
    359c:	fe 01       	movw	r30, r28
    359e:	ec 5a       	subi	r30, 0xAC	; 172
    35a0:	ff 4f       	sbci	r31, 0xFF	; 255
    35a2:	60 81       	ld	r22, Z
    35a4:	71 81       	ldd	r23, Z+1	; 0x01
    35a6:	82 81       	ldd	r24, Z+2	; 0x02
    35a8:	93 81       	ldd	r25, Z+3	; 0x03
    35aa:	20 e0       	ldi	r18, 0x00	; 0
    35ac:	30 e0       	ldi	r19, 0x00	; 0
    35ae:	4a ef       	ldi	r20, 0xFA	; 250
    35b0:	54 e4       	ldi	r21, 0x44	; 68
    35b2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    35b6:	dc 01       	movw	r26, r24
    35b8:	cb 01       	movw	r24, r22
    35ba:	f8 01       	movw	r30, r16
    35bc:	80 83       	st	Z, r24
    35be:	91 83       	std	Z+1, r25	; 0x01
    35c0:	a2 83       	std	Z+2, r26	; 0x02
    35c2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    35c4:	fe 01       	movw	r30, r28
    35c6:	e0 5b       	subi	r30, 0xB0	; 176
    35c8:	ff 4f       	sbci	r31, 0xFF	; 255
    35ca:	60 81       	ld	r22, Z
    35cc:	71 81       	ldd	r23, Z+1	; 0x01
    35ce:	82 81       	ldd	r24, Z+2	; 0x02
    35d0:	93 81       	ldd	r25, Z+3	; 0x03
    35d2:	20 e0       	ldi	r18, 0x00	; 0
    35d4:	30 e0       	ldi	r19, 0x00	; 0
    35d6:	40 e8       	ldi	r20, 0x80	; 128
    35d8:	5f e3       	ldi	r21, 0x3F	; 63
    35da:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    35de:	88 23       	and	r24, r24
    35e0:	44 f4       	brge	.+16     	; 0x35f2 <LCD_CheckStatusSendChar4bit+0x172>
		__ticks = 1;
    35e2:	fe 01       	movw	r30, r28
    35e4:	e2 5b       	subi	r30, 0xB2	; 178
    35e6:	ff 4f       	sbci	r31, 0xFF	; 255
    35e8:	81 e0       	ldi	r24, 0x01	; 1
    35ea:	90 e0       	ldi	r25, 0x00	; 0
    35ec:	91 83       	std	Z+1, r25	; 0x01
    35ee:	80 83       	st	Z, r24
    35f0:	64 c0       	rjmp	.+200    	; 0x36ba <LCD_CheckStatusSendChar4bit+0x23a>
	else if (__tmp > 65535)
    35f2:	fe 01       	movw	r30, r28
    35f4:	e0 5b       	subi	r30, 0xB0	; 176
    35f6:	ff 4f       	sbci	r31, 0xFF	; 255
    35f8:	60 81       	ld	r22, Z
    35fa:	71 81       	ldd	r23, Z+1	; 0x01
    35fc:	82 81       	ldd	r24, Z+2	; 0x02
    35fe:	93 81       	ldd	r25, Z+3	; 0x03
    3600:	20 e0       	ldi	r18, 0x00	; 0
    3602:	3f ef       	ldi	r19, 0xFF	; 255
    3604:	4f e7       	ldi	r20, 0x7F	; 127
    3606:	57 e4       	ldi	r21, 0x47	; 71
    3608:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    360c:	18 16       	cp	r1, r24
    360e:	0c f0       	brlt	.+2      	; 0x3612 <LCD_CheckStatusSendChar4bit+0x192>
    3610:	43 c0       	rjmp	.+134    	; 0x3698 <LCD_CheckStatusSendChar4bit+0x218>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3612:	fe 01       	movw	r30, r28
    3614:	ec 5a       	subi	r30, 0xAC	; 172
    3616:	ff 4f       	sbci	r31, 0xFF	; 255
    3618:	60 81       	ld	r22, Z
    361a:	71 81       	ldd	r23, Z+1	; 0x01
    361c:	82 81       	ldd	r24, Z+2	; 0x02
    361e:	93 81       	ldd	r25, Z+3	; 0x03
    3620:	20 e0       	ldi	r18, 0x00	; 0
    3622:	30 e0       	ldi	r19, 0x00	; 0
    3624:	40 e2       	ldi	r20, 0x20	; 32
    3626:	51 e4       	ldi	r21, 0x41	; 65
    3628:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    362c:	dc 01       	movw	r26, r24
    362e:	cb 01       	movw	r24, r22
    3630:	8e 01       	movw	r16, r28
    3632:	02 5b       	subi	r16, 0xB2	; 178
    3634:	1f 4f       	sbci	r17, 0xFF	; 255
    3636:	bc 01       	movw	r22, r24
    3638:	cd 01       	movw	r24, r26
    363a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    363e:	dc 01       	movw	r26, r24
    3640:	cb 01       	movw	r24, r22
    3642:	f8 01       	movw	r30, r16
    3644:	91 83       	std	Z+1, r25	; 0x01
    3646:	80 83       	st	Z, r24
    3648:	1f c0       	rjmp	.+62     	; 0x3688 <LCD_CheckStatusSendChar4bit+0x208>
    364a:	fe 01       	movw	r30, r28
    364c:	e4 5b       	subi	r30, 0xB4	; 180
    364e:	ff 4f       	sbci	r31, 0xFF	; 255
    3650:	88 ec       	ldi	r24, 0xC8	; 200
    3652:	90 e0       	ldi	r25, 0x00	; 0
    3654:	91 83       	std	Z+1, r25	; 0x01
    3656:	80 83       	st	Z, r24
    3658:	fe 01       	movw	r30, r28
    365a:	e4 5b       	subi	r30, 0xB4	; 180
    365c:	ff 4f       	sbci	r31, 0xFF	; 255
    365e:	80 81       	ld	r24, Z
    3660:	91 81       	ldd	r25, Z+1	; 0x01
    3662:	01 97       	sbiw	r24, 0x01	; 1
    3664:	f1 f7       	brne	.-4      	; 0x3662 <LCD_CheckStatusSendChar4bit+0x1e2>
    3666:	fe 01       	movw	r30, r28
    3668:	e4 5b       	subi	r30, 0xB4	; 180
    366a:	ff 4f       	sbci	r31, 0xFF	; 255
    366c:	91 83       	std	Z+1, r25	; 0x01
    366e:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3670:	de 01       	movw	r26, r28
    3672:	a2 5b       	subi	r26, 0xB2	; 178
    3674:	bf 4f       	sbci	r27, 0xFF	; 255
    3676:	fe 01       	movw	r30, r28
    3678:	e2 5b       	subi	r30, 0xB2	; 178
    367a:	ff 4f       	sbci	r31, 0xFF	; 255
    367c:	80 81       	ld	r24, Z
    367e:	91 81       	ldd	r25, Z+1	; 0x01
    3680:	01 97       	sbiw	r24, 0x01	; 1
    3682:	11 96       	adiw	r26, 0x01	; 1
    3684:	9c 93       	st	X, r25
    3686:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3688:	fe 01       	movw	r30, r28
    368a:	e2 5b       	subi	r30, 0xB2	; 178
    368c:	ff 4f       	sbci	r31, 0xFF	; 255
    368e:	80 81       	ld	r24, Z
    3690:	91 81       	ldd	r25, Z+1	; 0x01
    3692:	00 97       	sbiw	r24, 0x00	; 0
    3694:	d1 f6       	brne	.-76     	; 0x364a <LCD_CheckStatusSendChar4bit+0x1ca>
    3696:	4b c0       	rjmp	.+150    	; 0x372e <LCD_CheckStatusSendChar4bit+0x2ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3698:	8e 01       	movw	r16, r28
    369a:	02 5b       	subi	r16, 0xB2	; 178
    369c:	1f 4f       	sbci	r17, 0xFF	; 255
    369e:	fe 01       	movw	r30, r28
    36a0:	e0 5b       	subi	r30, 0xB0	; 176
    36a2:	ff 4f       	sbci	r31, 0xFF	; 255
    36a4:	60 81       	ld	r22, Z
    36a6:	71 81       	ldd	r23, Z+1	; 0x01
    36a8:	82 81       	ldd	r24, Z+2	; 0x02
    36aa:	93 81       	ldd	r25, Z+3	; 0x03
    36ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    36b0:	dc 01       	movw	r26, r24
    36b2:	cb 01       	movw	r24, r22
    36b4:	f8 01       	movw	r30, r16
    36b6:	91 83       	std	Z+1, r25	; 0x01
    36b8:	80 83       	st	Z, r24
    36ba:	de 01       	movw	r26, r28
    36bc:	a6 5b       	subi	r26, 0xB6	; 182
    36be:	bf 4f       	sbci	r27, 0xFF	; 255
    36c0:	fe 01       	movw	r30, r28
    36c2:	e2 5b       	subi	r30, 0xB2	; 178
    36c4:	ff 4f       	sbci	r31, 0xFF	; 255
    36c6:	80 81       	ld	r24, Z
    36c8:	91 81       	ldd	r25, Z+1	; 0x01
    36ca:	11 96       	adiw	r26, 0x01	; 1
    36cc:	9c 93       	st	X, r25
    36ce:	8e 93       	st	-X, r24
    36d0:	fe 01       	movw	r30, r28
    36d2:	e6 5b       	subi	r30, 0xB6	; 182
    36d4:	ff 4f       	sbci	r31, 0xFF	; 255
    36d6:	80 81       	ld	r24, Z
    36d8:	91 81       	ldd	r25, Z+1	; 0x01
    36da:	01 97       	sbiw	r24, 0x01	; 1
    36dc:	f1 f7       	brne	.-4      	; 0x36da <LCD_CheckStatusSendChar4bit+0x25a>
    36de:	fe 01       	movw	r30, r28
    36e0:	e6 5b       	subi	r30, 0xB6	; 182
    36e2:	ff 4f       	sbci	r31, 0xFF	; 255
    36e4:	91 83       	std	Z+1, r25	; 0x01
    36e6:	80 83       	st	Z, r24
    36e8:	22 c0       	rjmp	.+68     	; 0x372e <LCD_CheckStatusSendChar4bit+0x2ae>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    36ea:	8e 01       	movw	r16, r28
    36ec:	08 5a       	subi	r16, 0xA8	; 168
    36ee:	1f 4f       	sbci	r17, 0xFF	; 255
    36f0:	fe 01       	movw	r30, r28
    36f2:	e7 5a       	subi	r30, 0xA7	; 167
    36f4:	ff 4f       	sbci	r31, 0xFF	; 255
    36f6:	60 81       	ld	r22, Z
    36f8:	71 81       	ldd	r23, Z+1	; 0x01
    36fa:	82 81       	ldd	r24, Z+2	; 0x02
    36fc:	93 81       	ldd	r25, Z+3	; 0x03
    36fe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3702:	dc 01       	movw	r26, r24
    3704:	cb 01       	movw	r24, r22
    3706:	f8 01       	movw	r30, r16
    3708:	80 83       	st	Z, r24
    370a:	de 01       	movw	r26, r28
    370c:	a7 5b       	subi	r26, 0xB7	; 183
    370e:	bf 4f       	sbci	r27, 0xFF	; 255
    3710:	fe 01       	movw	r30, r28
    3712:	e8 5a       	subi	r30, 0xA8	; 168
    3714:	ff 4f       	sbci	r31, 0xFF	; 255
    3716:	80 81       	ld	r24, Z
    3718:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    371a:	fe 01       	movw	r30, r28
    371c:	e7 5b       	subi	r30, 0xB7	; 183
    371e:	ff 4f       	sbci	r31, 0xFF	; 255
    3720:	80 81       	ld	r24, Z
    3722:	8a 95       	dec	r24
    3724:	f1 f7       	brne	.-4      	; 0x3722 <LCD_CheckStatusSendChar4bit+0x2a2>
    3726:	fe 01       	movw	r30, r28
    3728:	e7 5b       	subi	r30, 0xB7	; 183
    372a:	ff 4f       	sbci	r31, 0xFF	; 255
    372c:	80 83       	st	Z, r24
                _delay_us(1);
                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_E_PIN, DIO__UINT8_LOW);
    372e:	83 e0       	ldi	r24, 0x03	; 3
    3730:	62 e0       	ldi	r22, 0x02	; 2
    3732:	40 e0       	ldi	r20, 0x00	; 0
    3734:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>
    3738:	fe 01       	movw	r30, r28
    373a:	eb 5b       	subi	r30, 0xBB	; 187
    373c:	ff 4f       	sbci	r31, 0xFF	; 255
    373e:	80 e0       	ldi	r24, 0x00	; 0
    3740:	90 e0       	ldi	r25, 0x00	; 0
    3742:	a0 e8       	ldi	r26, 0x80	; 128
    3744:	bf e3       	ldi	r27, 0x3F	; 63
    3746:	80 83       	st	Z, r24
    3748:	91 83       	std	Z+1, r25	; 0x01
    374a:	a2 83       	std	Z+2, r26	; 0x02
    374c:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    374e:	8e 01       	movw	r16, r28
    3750:	0f 5b       	subi	r16, 0xBF	; 191
    3752:	1f 4f       	sbci	r17, 0xFF	; 255
    3754:	fe 01       	movw	r30, r28
    3756:	eb 5b       	subi	r30, 0xBB	; 187
    3758:	ff 4f       	sbci	r31, 0xFF	; 255
    375a:	60 81       	ld	r22, Z
    375c:	71 81       	ldd	r23, Z+1	; 0x01
    375e:	82 81       	ldd	r24, Z+2	; 0x02
    3760:	93 81       	ldd	r25, Z+3	; 0x03
    3762:	2b ea       	ldi	r18, 0xAB	; 171
    3764:	3a ea       	ldi	r19, 0xAA	; 170
    3766:	4a e2       	ldi	r20, 0x2A	; 42
    3768:	50 e4       	ldi	r21, 0x40	; 64
    376a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    376e:	dc 01       	movw	r26, r24
    3770:	cb 01       	movw	r24, r22
    3772:	f8 01       	movw	r30, r16
    3774:	80 83       	st	Z, r24
    3776:	91 83       	std	Z+1, r25	; 0x01
    3778:	a2 83       	std	Z+2, r26	; 0x02
    377a:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    377c:	fe 01       	movw	r30, r28
    377e:	ef 5b       	subi	r30, 0xBF	; 191
    3780:	ff 4f       	sbci	r31, 0xFF	; 255
    3782:	60 81       	ld	r22, Z
    3784:	71 81       	ldd	r23, Z+1	; 0x01
    3786:	82 81       	ldd	r24, Z+2	; 0x02
    3788:	93 81       	ldd	r25, Z+3	; 0x03
    378a:	20 e0       	ldi	r18, 0x00	; 0
    378c:	30 e0       	ldi	r19, 0x00	; 0
    378e:	40 e8       	ldi	r20, 0x80	; 128
    3790:	5f e3       	ldi	r21, 0x3F	; 63
    3792:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3796:	88 23       	and	r24, r24
    3798:	34 f4       	brge	.+12     	; 0x37a6 <LCD_CheckStatusSendChar4bit+0x326>
		__ticks = 1;
    379a:	81 e0       	ldi	r24, 0x01	; 1
    379c:	fe 01       	movw	r30, r28
    379e:	e0 5c       	subi	r30, 0xC0	; 192
    37a0:	ff 4f       	sbci	r31, 0xFF	; 255
    37a2:	80 83       	st	Z, r24
    37a4:	9d c0       	rjmp	.+314    	; 0x38e0 <LCD_CheckStatusSendChar4bit+0x460>
	else if (__tmp > 255)
    37a6:	fe 01       	movw	r30, r28
    37a8:	ef 5b       	subi	r30, 0xBF	; 191
    37aa:	ff 4f       	sbci	r31, 0xFF	; 255
    37ac:	60 81       	ld	r22, Z
    37ae:	71 81       	ldd	r23, Z+1	; 0x01
    37b0:	82 81       	ldd	r24, Z+2	; 0x02
    37b2:	93 81       	ldd	r25, Z+3	; 0x03
    37b4:	20 e0       	ldi	r18, 0x00	; 0
    37b6:	30 e0       	ldi	r19, 0x00	; 0
    37b8:	4f e7       	ldi	r20, 0x7F	; 127
    37ba:	53 e4       	ldi	r21, 0x43	; 67
    37bc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    37c0:	18 16       	cp	r1, r24
    37c2:	0c f0       	brlt	.+2      	; 0x37c6 <LCD_CheckStatusSendChar4bit+0x346>
    37c4:	7e c0       	rjmp	.+252    	; 0x38c2 <LCD_CheckStatusSendChar4bit+0x442>
	{
		_delay_ms(__us / 1000.0);
    37c6:	fe 01       	movw	r30, r28
    37c8:	eb 5b       	subi	r30, 0xBB	; 187
    37ca:	ff 4f       	sbci	r31, 0xFF	; 255
    37cc:	60 81       	ld	r22, Z
    37ce:	71 81       	ldd	r23, Z+1	; 0x01
    37d0:	82 81       	ldd	r24, Z+2	; 0x02
    37d2:	93 81       	ldd	r25, Z+3	; 0x03
    37d4:	20 e0       	ldi	r18, 0x00	; 0
    37d6:	30 e0       	ldi	r19, 0x00	; 0
    37d8:	4a e7       	ldi	r20, 0x7A	; 122
    37da:	54 e4       	ldi	r21, 0x44	; 68
    37dc:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    37e0:	dc 01       	movw	r26, r24
    37e2:	cb 01       	movw	r24, r22
    37e4:	8c af       	std	Y+60, r24	; 0x3c
    37e6:	9d af       	std	Y+61, r25	; 0x3d
    37e8:	ae af       	std	Y+62, r26	; 0x3e
    37ea:	bf af       	std	Y+63, r27	; 0x3f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    37ec:	6c ad       	ldd	r22, Y+60	; 0x3c
    37ee:	7d ad       	ldd	r23, Y+61	; 0x3d
    37f0:	8e ad       	ldd	r24, Y+62	; 0x3e
    37f2:	9f ad       	ldd	r25, Y+63	; 0x3f
    37f4:	20 e0       	ldi	r18, 0x00	; 0
    37f6:	30 e0       	ldi	r19, 0x00	; 0
    37f8:	4a ef       	ldi	r20, 0xFA	; 250
    37fa:	54 e4       	ldi	r21, 0x44	; 68
    37fc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3800:	dc 01       	movw	r26, r24
    3802:	cb 01       	movw	r24, r22
    3804:	88 af       	std	Y+56, r24	; 0x38
    3806:	99 af       	std	Y+57, r25	; 0x39
    3808:	aa af       	std	Y+58, r26	; 0x3a
    380a:	bb af       	std	Y+59, r27	; 0x3b
	if (__tmp < 1.0)
    380c:	68 ad       	ldd	r22, Y+56	; 0x38
    380e:	79 ad       	ldd	r23, Y+57	; 0x39
    3810:	8a ad       	ldd	r24, Y+58	; 0x3a
    3812:	9b ad       	ldd	r25, Y+59	; 0x3b
    3814:	20 e0       	ldi	r18, 0x00	; 0
    3816:	30 e0       	ldi	r19, 0x00	; 0
    3818:	40 e8       	ldi	r20, 0x80	; 128
    381a:	5f e3       	ldi	r21, 0x3F	; 63
    381c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3820:	88 23       	and	r24, r24
    3822:	2c f4       	brge	.+10     	; 0x382e <LCD_CheckStatusSendChar4bit+0x3ae>
		__ticks = 1;
    3824:	81 e0       	ldi	r24, 0x01	; 1
    3826:	90 e0       	ldi	r25, 0x00	; 0
    3828:	9f ab       	std	Y+55, r25	; 0x37
    382a:	8e ab       	std	Y+54, r24	; 0x36
    382c:	3f c0       	rjmp	.+126    	; 0x38ac <LCD_CheckStatusSendChar4bit+0x42c>
	else if (__tmp > 65535)
    382e:	68 ad       	ldd	r22, Y+56	; 0x38
    3830:	79 ad       	ldd	r23, Y+57	; 0x39
    3832:	8a ad       	ldd	r24, Y+58	; 0x3a
    3834:	9b ad       	ldd	r25, Y+59	; 0x3b
    3836:	20 e0       	ldi	r18, 0x00	; 0
    3838:	3f ef       	ldi	r19, 0xFF	; 255
    383a:	4f e7       	ldi	r20, 0x7F	; 127
    383c:	57 e4       	ldi	r21, 0x47	; 71
    383e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3842:	18 16       	cp	r1, r24
    3844:	4c f5       	brge	.+82     	; 0x3898 <LCD_CheckStatusSendChar4bit+0x418>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3846:	6c ad       	ldd	r22, Y+60	; 0x3c
    3848:	7d ad       	ldd	r23, Y+61	; 0x3d
    384a:	8e ad       	ldd	r24, Y+62	; 0x3e
    384c:	9f ad       	ldd	r25, Y+63	; 0x3f
    384e:	20 e0       	ldi	r18, 0x00	; 0
    3850:	30 e0       	ldi	r19, 0x00	; 0
    3852:	40 e2       	ldi	r20, 0x20	; 32
    3854:	51 e4       	ldi	r21, 0x41	; 65
    3856:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    385a:	dc 01       	movw	r26, r24
    385c:	cb 01       	movw	r24, r22
    385e:	bc 01       	movw	r22, r24
    3860:	cd 01       	movw	r24, r26
    3862:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3866:	dc 01       	movw	r26, r24
    3868:	cb 01       	movw	r24, r22
    386a:	9f ab       	std	Y+55, r25	; 0x37
    386c:	8e ab       	std	Y+54, r24	; 0x36
    386e:	0f c0       	rjmp	.+30     	; 0x388e <LCD_CheckStatusSendChar4bit+0x40e>
    3870:	88 ec       	ldi	r24, 0xC8	; 200
    3872:	90 e0       	ldi	r25, 0x00	; 0
    3874:	9d ab       	std	Y+53, r25	; 0x35
    3876:	8c ab       	std	Y+52, r24	; 0x34
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3878:	8c a9       	ldd	r24, Y+52	; 0x34
    387a:	9d a9       	ldd	r25, Y+53	; 0x35
    387c:	01 97       	sbiw	r24, 0x01	; 1
    387e:	f1 f7       	brne	.-4      	; 0x387c <LCD_CheckStatusSendChar4bit+0x3fc>
    3880:	9d ab       	std	Y+53, r25	; 0x35
    3882:	8c ab       	std	Y+52, r24	; 0x34
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3884:	8e a9       	ldd	r24, Y+54	; 0x36
    3886:	9f a9       	ldd	r25, Y+55	; 0x37
    3888:	01 97       	sbiw	r24, 0x01	; 1
    388a:	9f ab       	std	Y+55, r25	; 0x37
    388c:	8e ab       	std	Y+54, r24	; 0x36
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    388e:	8e a9       	ldd	r24, Y+54	; 0x36
    3890:	9f a9       	ldd	r25, Y+55	; 0x37
    3892:	00 97       	sbiw	r24, 0x00	; 0
    3894:	69 f7       	brne	.-38     	; 0x3870 <LCD_CheckStatusSendChar4bit+0x3f0>
    3896:	2d c0       	rjmp	.+90     	; 0x38f2 <LCD_CheckStatusSendChar4bit+0x472>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3898:	68 ad       	ldd	r22, Y+56	; 0x38
    389a:	79 ad       	ldd	r23, Y+57	; 0x39
    389c:	8a ad       	ldd	r24, Y+58	; 0x3a
    389e:	9b ad       	ldd	r25, Y+59	; 0x3b
    38a0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    38a4:	dc 01       	movw	r26, r24
    38a6:	cb 01       	movw	r24, r22
    38a8:	9f ab       	std	Y+55, r25	; 0x37
    38aa:	8e ab       	std	Y+54, r24	; 0x36
    38ac:	8e a9       	ldd	r24, Y+54	; 0x36
    38ae:	9f a9       	ldd	r25, Y+55	; 0x37
    38b0:	9b ab       	std	Y+51, r25	; 0x33
    38b2:	8a ab       	std	Y+50, r24	; 0x32
    38b4:	8a a9       	ldd	r24, Y+50	; 0x32
    38b6:	9b a9       	ldd	r25, Y+51	; 0x33
    38b8:	01 97       	sbiw	r24, 0x01	; 1
    38ba:	f1 f7       	brne	.-4      	; 0x38b8 <LCD_CheckStatusSendChar4bit+0x438>
    38bc:	9b ab       	std	Y+51, r25	; 0x33
    38be:	8a ab       	std	Y+50, r24	; 0x32
    38c0:	18 c0       	rjmp	.+48     	; 0x38f2 <LCD_CheckStatusSendChar4bit+0x472>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    38c2:	fe 01       	movw	r30, r28
    38c4:	ef 5b       	subi	r30, 0xBF	; 191
    38c6:	ff 4f       	sbci	r31, 0xFF	; 255
    38c8:	60 81       	ld	r22, Z
    38ca:	71 81       	ldd	r23, Z+1	; 0x01
    38cc:	82 81       	ldd	r24, Z+2	; 0x02
    38ce:	93 81       	ldd	r25, Z+3	; 0x03
    38d0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    38d4:	dc 01       	movw	r26, r24
    38d6:	cb 01       	movw	r24, r22
    38d8:	fe 01       	movw	r30, r28
    38da:	e0 5c       	subi	r30, 0xC0	; 192
    38dc:	ff 4f       	sbci	r31, 0xFF	; 255
    38de:	80 83       	st	Z, r24
    38e0:	fe 01       	movw	r30, r28
    38e2:	e0 5c       	subi	r30, 0xC0	; 192
    38e4:	ff 4f       	sbci	r31, 0xFF	; 255
    38e6:	80 81       	ld	r24, Z
    38e8:	89 ab       	std	Y+49, r24	; 0x31
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    38ea:	89 a9       	ldd	r24, Y+49	; 0x31
    38ec:	8a 95       	dec	r24
    38ee:	f1 f7       	brne	.-4      	; 0x38ec <LCD_CheckStatusSendChar4bit+0x46c>
    38f0:	89 ab       	std	Y+49, r24	; 0x31
                _delay_us(1);

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_RS_PIN, DIO__UINT8_HIGH);
    38f2:	83 e0       	ldi	r24, 0x03	; 3
    38f4:	60 e0       	ldi	r22, 0x00	; 0
    38f6:	41 e0       	ldi	r20, 0x01	; 1
    38f8:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_RW_PIN, DIO__UINT8_LOW);
    38fc:	83 e0       	ldi	r24, 0x03	; 3
    38fe:	61 e0       	ldi	r22, 0x01	; 1
    3900:	40 e0       	ldi	r20, 0x00	; 0
    3902:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>

                DIO__CheckStatusSetPortValue(LCD__UINT8_DATA_PORT, (Copy__Uint8Char << 4) & LCD__UINT8_DATA_PINS);
    3906:	fe 01       	movw	r30, r28
    3908:	ee 59       	subi	r30, 0x9E	; 158
    390a:	ff 4f       	sbci	r31, 0xFF	; 255
    390c:	80 81       	ld	r24, Z
    390e:	88 2f       	mov	r24, r24
    3910:	90 e0       	ldi	r25, 0x00	; 0
    3912:	82 95       	swap	r24
    3914:	92 95       	swap	r25
    3916:	90 7f       	andi	r25, 0xF0	; 240
    3918:	98 27       	eor	r25, r24
    391a:	80 7f       	andi	r24, 0xF0	; 240
    391c:	98 27       	eor	r25, r24
    391e:	98 2f       	mov	r25, r24
    3920:	82 e0       	ldi	r24, 0x02	; 2
    3922:	69 2f       	mov	r22, r25
    3924:	0e 94 4a 0b 	call	0x1694	; 0x1694 <DIO__CheckStatusSetPortValue>

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_E_PIN, DIO__UINT8_HIGH);
    3928:	83 e0       	ldi	r24, 0x03	; 3
    392a:	62 e0       	ldi	r22, 0x02	; 2
    392c:	41 e0       	ldi	r20, 0x01	; 1
    392e:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>
    3932:	80 e0       	ldi	r24, 0x00	; 0
    3934:	90 e0       	ldi	r25, 0x00	; 0
    3936:	a0 e8       	ldi	r26, 0x80	; 128
    3938:	bf e3       	ldi	r27, 0x3F	; 63
    393a:	8d a7       	std	Y+45, r24	; 0x2d
    393c:	9e a7       	std	Y+46, r25	; 0x2e
    393e:	af a7       	std	Y+47, r26	; 0x2f
    3940:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3942:	6d a5       	ldd	r22, Y+45	; 0x2d
    3944:	7e a5       	ldd	r23, Y+46	; 0x2e
    3946:	8f a5       	ldd	r24, Y+47	; 0x2f
    3948:	98 a9       	ldd	r25, Y+48	; 0x30
    394a:	2b ea       	ldi	r18, 0xAB	; 171
    394c:	3a ea       	ldi	r19, 0xAA	; 170
    394e:	4a e2       	ldi	r20, 0x2A	; 42
    3950:	50 e4       	ldi	r21, 0x40	; 64
    3952:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3956:	dc 01       	movw	r26, r24
    3958:	cb 01       	movw	r24, r22
    395a:	89 a7       	std	Y+41, r24	; 0x29
    395c:	9a a7       	std	Y+42, r25	; 0x2a
    395e:	ab a7       	std	Y+43, r26	; 0x2b
    3960:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    3962:	69 a5       	ldd	r22, Y+41	; 0x29
    3964:	7a a5       	ldd	r23, Y+42	; 0x2a
    3966:	8b a5       	ldd	r24, Y+43	; 0x2b
    3968:	9c a5       	ldd	r25, Y+44	; 0x2c
    396a:	20 e0       	ldi	r18, 0x00	; 0
    396c:	30 e0       	ldi	r19, 0x00	; 0
    396e:	40 e8       	ldi	r20, 0x80	; 128
    3970:	5f e3       	ldi	r21, 0x3F	; 63
    3972:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3976:	88 23       	and	r24, r24
    3978:	1c f4       	brge	.+6      	; 0x3980 <LCD_CheckStatusSendChar4bit+0x500>
		__ticks = 1;
    397a:	81 e0       	ldi	r24, 0x01	; 1
    397c:	88 a7       	std	Y+40, r24	; 0x28
    397e:	91 c0       	rjmp	.+290    	; 0x3aa2 <LCD_CheckStatusSendChar4bit+0x622>
	else if (__tmp > 255)
    3980:	69 a5       	ldd	r22, Y+41	; 0x29
    3982:	7a a5       	ldd	r23, Y+42	; 0x2a
    3984:	8b a5       	ldd	r24, Y+43	; 0x2b
    3986:	9c a5       	ldd	r25, Y+44	; 0x2c
    3988:	20 e0       	ldi	r18, 0x00	; 0
    398a:	30 e0       	ldi	r19, 0x00	; 0
    398c:	4f e7       	ldi	r20, 0x7F	; 127
    398e:	53 e4       	ldi	r21, 0x43	; 67
    3990:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3994:	18 16       	cp	r1, r24
    3996:	0c f0       	brlt	.+2      	; 0x399a <LCD_CheckStatusSendChar4bit+0x51a>
    3998:	7b c0       	rjmp	.+246    	; 0x3a90 <LCD_CheckStatusSendChar4bit+0x610>
	{
		_delay_ms(__us / 1000.0);
    399a:	6d a5       	ldd	r22, Y+45	; 0x2d
    399c:	7e a5       	ldd	r23, Y+46	; 0x2e
    399e:	8f a5       	ldd	r24, Y+47	; 0x2f
    39a0:	98 a9       	ldd	r25, Y+48	; 0x30
    39a2:	20 e0       	ldi	r18, 0x00	; 0
    39a4:	30 e0       	ldi	r19, 0x00	; 0
    39a6:	4a e7       	ldi	r20, 0x7A	; 122
    39a8:	54 e4       	ldi	r21, 0x44	; 68
    39aa:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    39ae:	dc 01       	movw	r26, r24
    39b0:	cb 01       	movw	r24, r22
    39b2:	8c a3       	std	Y+36, r24	; 0x24
    39b4:	9d a3       	std	Y+37, r25	; 0x25
    39b6:	ae a3       	std	Y+38, r26	; 0x26
    39b8:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    39ba:	6c a1       	ldd	r22, Y+36	; 0x24
    39bc:	7d a1       	ldd	r23, Y+37	; 0x25
    39be:	8e a1       	ldd	r24, Y+38	; 0x26
    39c0:	9f a1       	ldd	r25, Y+39	; 0x27
    39c2:	20 e0       	ldi	r18, 0x00	; 0
    39c4:	30 e0       	ldi	r19, 0x00	; 0
    39c6:	4a ef       	ldi	r20, 0xFA	; 250
    39c8:	54 e4       	ldi	r21, 0x44	; 68
    39ca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    39ce:	dc 01       	movw	r26, r24
    39d0:	cb 01       	movw	r24, r22
    39d2:	88 a3       	std	Y+32, r24	; 0x20
    39d4:	99 a3       	std	Y+33, r25	; 0x21
    39d6:	aa a3       	std	Y+34, r26	; 0x22
    39d8:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    39da:	68 a1       	ldd	r22, Y+32	; 0x20
    39dc:	79 a1       	ldd	r23, Y+33	; 0x21
    39de:	8a a1       	ldd	r24, Y+34	; 0x22
    39e0:	9b a1       	ldd	r25, Y+35	; 0x23
    39e2:	20 e0       	ldi	r18, 0x00	; 0
    39e4:	30 e0       	ldi	r19, 0x00	; 0
    39e6:	40 e8       	ldi	r20, 0x80	; 128
    39e8:	5f e3       	ldi	r21, 0x3F	; 63
    39ea:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    39ee:	88 23       	and	r24, r24
    39f0:	2c f4       	brge	.+10     	; 0x39fc <LCD_CheckStatusSendChar4bit+0x57c>
		__ticks = 1;
    39f2:	81 e0       	ldi	r24, 0x01	; 1
    39f4:	90 e0       	ldi	r25, 0x00	; 0
    39f6:	9f 8f       	std	Y+31, r25	; 0x1f
    39f8:	8e 8f       	std	Y+30, r24	; 0x1e
    39fa:	3f c0       	rjmp	.+126    	; 0x3a7a <LCD_CheckStatusSendChar4bit+0x5fa>
	else if (__tmp > 65535)
    39fc:	68 a1       	ldd	r22, Y+32	; 0x20
    39fe:	79 a1       	ldd	r23, Y+33	; 0x21
    3a00:	8a a1       	ldd	r24, Y+34	; 0x22
    3a02:	9b a1       	ldd	r25, Y+35	; 0x23
    3a04:	20 e0       	ldi	r18, 0x00	; 0
    3a06:	3f ef       	ldi	r19, 0xFF	; 255
    3a08:	4f e7       	ldi	r20, 0x7F	; 127
    3a0a:	57 e4       	ldi	r21, 0x47	; 71
    3a0c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3a10:	18 16       	cp	r1, r24
    3a12:	4c f5       	brge	.+82     	; 0x3a66 <LCD_CheckStatusSendChar4bit+0x5e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3a14:	6c a1       	ldd	r22, Y+36	; 0x24
    3a16:	7d a1       	ldd	r23, Y+37	; 0x25
    3a18:	8e a1       	ldd	r24, Y+38	; 0x26
    3a1a:	9f a1       	ldd	r25, Y+39	; 0x27
    3a1c:	20 e0       	ldi	r18, 0x00	; 0
    3a1e:	30 e0       	ldi	r19, 0x00	; 0
    3a20:	40 e2       	ldi	r20, 0x20	; 32
    3a22:	51 e4       	ldi	r21, 0x41	; 65
    3a24:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3a28:	dc 01       	movw	r26, r24
    3a2a:	cb 01       	movw	r24, r22
    3a2c:	bc 01       	movw	r22, r24
    3a2e:	cd 01       	movw	r24, r26
    3a30:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3a34:	dc 01       	movw	r26, r24
    3a36:	cb 01       	movw	r24, r22
    3a38:	9f 8f       	std	Y+31, r25	; 0x1f
    3a3a:	8e 8f       	std	Y+30, r24	; 0x1e
    3a3c:	0f c0       	rjmp	.+30     	; 0x3a5c <LCD_CheckStatusSendChar4bit+0x5dc>
    3a3e:	88 ec       	ldi	r24, 0xC8	; 200
    3a40:	90 e0       	ldi	r25, 0x00	; 0
    3a42:	9d 8f       	std	Y+29, r25	; 0x1d
    3a44:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3a46:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3a48:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3a4a:	01 97       	sbiw	r24, 0x01	; 1
    3a4c:	f1 f7       	brne	.-4      	; 0x3a4a <LCD_CheckStatusSendChar4bit+0x5ca>
    3a4e:	9d 8f       	std	Y+29, r25	; 0x1d
    3a50:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3a52:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3a54:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3a56:	01 97       	sbiw	r24, 0x01	; 1
    3a58:	9f 8f       	std	Y+31, r25	; 0x1f
    3a5a:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3a5c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3a5e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3a60:	00 97       	sbiw	r24, 0x00	; 0
    3a62:	69 f7       	brne	.-38     	; 0x3a3e <LCD_CheckStatusSendChar4bit+0x5be>
    3a64:	24 c0       	rjmp	.+72     	; 0x3aae <LCD_CheckStatusSendChar4bit+0x62e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3a66:	68 a1       	ldd	r22, Y+32	; 0x20
    3a68:	79 a1       	ldd	r23, Y+33	; 0x21
    3a6a:	8a a1       	ldd	r24, Y+34	; 0x22
    3a6c:	9b a1       	ldd	r25, Y+35	; 0x23
    3a6e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3a72:	dc 01       	movw	r26, r24
    3a74:	cb 01       	movw	r24, r22
    3a76:	9f 8f       	std	Y+31, r25	; 0x1f
    3a78:	8e 8f       	std	Y+30, r24	; 0x1e
    3a7a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3a7c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3a7e:	9b 8f       	std	Y+27, r25	; 0x1b
    3a80:	8a 8f       	std	Y+26, r24	; 0x1a
    3a82:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3a84:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a86:	01 97       	sbiw	r24, 0x01	; 1
    3a88:	f1 f7       	brne	.-4      	; 0x3a86 <LCD_CheckStatusSendChar4bit+0x606>
    3a8a:	9b 8f       	std	Y+27, r25	; 0x1b
    3a8c:	8a 8f       	std	Y+26, r24	; 0x1a
    3a8e:	0f c0       	rjmp	.+30     	; 0x3aae <LCD_CheckStatusSendChar4bit+0x62e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3a90:	69 a5       	ldd	r22, Y+41	; 0x29
    3a92:	7a a5       	ldd	r23, Y+42	; 0x2a
    3a94:	8b a5       	ldd	r24, Y+43	; 0x2b
    3a96:	9c a5       	ldd	r25, Y+44	; 0x2c
    3a98:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3a9c:	dc 01       	movw	r26, r24
    3a9e:	cb 01       	movw	r24, r22
    3aa0:	88 a7       	std	Y+40, r24	; 0x28
    3aa2:	88 a5       	ldd	r24, Y+40	; 0x28
    3aa4:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3aa6:	89 8d       	ldd	r24, Y+25	; 0x19
    3aa8:	8a 95       	dec	r24
    3aaa:	f1 f7       	brne	.-4      	; 0x3aa8 <LCD_CheckStatusSendChar4bit+0x628>
    3aac:	89 8f       	std	Y+25, r24	; 0x19
                _delay_us(1);
                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_E_PIN, DIO__UINT8_LOW);
    3aae:	83 e0       	ldi	r24, 0x03	; 3
    3ab0:	62 e0       	ldi	r22, 0x02	; 2
    3ab2:	40 e0       	ldi	r20, 0x00	; 0
    3ab4:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>
    3ab8:	80 e0       	ldi	r24, 0x00	; 0
    3aba:	90 e0       	ldi	r25, 0x00	; 0
    3abc:	a0 e8       	ldi	r26, 0x80	; 128
    3abe:	bf e3       	ldi	r27, 0x3F	; 63
    3ac0:	8d 8b       	std	Y+21, r24	; 0x15
    3ac2:	9e 8b       	std	Y+22, r25	; 0x16
    3ac4:	af 8b       	std	Y+23, r26	; 0x17
    3ac6:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3ac8:	6d 89       	ldd	r22, Y+21	; 0x15
    3aca:	7e 89       	ldd	r23, Y+22	; 0x16
    3acc:	8f 89       	ldd	r24, Y+23	; 0x17
    3ace:	98 8d       	ldd	r25, Y+24	; 0x18
    3ad0:	2b ea       	ldi	r18, 0xAB	; 171
    3ad2:	3a ea       	ldi	r19, 0xAA	; 170
    3ad4:	4a e2       	ldi	r20, 0x2A	; 42
    3ad6:	50 e4       	ldi	r21, 0x40	; 64
    3ad8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3adc:	dc 01       	movw	r26, r24
    3ade:	cb 01       	movw	r24, r22
    3ae0:	89 8b       	std	Y+17, r24	; 0x11
    3ae2:	9a 8b       	std	Y+18, r25	; 0x12
    3ae4:	ab 8b       	std	Y+19, r26	; 0x13
    3ae6:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    3ae8:	69 89       	ldd	r22, Y+17	; 0x11
    3aea:	7a 89       	ldd	r23, Y+18	; 0x12
    3aec:	8b 89       	ldd	r24, Y+19	; 0x13
    3aee:	9c 89       	ldd	r25, Y+20	; 0x14
    3af0:	20 e0       	ldi	r18, 0x00	; 0
    3af2:	30 e0       	ldi	r19, 0x00	; 0
    3af4:	40 e8       	ldi	r20, 0x80	; 128
    3af6:	5f e3       	ldi	r21, 0x3F	; 63
    3af8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3afc:	88 23       	and	r24, r24
    3afe:	1c f4       	brge	.+6      	; 0x3b06 <LCD_CheckStatusSendChar4bit+0x686>
		__ticks = 1;
    3b00:	81 e0       	ldi	r24, 0x01	; 1
    3b02:	88 8b       	std	Y+16, r24	; 0x10
    3b04:	91 c0       	rjmp	.+290    	; 0x3c28 <LCD_CheckStatusSendChar4bit+0x7a8>
	else if (__tmp > 255)
    3b06:	69 89       	ldd	r22, Y+17	; 0x11
    3b08:	7a 89       	ldd	r23, Y+18	; 0x12
    3b0a:	8b 89       	ldd	r24, Y+19	; 0x13
    3b0c:	9c 89       	ldd	r25, Y+20	; 0x14
    3b0e:	20 e0       	ldi	r18, 0x00	; 0
    3b10:	30 e0       	ldi	r19, 0x00	; 0
    3b12:	4f e7       	ldi	r20, 0x7F	; 127
    3b14:	53 e4       	ldi	r21, 0x43	; 67
    3b16:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3b1a:	18 16       	cp	r1, r24
    3b1c:	0c f0       	brlt	.+2      	; 0x3b20 <LCD_CheckStatusSendChar4bit+0x6a0>
    3b1e:	7b c0       	rjmp	.+246    	; 0x3c16 <LCD_CheckStatusSendChar4bit+0x796>
	{
		_delay_ms(__us / 1000.0);
    3b20:	6d 89       	ldd	r22, Y+21	; 0x15
    3b22:	7e 89       	ldd	r23, Y+22	; 0x16
    3b24:	8f 89       	ldd	r24, Y+23	; 0x17
    3b26:	98 8d       	ldd	r25, Y+24	; 0x18
    3b28:	20 e0       	ldi	r18, 0x00	; 0
    3b2a:	30 e0       	ldi	r19, 0x00	; 0
    3b2c:	4a e7       	ldi	r20, 0x7A	; 122
    3b2e:	54 e4       	ldi	r21, 0x44	; 68
    3b30:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3b34:	dc 01       	movw	r26, r24
    3b36:	cb 01       	movw	r24, r22
    3b38:	8c 87       	std	Y+12, r24	; 0x0c
    3b3a:	9d 87       	std	Y+13, r25	; 0x0d
    3b3c:	ae 87       	std	Y+14, r26	; 0x0e
    3b3e:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3b40:	6c 85       	ldd	r22, Y+12	; 0x0c
    3b42:	7d 85       	ldd	r23, Y+13	; 0x0d
    3b44:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b46:	9f 85       	ldd	r25, Y+15	; 0x0f
    3b48:	20 e0       	ldi	r18, 0x00	; 0
    3b4a:	30 e0       	ldi	r19, 0x00	; 0
    3b4c:	4a ef       	ldi	r20, 0xFA	; 250
    3b4e:	54 e4       	ldi	r21, 0x44	; 68
    3b50:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3b54:	dc 01       	movw	r26, r24
    3b56:	cb 01       	movw	r24, r22
    3b58:	88 87       	std	Y+8, r24	; 0x08
    3b5a:	99 87       	std	Y+9, r25	; 0x09
    3b5c:	aa 87       	std	Y+10, r26	; 0x0a
    3b5e:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    3b60:	68 85       	ldd	r22, Y+8	; 0x08
    3b62:	79 85       	ldd	r23, Y+9	; 0x09
    3b64:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b66:	9b 85       	ldd	r25, Y+11	; 0x0b
    3b68:	20 e0       	ldi	r18, 0x00	; 0
    3b6a:	30 e0       	ldi	r19, 0x00	; 0
    3b6c:	40 e8       	ldi	r20, 0x80	; 128
    3b6e:	5f e3       	ldi	r21, 0x3F	; 63
    3b70:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3b74:	88 23       	and	r24, r24
    3b76:	2c f4       	brge	.+10     	; 0x3b82 <LCD_CheckStatusSendChar4bit+0x702>
		__ticks = 1;
    3b78:	81 e0       	ldi	r24, 0x01	; 1
    3b7a:	90 e0       	ldi	r25, 0x00	; 0
    3b7c:	9f 83       	std	Y+7, r25	; 0x07
    3b7e:	8e 83       	std	Y+6, r24	; 0x06
    3b80:	3f c0       	rjmp	.+126    	; 0x3c00 <LCD_CheckStatusSendChar4bit+0x780>
	else if (__tmp > 65535)
    3b82:	68 85       	ldd	r22, Y+8	; 0x08
    3b84:	79 85       	ldd	r23, Y+9	; 0x09
    3b86:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b88:	9b 85       	ldd	r25, Y+11	; 0x0b
    3b8a:	20 e0       	ldi	r18, 0x00	; 0
    3b8c:	3f ef       	ldi	r19, 0xFF	; 255
    3b8e:	4f e7       	ldi	r20, 0x7F	; 127
    3b90:	57 e4       	ldi	r21, 0x47	; 71
    3b92:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3b96:	18 16       	cp	r1, r24
    3b98:	4c f5       	brge	.+82     	; 0x3bec <LCD_CheckStatusSendChar4bit+0x76c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3b9a:	6c 85       	ldd	r22, Y+12	; 0x0c
    3b9c:	7d 85       	ldd	r23, Y+13	; 0x0d
    3b9e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3ba0:	9f 85       	ldd	r25, Y+15	; 0x0f
    3ba2:	20 e0       	ldi	r18, 0x00	; 0
    3ba4:	30 e0       	ldi	r19, 0x00	; 0
    3ba6:	40 e2       	ldi	r20, 0x20	; 32
    3ba8:	51 e4       	ldi	r21, 0x41	; 65
    3baa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3bae:	dc 01       	movw	r26, r24
    3bb0:	cb 01       	movw	r24, r22
    3bb2:	bc 01       	movw	r22, r24
    3bb4:	cd 01       	movw	r24, r26
    3bb6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bba:	dc 01       	movw	r26, r24
    3bbc:	cb 01       	movw	r24, r22
    3bbe:	9f 83       	std	Y+7, r25	; 0x07
    3bc0:	8e 83       	std	Y+6, r24	; 0x06
    3bc2:	0f c0       	rjmp	.+30     	; 0x3be2 <LCD_CheckStatusSendChar4bit+0x762>
    3bc4:	88 ec       	ldi	r24, 0xC8	; 200
    3bc6:	90 e0       	ldi	r25, 0x00	; 0
    3bc8:	9d 83       	std	Y+5, r25	; 0x05
    3bca:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3bcc:	8c 81       	ldd	r24, Y+4	; 0x04
    3bce:	9d 81       	ldd	r25, Y+5	; 0x05
    3bd0:	01 97       	sbiw	r24, 0x01	; 1
    3bd2:	f1 f7       	brne	.-4      	; 0x3bd0 <LCD_CheckStatusSendChar4bit+0x750>
    3bd4:	9d 83       	std	Y+5, r25	; 0x05
    3bd6:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3bd8:	8e 81       	ldd	r24, Y+6	; 0x06
    3bda:	9f 81       	ldd	r25, Y+7	; 0x07
    3bdc:	01 97       	sbiw	r24, 0x01	; 1
    3bde:	9f 83       	std	Y+7, r25	; 0x07
    3be0:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3be2:	8e 81       	ldd	r24, Y+6	; 0x06
    3be4:	9f 81       	ldd	r25, Y+7	; 0x07
    3be6:	00 97       	sbiw	r24, 0x00	; 0
    3be8:	69 f7       	brne	.-38     	; 0x3bc4 <LCD_CheckStatusSendChar4bit+0x744>
    3bea:	24 c0       	rjmp	.+72     	; 0x3c34 <LCD_CheckStatusSendChar4bit+0x7b4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3bec:	68 85       	ldd	r22, Y+8	; 0x08
    3bee:	79 85       	ldd	r23, Y+9	; 0x09
    3bf0:	8a 85       	ldd	r24, Y+10	; 0x0a
    3bf2:	9b 85       	ldd	r25, Y+11	; 0x0b
    3bf4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bf8:	dc 01       	movw	r26, r24
    3bfa:	cb 01       	movw	r24, r22
    3bfc:	9f 83       	std	Y+7, r25	; 0x07
    3bfe:	8e 83       	std	Y+6, r24	; 0x06
    3c00:	8e 81       	ldd	r24, Y+6	; 0x06
    3c02:	9f 81       	ldd	r25, Y+7	; 0x07
    3c04:	9b 83       	std	Y+3, r25	; 0x03
    3c06:	8a 83       	std	Y+2, r24	; 0x02
    3c08:	8a 81       	ldd	r24, Y+2	; 0x02
    3c0a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c0c:	01 97       	sbiw	r24, 0x01	; 1
    3c0e:	f1 f7       	brne	.-4      	; 0x3c0c <LCD_CheckStatusSendChar4bit+0x78c>
    3c10:	9b 83       	std	Y+3, r25	; 0x03
    3c12:	8a 83       	std	Y+2, r24	; 0x02
    3c14:	0f c0       	rjmp	.+30     	; 0x3c34 <LCD_CheckStatusSendChar4bit+0x7b4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3c16:	69 89       	ldd	r22, Y+17	; 0x11
    3c18:	7a 89       	ldd	r23, Y+18	; 0x12
    3c1a:	8b 89       	ldd	r24, Y+19	; 0x13
    3c1c:	9c 89       	ldd	r25, Y+20	; 0x14
    3c1e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3c22:	dc 01       	movw	r26, r24
    3c24:	cb 01       	movw	r24, r22
    3c26:	88 8b       	std	Y+16, r24	; 0x10
    3c28:	88 89       	ldd	r24, Y+16	; 0x10
    3c2a:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3c2c:	89 81       	ldd	r24, Y+1	; 0x01
    3c2e:	8a 95       	dec	r24
    3c30:	f1 f7       	brne	.-4      	; 0x3c2e <LCD_CheckStatusSendChar4bit+0x7ae>
    3c32:	89 83       	std	Y+1, r24	; 0x01
        }
        else
        {
                Local_CheckStausReturnValue = CHECK_FAIL;
        }
        return Local_CheckStausReturnValue;
    3c34:	fe 01       	movw	r30, r28
    3c36:	ef 59       	subi	r30, 0x9F	; 159
    3c38:	ff 4f       	sbci	r31, 0xFF	; 255
    3c3a:	80 81       	ld	r24, Z
}
    3c3c:	ce 59       	subi	r28, 0x9E	; 158
    3c3e:	df 4f       	sbci	r29, 0xFF	; 255
    3c40:	0f b6       	in	r0, 0x3f	; 63
    3c42:	f8 94       	cli
    3c44:	de bf       	out	0x3e, r29	; 62
    3c46:	0f be       	out	0x3f, r0	; 63
    3c48:	cd bf       	out	0x3d, r28	; 61
    3c4a:	cf 91       	pop	r28
    3c4c:	df 91       	pop	r29
    3c4e:	1f 91       	pop	r17
    3c50:	0f 91       	pop	r16
    3c52:	08 95       	ret

00003c54 <LCD_CheckStatusSendCmnd4bit>:
CheckStatus LCD_CheckStatusSendCmnd4bit(_uint8 Copy__Uint8Cmnd)
{
    3c54:	0f 93       	push	r16
    3c56:	1f 93       	push	r17
    3c58:	df 93       	push	r29
    3c5a:	cf 93       	push	r28
    3c5c:	cd b7       	in	r28, 0x3d	; 61
    3c5e:	de b7       	in	r29, 0x3e	; 62
    3c60:	c2 56       	subi	r28, 0x62	; 98
    3c62:	d0 40       	sbci	r29, 0x00	; 0
    3c64:	0f b6       	in	r0, 0x3f	; 63
    3c66:	f8 94       	cli
    3c68:	de bf       	out	0x3e, r29	; 62
    3c6a:	0f be       	out	0x3f, r0	; 63
    3c6c:	cd bf       	out	0x3d, r28	; 61
    3c6e:	fe 01       	movw	r30, r28
    3c70:	ee 59       	subi	r30, 0x9E	; 158
    3c72:	ff 4f       	sbci	r31, 0xFF	; 255
    3c74:	80 83       	st	Z, r24
        CheckStatus Local_CheckStausReturnValue = CHECK_SUCCESS;
    3c76:	fe 01       	movw	r30, r28
    3c78:	ef 59       	subi	r30, 0x9F	; 159
    3c7a:	ff 4f       	sbci	r31, 0xFF	; 255
    3c7c:	10 82       	st	Z, r1
         3-Send CMND byte  to the Data Pins of LCD
         4-PULSE of Enable E = 1 ,E = 0
        */
        if (Copy__Uint8Cmnd <= 255)
        {
                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_RS_PIN, DIO__UINT8_LOW);
    3c7e:	83 e0       	ldi	r24, 0x03	; 3
    3c80:	60 e0       	ldi	r22, 0x00	; 0
    3c82:	40 e0       	ldi	r20, 0x00	; 0
    3c84:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_RW_PIN, DIO__UINT8_LOW);
    3c88:	83 e0       	ldi	r24, 0x03	; 3
    3c8a:	61 e0       	ldi	r22, 0x01	; 1
    3c8c:	40 e0       	ldi	r20, 0x00	; 0
    3c8e:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>

                DIO__CheckStatusSetPortValue(LCD__UINT8_DATA_PORT,( Copy__Uint8Cmnd & LCD__UINT8_DATA_PINS));
    3c92:	fe 01       	movw	r30, r28
    3c94:	ee 59       	subi	r30, 0x9E	; 158
    3c96:	ff 4f       	sbci	r31, 0xFF	; 255
    3c98:	80 81       	ld	r24, Z
    3c9a:	98 2f       	mov	r25, r24
    3c9c:	90 7f       	andi	r25, 0xF0	; 240
    3c9e:	82 e0       	ldi	r24, 0x02	; 2
    3ca0:	69 2f       	mov	r22, r25
    3ca2:	0e 94 4a 0b 	call	0x1694	; 0x1694 <DIO__CheckStatusSetPortValue>

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_E_PIN, DIO__UINT8_HIGH);
    3ca6:	83 e0       	ldi	r24, 0x03	; 3
    3ca8:	62 e0       	ldi	r22, 0x02	; 2
    3caa:	41 e0       	ldi	r20, 0x01	; 1
    3cac:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>
    3cb0:	fe 01       	movw	r30, r28
    3cb2:	e3 5a       	subi	r30, 0xA3	; 163
    3cb4:	ff 4f       	sbci	r31, 0xFF	; 255
    3cb6:	80 e0       	ldi	r24, 0x00	; 0
    3cb8:	90 e0       	ldi	r25, 0x00	; 0
    3cba:	a0 e8       	ldi	r26, 0x80	; 128
    3cbc:	bf e3       	ldi	r27, 0x3F	; 63
    3cbe:	80 83       	st	Z, r24
    3cc0:	91 83       	std	Z+1, r25	; 0x01
    3cc2:	a2 83       	std	Z+2, r26	; 0x02
    3cc4:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3cc6:	8e 01       	movw	r16, r28
    3cc8:	07 5a       	subi	r16, 0xA7	; 167
    3cca:	1f 4f       	sbci	r17, 0xFF	; 255
    3ccc:	fe 01       	movw	r30, r28
    3cce:	e3 5a       	subi	r30, 0xA3	; 163
    3cd0:	ff 4f       	sbci	r31, 0xFF	; 255
    3cd2:	60 81       	ld	r22, Z
    3cd4:	71 81       	ldd	r23, Z+1	; 0x01
    3cd6:	82 81       	ldd	r24, Z+2	; 0x02
    3cd8:	93 81       	ldd	r25, Z+3	; 0x03
    3cda:	2b ea       	ldi	r18, 0xAB	; 171
    3cdc:	3a ea       	ldi	r19, 0xAA	; 170
    3cde:	4a e2       	ldi	r20, 0x2A	; 42
    3ce0:	50 e4       	ldi	r21, 0x40	; 64
    3ce2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3ce6:	dc 01       	movw	r26, r24
    3ce8:	cb 01       	movw	r24, r22
    3cea:	f8 01       	movw	r30, r16
    3cec:	80 83       	st	Z, r24
    3cee:	91 83       	std	Z+1, r25	; 0x01
    3cf0:	a2 83       	std	Z+2, r26	; 0x02
    3cf2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3cf4:	fe 01       	movw	r30, r28
    3cf6:	e7 5a       	subi	r30, 0xA7	; 167
    3cf8:	ff 4f       	sbci	r31, 0xFF	; 255
    3cfa:	60 81       	ld	r22, Z
    3cfc:	71 81       	ldd	r23, Z+1	; 0x01
    3cfe:	82 81       	ldd	r24, Z+2	; 0x02
    3d00:	93 81       	ldd	r25, Z+3	; 0x03
    3d02:	20 e0       	ldi	r18, 0x00	; 0
    3d04:	30 e0       	ldi	r19, 0x00	; 0
    3d06:	40 e8       	ldi	r20, 0x80	; 128
    3d08:	5f e3       	ldi	r21, 0x3F	; 63
    3d0a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3d0e:	88 23       	and	r24, r24
    3d10:	34 f4       	brge	.+12     	; 0x3d1e <LCD_CheckStatusSendCmnd4bit+0xca>
		__ticks = 1;
    3d12:	fe 01       	movw	r30, r28
    3d14:	e8 5a       	subi	r30, 0xA8	; 168
    3d16:	ff 4f       	sbci	r31, 0xFF	; 255
    3d18:	81 e0       	ldi	r24, 0x01	; 1
    3d1a:	80 83       	st	Z, r24
    3d1c:	e0 c0       	rjmp	.+448    	; 0x3ede <LCD_CheckStatusSendCmnd4bit+0x28a>
	else if (__tmp > 255)
    3d1e:	fe 01       	movw	r30, r28
    3d20:	e7 5a       	subi	r30, 0xA7	; 167
    3d22:	ff 4f       	sbci	r31, 0xFF	; 255
    3d24:	60 81       	ld	r22, Z
    3d26:	71 81       	ldd	r23, Z+1	; 0x01
    3d28:	82 81       	ldd	r24, Z+2	; 0x02
    3d2a:	93 81       	ldd	r25, Z+3	; 0x03
    3d2c:	20 e0       	ldi	r18, 0x00	; 0
    3d2e:	30 e0       	ldi	r19, 0x00	; 0
    3d30:	4f e7       	ldi	r20, 0x7F	; 127
    3d32:	53 e4       	ldi	r21, 0x43	; 67
    3d34:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3d38:	18 16       	cp	r1, r24
    3d3a:	0c f0       	brlt	.+2      	; 0x3d3e <LCD_CheckStatusSendCmnd4bit+0xea>
    3d3c:	c0 c0       	rjmp	.+384    	; 0x3ebe <LCD_CheckStatusSendCmnd4bit+0x26a>
	{
		_delay_ms(__us / 1000.0);
    3d3e:	fe 01       	movw	r30, r28
    3d40:	e3 5a       	subi	r30, 0xA3	; 163
    3d42:	ff 4f       	sbci	r31, 0xFF	; 255
    3d44:	60 81       	ld	r22, Z
    3d46:	71 81       	ldd	r23, Z+1	; 0x01
    3d48:	82 81       	ldd	r24, Z+2	; 0x02
    3d4a:	93 81       	ldd	r25, Z+3	; 0x03
    3d4c:	20 e0       	ldi	r18, 0x00	; 0
    3d4e:	30 e0       	ldi	r19, 0x00	; 0
    3d50:	4a e7       	ldi	r20, 0x7A	; 122
    3d52:	54 e4       	ldi	r21, 0x44	; 68
    3d54:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3d58:	dc 01       	movw	r26, r24
    3d5a:	cb 01       	movw	r24, r22
    3d5c:	fe 01       	movw	r30, r28
    3d5e:	ec 5a       	subi	r30, 0xAC	; 172
    3d60:	ff 4f       	sbci	r31, 0xFF	; 255
    3d62:	80 83       	st	Z, r24
    3d64:	91 83       	std	Z+1, r25	; 0x01
    3d66:	a2 83       	std	Z+2, r26	; 0x02
    3d68:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3d6a:	8e 01       	movw	r16, r28
    3d6c:	00 5b       	subi	r16, 0xB0	; 176
    3d6e:	1f 4f       	sbci	r17, 0xFF	; 255
    3d70:	fe 01       	movw	r30, r28
    3d72:	ec 5a       	subi	r30, 0xAC	; 172
    3d74:	ff 4f       	sbci	r31, 0xFF	; 255
    3d76:	60 81       	ld	r22, Z
    3d78:	71 81       	ldd	r23, Z+1	; 0x01
    3d7a:	82 81       	ldd	r24, Z+2	; 0x02
    3d7c:	93 81       	ldd	r25, Z+3	; 0x03
    3d7e:	20 e0       	ldi	r18, 0x00	; 0
    3d80:	30 e0       	ldi	r19, 0x00	; 0
    3d82:	4a ef       	ldi	r20, 0xFA	; 250
    3d84:	54 e4       	ldi	r21, 0x44	; 68
    3d86:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3d8a:	dc 01       	movw	r26, r24
    3d8c:	cb 01       	movw	r24, r22
    3d8e:	f8 01       	movw	r30, r16
    3d90:	80 83       	st	Z, r24
    3d92:	91 83       	std	Z+1, r25	; 0x01
    3d94:	a2 83       	std	Z+2, r26	; 0x02
    3d96:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3d98:	fe 01       	movw	r30, r28
    3d9a:	e0 5b       	subi	r30, 0xB0	; 176
    3d9c:	ff 4f       	sbci	r31, 0xFF	; 255
    3d9e:	60 81       	ld	r22, Z
    3da0:	71 81       	ldd	r23, Z+1	; 0x01
    3da2:	82 81       	ldd	r24, Z+2	; 0x02
    3da4:	93 81       	ldd	r25, Z+3	; 0x03
    3da6:	20 e0       	ldi	r18, 0x00	; 0
    3da8:	30 e0       	ldi	r19, 0x00	; 0
    3daa:	40 e8       	ldi	r20, 0x80	; 128
    3dac:	5f e3       	ldi	r21, 0x3F	; 63
    3dae:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3db2:	88 23       	and	r24, r24
    3db4:	44 f4       	brge	.+16     	; 0x3dc6 <LCD_CheckStatusSendCmnd4bit+0x172>
		__ticks = 1;
    3db6:	fe 01       	movw	r30, r28
    3db8:	e2 5b       	subi	r30, 0xB2	; 178
    3dba:	ff 4f       	sbci	r31, 0xFF	; 255
    3dbc:	81 e0       	ldi	r24, 0x01	; 1
    3dbe:	90 e0       	ldi	r25, 0x00	; 0
    3dc0:	91 83       	std	Z+1, r25	; 0x01
    3dc2:	80 83       	st	Z, r24
    3dc4:	64 c0       	rjmp	.+200    	; 0x3e8e <LCD_CheckStatusSendCmnd4bit+0x23a>
	else if (__tmp > 65535)
    3dc6:	fe 01       	movw	r30, r28
    3dc8:	e0 5b       	subi	r30, 0xB0	; 176
    3dca:	ff 4f       	sbci	r31, 0xFF	; 255
    3dcc:	60 81       	ld	r22, Z
    3dce:	71 81       	ldd	r23, Z+1	; 0x01
    3dd0:	82 81       	ldd	r24, Z+2	; 0x02
    3dd2:	93 81       	ldd	r25, Z+3	; 0x03
    3dd4:	20 e0       	ldi	r18, 0x00	; 0
    3dd6:	3f ef       	ldi	r19, 0xFF	; 255
    3dd8:	4f e7       	ldi	r20, 0x7F	; 127
    3dda:	57 e4       	ldi	r21, 0x47	; 71
    3ddc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3de0:	18 16       	cp	r1, r24
    3de2:	0c f0       	brlt	.+2      	; 0x3de6 <LCD_CheckStatusSendCmnd4bit+0x192>
    3de4:	43 c0       	rjmp	.+134    	; 0x3e6c <LCD_CheckStatusSendCmnd4bit+0x218>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3de6:	fe 01       	movw	r30, r28
    3de8:	ec 5a       	subi	r30, 0xAC	; 172
    3dea:	ff 4f       	sbci	r31, 0xFF	; 255
    3dec:	60 81       	ld	r22, Z
    3dee:	71 81       	ldd	r23, Z+1	; 0x01
    3df0:	82 81       	ldd	r24, Z+2	; 0x02
    3df2:	93 81       	ldd	r25, Z+3	; 0x03
    3df4:	20 e0       	ldi	r18, 0x00	; 0
    3df6:	30 e0       	ldi	r19, 0x00	; 0
    3df8:	40 e2       	ldi	r20, 0x20	; 32
    3dfa:	51 e4       	ldi	r21, 0x41	; 65
    3dfc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3e00:	dc 01       	movw	r26, r24
    3e02:	cb 01       	movw	r24, r22
    3e04:	8e 01       	movw	r16, r28
    3e06:	02 5b       	subi	r16, 0xB2	; 178
    3e08:	1f 4f       	sbci	r17, 0xFF	; 255
    3e0a:	bc 01       	movw	r22, r24
    3e0c:	cd 01       	movw	r24, r26
    3e0e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3e12:	dc 01       	movw	r26, r24
    3e14:	cb 01       	movw	r24, r22
    3e16:	f8 01       	movw	r30, r16
    3e18:	91 83       	std	Z+1, r25	; 0x01
    3e1a:	80 83       	st	Z, r24
    3e1c:	1f c0       	rjmp	.+62     	; 0x3e5c <LCD_CheckStatusSendCmnd4bit+0x208>
    3e1e:	fe 01       	movw	r30, r28
    3e20:	e4 5b       	subi	r30, 0xB4	; 180
    3e22:	ff 4f       	sbci	r31, 0xFF	; 255
    3e24:	88 ec       	ldi	r24, 0xC8	; 200
    3e26:	90 e0       	ldi	r25, 0x00	; 0
    3e28:	91 83       	std	Z+1, r25	; 0x01
    3e2a:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3e2c:	fe 01       	movw	r30, r28
    3e2e:	e4 5b       	subi	r30, 0xB4	; 180
    3e30:	ff 4f       	sbci	r31, 0xFF	; 255
    3e32:	80 81       	ld	r24, Z
    3e34:	91 81       	ldd	r25, Z+1	; 0x01
    3e36:	01 97       	sbiw	r24, 0x01	; 1
    3e38:	f1 f7       	brne	.-4      	; 0x3e36 <LCD_CheckStatusSendCmnd4bit+0x1e2>
    3e3a:	fe 01       	movw	r30, r28
    3e3c:	e4 5b       	subi	r30, 0xB4	; 180
    3e3e:	ff 4f       	sbci	r31, 0xFF	; 255
    3e40:	91 83       	std	Z+1, r25	; 0x01
    3e42:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3e44:	de 01       	movw	r26, r28
    3e46:	a2 5b       	subi	r26, 0xB2	; 178
    3e48:	bf 4f       	sbci	r27, 0xFF	; 255
    3e4a:	fe 01       	movw	r30, r28
    3e4c:	e2 5b       	subi	r30, 0xB2	; 178
    3e4e:	ff 4f       	sbci	r31, 0xFF	; 255
    3e50:	80 81       	ld	r24, Z
    3e52:	91 81       	ldd	r25, Z+1	; 0x01
    3e54:	01 97       	sbiw	r24, 0x01	; 1
    3e56:	11 96       	adiw	r26, 0x01	; 1
    3e58:	9c 93       	st	X, r25
    3e5a:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3e5c:	fe 01       	movw	r30, r28
    3e5e:	e2 5b       	subi	r30, 0xB2	; 178
    3e60:	ff 4f       	sbci	r31, 0xFF	; 255
    3e62:	80 81       	ld	r24, Z
    3e64:	91 81       	ldd	r25, Z+1	; 0x01
    3e66:	00 97       	sbiw	r24, 0x00	; 0
    3e68:	d1 f6       	brne	.-76     	; 0x3e1e <LCD_CheckStatusSendCmnd4bit+0x1ca>
    3e6a:	4b c0       	rjmp	.+150    	; 0x3f02 <LCD_CheckStatusSendCmnd4bit+0x2ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3e6c:	8e 01       	movw	r16, r28
    3e6e:	02 5b       	subi	r16, 0xB2	; 178
    3e70:	1f 4f       	sbci	r17, 0xFF	; 255
    3e72:	fe 01       	movw	r30, r28
    3e74:	e0 5b       	subi	r30, 0xB0	; 176
    3e76:	ff 4f       	sbci	r31, 0xFF	; 255
    3e78:	60 81       	ld	r22, Z
    3e7a:	71 81       	ldd	r23, Z+1	; 0x01
    3e7c:	82 81       	ldd	r24, Z+2	; 0x02
    3e7e:	93 81       	ldd	r25, Z+3	; 0x03
    3e80:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3e84:	dc 01       	movw	r26, r24
    3e86:	cb 01       	movw	r24, r22
    3e88:	f8 01       	movw	r30, r16
    3e8a:	91 83       	std	Z+1, r25	; 0x01
    3e8c:	80 83       	st	Z, r24
    3e8e:	de 01       	movw	r26, r28
    3e90:	a6 5b       	subi	r26, 0xB6	; 182
    3e92:	bf 4f       	sbci	r27, 0xFF	; 255
    3e94:	fe 01       	movw	r30, r28
    3e96:	e2 5b       	subi	r30, 0xB2	; 178
    3e98:	ff 4f       	sbci	r31, 0xFF	; 255
    3e9a:	80 81       	ld	r24, Z
    3e9c:	91 81       	ldd	r25, Z+1	; 0x01
    3e9e:	11 96       	adiw	r26, 0x01	; 1
    3ea0:	9c 93       	st	X, r25
    3ea2:	8e 93       	st	-X, r24
    3ea4:	fe 01       	movw	r30, r28
    3ea6:	e6 5b       	subi	r30, 0xB6	; 182
    3ea8:	ff 4f       	sbci	r31, 0xFF	; 255
    3eaa:	80 81       	ld	r24, Z
    3eac:	91 81       	ldd	r25, Z+1	; 0x01
    3eae:	01 97       	sbiw	r24, 0x01	; 1
    3eb0:	f1 f7       	brne	.-4      	; 0x3eae <LCD_CheckStatusSendCmnd4bit+0x25a>
    3eb2:	fe 01       	movw	r30, r28
    3eb4:	e6 5b       	subi	r30, 0xB6	; 182
    3eb6:	ff 4f       	sbci	r31, 0xFF	; 255
    3eb8:	91 83       	std	Z+1, r25	; 0x01
    3eba:	80 83       	st	Z, r24
    3ebc:	22 c0       	rjmp	.+68     	; 0x3f02 <LCD_CheckStatusSendCmnd4bit+0x2ae>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3ebe:	8e 01       	movw	r16, r28
    3ec0:	08 5a       	subi	r16, 0xA8	; 168
    3ec2:	1f 4f       	sbci	r17, 0xFF	; 255
    3ec4:	fe 01       	movw	r30, r28
    3ec6:	e7 5a       	subi	r30, 0xA7	; 167
    3ec8:	ff 4f       	sbci	r31, 0xFF	; 255
    3eca:	60 81       	ld	r22, Z
    3ecc:	71 81       	ldd	r23, Z+1	; 0x01
    3ece:	82 81       	ldd	r24, Z+2	; 0x02
    3ed0:	93 81       	ldd	r25, Z+3	; 0x03
    3ed2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3ed6:	dc 01       	movw	r26, r24
    3ed8:	cb 01       	movw	r24, r22
    3eda:	f8 01       	movw	r30, r16
    3edc:	80 83       	st	Z, r24
    3ede:	de 01       	movw	r26, r28
    3ee0:	a7 5b       	subi	r26, 0xB7	; 183
    3ee2:	bf 4f       	sbci	r27, 0xFF	; 255
    3ee4:	fe 01       	movw	r30, r28
    3ee6:	e8 5a       	subi	r30, 0xA8	; 168
    3ee8:	ff 4f       	sbci	r31, 0xFF	; 255
    3eea:	80 81       	ld	r24, Z
    3eec:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3eee:	fe 01       	movw	r30, r28
    3ef0:	e7 5b       	subi	r30, 0xB7	; 183
    3ef2:	ff 4f       	sbci	r31, 0xFF	; 255
    3ef4:	80 81       	ld	r24, Z
    3ef6:	8a 95       	dec	r24
    3ef8:	f1 f7       	brne	.-4      	; 0x3ef6 <LCD_CheckStatusSendCmnd4bit+0x2a2>
    3efa:	fe 01       	movw	r30, r28
    3efc:	e7 5b       	subi	r30, 0xB7	; 183
    3efe:	ff 4f       	sbci	r31, 0xFF	; 255
    3f00:	80 83       	st	Z, r24
                _delay_us(1);
                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_E_PIN, DIO__UINT8_LOW);
    3f02:	83 e0       	ldi	r24, 0x03	; 3
    3f04:	62 e0       	ldi	r22, 0x02	; 2
    3f06:	40 e0       	ldi	r20, 0x00	; 0
    3f08:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>
    3f0c:	fe 01       	movw	r30, r28
    3f0e:	eb 5b       	subi	r30, 0xBB	; 187
    3f10:	ff 4f       	sbci	r31, 0xFF	; 255
    3f12:	80 e0       	ldi	r24, 0x00	; 0
    3f14:	90 e0       	ldi	r25, 0x00	; 0
    3f16:	a0 e8       	ldi	r26, 0x80	; 128
    3f18:	bf e3       	ldi	r27, 0x3F	; 63
    3f1a:	80 83       	st	Z, r24
    3f1c:	91 83       	std	Z+1, r25	; 0x01
    3f1e:	a2 83       	std	Z+2, r26	; 0x02
    3f20:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3f22:	8e 01       	movw	r16, r28
    3f24:	0f 5b       	subi	r16, 0xBF	; 191
    3f26:	1f 4f       	sbci	r17, 0xFF	; 255
    3f28:	fe 01       	movw	r30, r28
    3f2a:	eb 5b       	subi	r30, 0xBB	; 187
    3f2c:	ff 4f       	sbci	r31, 0xFF	; 255
    3f2e:	60 81       	ld	r22, Z
    3f30:	71 81       	ldd	r23, Z+1	; 0x01
    3f32:	82 81       	ldd	r24, Z+2	; 0x02
    3f34:	93 81       	ldd	r25, Z+3	; 0x03
    3f36:	2b ea       	ldi	r18, 0xAB	; 171
    3f38:	3a ea       	ldi	r19, 0xAA	; 170
    3f3a:	4a e2       	ldi	r20, 0x2A	; 42
    3f3c:	50 e4       	ldi	r21, 0x40	; 64
    3f3e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3f42:	dc 01       	movw	r26, r24
    3f44:	cb 01       	movw	r24, r22
    3f46:	f8 01       	movw	r30, r16
    3f48:	80 83       	st	Z, r24
    3f4a:	91 83       	std	Z+1, r25	; 0x01
    3f4c:	a2 83       	std	Z+2, r26	; 0x02
    3f4e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3f50:	fe 01       	movw	r30, r28
    3f52:	ef 5b       	subi	r30, 0xBF	; 191
    3f54:	ff 4f       	sbci	r31, 0xFF	; 255
    3f56:	60 81       	ld	r22, Z
    3f58:	71 81       	ldd	r23, Z+1	; 0x01
    3f5a:	82 81       	ldd	r24, Z+2	; 0x02
    3f5c:	93 81       	ldd	r25, Z+3	; 0x03
    3f5e:	20 e0       	ldi	r18, 0x00	; 0
    3f60:	30 e0       	ldi	r19, 0x00	; 0
    3f62:	40 e8       	ldi	r20, 0x80	; 128
    3f64:	5f e3       	ldi	r21, 0x3F	; 63
    3f66:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3f6a:	88 23       	and	r24, r24
    3f6c:	34 f4       	brge	.+12     	; 0x3f7a <LCD_CheckStatusSendCmnd4bit+0x326>
		__ticks = 1;
    3f6e:	81 e0       	ldi	r24, 0x01	; 1
    3f70:	fe 01       	movw	r30, r28
    3f72:	e0 5c       	subi	r30, 0xC0	; 192
    3f74:	ff 4f       	sbci	r31, 0xFF	; 255
    3f76:	80 83       	st	Z, r24
    3f78:	9d c0       	rjmp	.+314    	; 0x40b4 <LCD_CheckStatusSendCmnd4bit+0x460>
	else if (__tmp > 255)
    3f7a:	fe 01       	movw	r30, r28
    3f7c:	ef 5b       	subi	r30, 0xBF	; 191
    3f7e:	ff 4f       	sbci	r31, 0xFF	; 255
    3f80:	60 81       	ld	r22, Z
    3f82:	71 81       	ldd	r23, Z+1	; 0x01
    3f84:	82 81       	ldd	r24, Z+2	; 0x02
    3f86:	93 81       	ldd	r25, Z+3	; 0x03
    3f88:	20 e0       	ldi	r18, 0x00	; 0
    3f8a:	30 e0       	ldi	r19, 0x00	; 0
    3f8c:	4f e7       	ldi	r20, 0x7F	; 127
    3f8e:	53 e4       	ldi	r21, 0x43	; 67
    3f90:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3f94:	18 16       	cp	r1, r24
    3f96:	0c f0       	brlt	.+2      	; 0x3f9a <LCD_CheckStatusSendCmnd4bit+0x346>
    3f98:	7e c0       	rjmp	.+252    	; 0x4096 <LCD_CheckStatusSendCmnd4bit+0x442>
	{
		_delay_ms(__us / 1000.0);
    3f9a:	fe 01       	movw	r30, r28
    3f9c:	eb 5b       	subi	r30, 0xBB	; 187
    3f9e:	ff 4f       	sbci	r31, 0xFF	; 255
    3fa0:	60 81       	ld	r22, Z
    3fa2:	71 81       	ldd	r23, Z+1	; 0x01
    3fa4:	82 81       	ldd	r24, Z+2	; 0x02
    3fa6:	93 81       	ldd	r25, Z+3	; 0x03
    3fa8:	20 e0       	ldi	r18, 0x00	; 0
    3faa:	30 e0       	ldi	r19, 0x00	; 0
    3fac:	4a e7       	ldi	r20, 0x7A	; 122
    3fae:	54 e4       	ldi	r21, 0x44	; 68
    3fb0:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3fb4:	dc 01       	movw	r26, r24
    3fb6:	cb 01       	movw	r24, r22
    3fb8:	8c af       	std	Y+60, r24	; 0x3c
    3fba:	9d af       	std	Y+61, r25	; 0x3d
    3fbc:	ae af       	std	Y+62, r26	; 0x3e
    3fbe:	bf af       	std	Y+63, r27	; 0x3f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3fc0:	6c ad       	ldd	r22, Y+60	; 0x3c
    3fc2:	7d ad       	ldd	r23, Y+61	; 0x3d
    3fc4:	8e ad       	ldd	r24, Y+62	; 0x3e
    3fc6:	9f ad       	ldd	r25, Y+63	; 0x3f
    3fc8:	20 e0       	ldi	r18, 0x00	; 0
    3fca:	30 e0       	ldi	r19, 0x00	; 0
    3fcc:	4a ef       	ldi	r20, 0xFA	; 250
    3fce:	54 e4       	ldi	r21, 0x44	; 68
    3fd0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3fd4:	dc 01       	movw	r26, r24
    3fd6:	cb 01       	movw	r24, r22
    3fd8:	88 af       	std	Y+56, r24	; 0x38
    3fda:	99 af       	std	Y+57, r25	; 0x39
    3fdc:	aa af       	std	Y+58, r26	; 0x3a
    3fde:	bb af       	std	Y+59, r27	; 0x3b
	if (__tmp < 1.0)
    3fe0:	68 ad       	ldd	r22, Y+56	; 0x38
    3fe2:	79 ad       	ldd	r23, Y+57	; 0x39
    3fe4:	8a ad       	ldd	r24, Y+58	; 0x3a
    3fe6:	9b ad       	ldd	r25, Y+59	; 0x3b
    3fe8:	20 e0       	ldi	r18, 0x00	; 0
    3fea:	30 e0       	ldi	r19, 0x00	; 0
    3fec:	40 e8       	ldi	r20, 0x80	; 128
    3fee:	5f e3       	ldi	r21, 0x3F	; 63
    3ff0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3ff4:	88 23       	and	r24, r24
    3ff6:	2c f4       	brge	.+10     	; 0x4002 <LCD_CheckStatusSendCmnd4bit+0x3ae>
		__ticks = 1;
    3ff8:	81 e0       	ldi	r24, 0x01	; 1
    3ffa:	90 e0       	ldi	r25, 0x00	; 0
    3ffc:	9f ab       	std	Y+55, r25	; 0x37
    3ffe:	8e ab       	std	Y+54, r24	; 0x36
    4000:	3f c0       	rjmp	.+126    	; 0x4080 <LCD_CheckStatusSendCmnd4bit+0x42c>
	else if (__tmp > 65535)
    4002:	68 ad       	ldd	r22, Y+56	; 0x38
    4004:	79 ad       	ldd	r23, Y+57	; 0x39
    4006:	8a ad       	ldd	r24, Y+58	; 0x3a
    4008:	9b ad       	ldd	r25, Y+59	; 0x3b
    400a:	20 e0       	ldi	r18, 0x00	; 0
    400c:	3f ef       	ldi	r19, 0xFF	; 255
    400e:	4f e7       	ldi	r20, 0x7F	; 127
    4010:	57 e4       	ldi	r21, 0x47	; 71
    4012:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4016:	18 16       	cp	r1, r24
    4018:	4c f5       	brge	.+82     	; 0x406c <LCD_CheckStatusSendCmnd4bit+0x418>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    401a:	6c ad       	ldd	r22, Y+60	; 0x3c
    401c:	7d ad       	ldd	r23, Y+61	; 0x3d
    401e:	8e ad       	ldd	r24, Y+62	; 0x3e
    4020:	9f ad       	ldd	r25, Y+63	; 0x3f
    4022:	20 e0       	ldi	r18, 0x00	; 0
    4024:	30 e0       	ldi	r19, 0x00	; 0
    4026:	40 e2       	ldi	r20, 0x20	; 32
    4028:	51 e4       	ldi	r21, 0x41	; 65
    402a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    402e:	dc 01       	movw	r26, r24
    4030:	cb 01       	movw	r24, r22
    4032:	bc 01       	movw	r22, r24
    4034:	cd 01       	movw	r24, r26
    4036:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    403a:	dc 01       	movw	r26, r24
    403c:	cb 01       	movw	r24, r22
    403e:	9f ab       	std	Y+55, r25	; 0x37
    4040:	8e ab       	std	Y+54, r24	; 0x36
    4042:	0f c0       	rjmp	.+30     	; 0x4062 <LCD_CheckStatusSendCmnd4bit+0x40e>
    4044:	88 ec       	ldi	r24, 0xC8	; 200
    4046:	90 e0       	ldi	r25, 0x00	; 0
    4048:	9d ab       	std	Y+53, r25	; 0x35
    404a:	8c ab       	std	Y+52, r24	; 0x34
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    404c:	8c a9       	ldd	r24, Y+52	; 0x34
    404e:	9d a9       	ldd	r25, Y+53	; 0x35
    4050:	01 97       	sbiw	r24, 0x01	; 1
    4052:	f1 f7       	brne	.-4      	; 0x4050 <LCD_CheckStatusSendCmnd4bit+0x3fc>
    4054:	9d ab       	std	Y+53, r25	; 0x35
    4056:	8c ab       	std	Y+52, r24	; 0x34
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4058:	8e a9       	ldd	r24, Y+54	; 0x36
    405a:	9f a9       	ldd	r25, Y+55	; 0x37
    405c:	01 97       	sbiw	r24, 0x01	; 1
    405e:	9f ab       	std	Y+55, r25	; 0x37
    4060:	8e ab       	std	Y+54, r24	; 0x36
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4062:	8e a9       	ldd	r24, Y+54	; 0x36
    4064:	9f a9       	ldd	r25, Y+55	; 0x37
    4066:	00 97       	sbiw	r24, 0x00	; 0
    4068:	69 f7       	brne	.-38     	; 0x4044 <LCD_CheckStatusSendCmnd4bit+0x3f0>
    406a:	2d c0       	rjmp	.+90     	; 0x40c6 <LCD_CheckStatusSendCmnd4bit+0x472>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    406c:	68 ad       	ldd	r22, Y+56	; 0x38
    406e:	79 ad       	ldd	r23, Y+57	; 0x39
    4070:	8a ad       	ldd	r24, Y+58	; 0x3a
    4072:	9b ad       	ldd	r25, Y+59	; 0x3b
    4074:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4078:	dc 01       	movw	r26, r24
    407a:	cb 01       	movw	r24, r22
    407c:	9f ab       	std	Y+55, r25	; 0x37
    407e:	8e ab       	std	Y+54, r24	; 0x36
    4080:	8e a9       	ldd	r24, Y+54	; 0x36
    4082:	9f a9       	ldd	r25, Y+55	; 0x37
    4084:	9b ab       	std	Y+51, r25	; 0x33
    4086:	8a ab       	std	Y+50, r24	; 0x32
    4088:	8a a9       	ldd	r24, Y+50	; 0x32
    408a:	9b a9       	ldd	r25, Y+51	; 0x33
    408c:	01 97       	sbiw	r24, 0x01	; 1
    408e:	f1 f7       	brne	.-4      	; 0x408c <LCD_CheckStatusSendCmnd4bit+0x438>
    4090:	9b ab       	std	Y+51, r25	; 0x33
    4092:	8a ab       	std	Y+50, r24	; 0x32
    4094:	18 c0       	rjmp	.+48     	; 0x40c6 <LCD_CheckStatusSendCmnd4bit+0x472>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4096:	fe 01       	movw	r30, r28
    4098:	ef 5b       	subi	r30, 0xBF	; 191
    409a:	ff 4f       	sbci	r31, 0xFF	; 255
    409c:	60 81       	ld	r22, Z
    409e:	71 81       	ldd	r23, Z+1	; 0x01
    40a0:	82 81       	ldd	r24, Z+2	; 0x02
    40a2:	93 81       	ldd	r25, Z+3	; 0x03
    40a4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    40a8:	dc 01       	movw	r26, r24
    40aa:	cb 01       	movw	r24, r22
    40ac:	fe 01       	movw	r30, r28
    40ae:	e0 5c       	subi	r30, 0xC0	; 192
    40b0:	ff 4f       	sbci	r31, 0xFF	; 255
    40b2:	80 83       	st	Z, r24
    40b4:	fe 01       	movw	r30, r28
    40b6:	e0 5c       	subi	r30, 0xC0	; 192
    40b8:	ff 4f       	sbci	r31, 0xFF	; 255
    40ba:	80 81       	ld	r24, Z
    40bc:	89 ab       	std	Y+49, r24	; 0x31
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    40be:	89 a9       	ldd	r24, Y+49	; 0x31
    40c0:	8a 95       	dec	r24
    40c2:	f1 f7       	brne	.-4      	; 0x40c0 <LCD_CheckStatusSendCmnd4bit+0x46c>
    40c4:	89 ab       	std	Y+49, r24	; 0x31
                _delay_us(1);
                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_RS_PIN, DIO__UINT8_LOW);
    40c6:	83 e0       	ldi	r24, 0x03	; 3
    40c8:	60 e0       	ldi	r22, 0x00	; 0
    40ca:	40 e0       	ldi	r20, 0x00	; 0
    40cc:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_RW_PIN, DIO__UINT8_LOW);
    40d0:	83 e0       	ldi	r24, 0x03	; 3
    40d2:	61 e0       	ldi	r22, 0x01	; 1
    40d4:	40 e0       	ldi	r20, 0x00	; 0
    40d6:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>

                DIO__CheckStatusSetPortValue(LCD__UINT8_DATA_PORT, ((Copy__Uint8Cmnd << 4) & LCD__UINT8_DATA_PINS));
    40da:	fe 01       	movw	r30, r28
    40dc:	ee 59       	subi	r30, 0x9E	; 158
    40de:	ff 4f       	sbci	r31, 0xFF	; 255
    40e0:	80 81       	ld	r24, Z
    40e2:	88 2f       	mov	r24, r24
    40e4:	90 e0       	ldi	r25, 0x00	; 0
    40e6:	82 95       	swap	r24
    40e8:	92 95       	swap	r25
    40ea:	90 7f       	andi	r25, 0xF0	; 240
    40ec:	98 27       	eor	r25, r24
    40ee:	80 7f       	andi	r24, 0xF0	; 240
    40f0:	98 27       	eor	r25, r24
    40f2:	98 2f       	mov	r25, r24
    40f4:	82 e0       	ldi	r24, 0x02	; 2
    40f6:	69 2f       	mov	r22, r25
    40f8:	0e 94 4a 0b 	call	0x1694	; 0x1694 <DIO__CheckStatusSetPortValue>

                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_E_PIN, DIO__UINT8_HIGH);
    40fc:	83 e0       	ldi	r24, 0x03	; 3
    40fe:	62 e0       	ldi	r22, 0x02	; 2
    4100:	41 e0       	ldi	r20, 0x01	; 1
    4102:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>
    4106:	80 e0       	ldi	r24, 0x00	; 0
    4108:	90 e0       	ldi	r25, 0x00	; 0
    410a:	a0 e8       	ldi	r26, 0x80	; 128
    410c:	bf e3       	ldi	r27, 0x3F	; 63
    410e:	8d a7       	std	Y+45, r24	; 0x2d
    4110:	9e a7       	std	Y+46, r25	; 0x2e
    4112:	af a7       	std	Y+47, r26	; 0x2f
    4114:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    4116:	6d a5       	ldd	r22, Y+45	; 0x2d
    4118:	7e a5       	ldd	r23, Y+46	; 0x2e
    411a:	8f a5       	ldd	r24, Y+47	; 0x2f
    411c:	98 a9       	ldd	r25, Y+48	; 0x30
    411e:	2b ea       	ldi	r18, 0xAB	; 171
    4120:	3a ea       	ldi	r19, 0xAA	; 170
    4122:	4a e2       	ldi	r20, 0x2A	; 42
    4124:	50 e4       	ldi	r21, 0x40	; 64
    4126:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    412a:	dc 01       	movw	r26, r24
    412c:	cb 01       	movw	r24, r22
    412e:	89 a7       	std	Y+41, r24	; 0x29
    4130:	9a a7       	std	Y+42, r25	; 0x2a
    4132:	ab a7       	std	Y+43, r26	; 0x2b
    4134:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    4136:	69 a5       	ldd	r22, Y+41	; 0x29
    4138:	7a a5       	ldd	r23, Y+42	; 0x2a
    413a:	8b a5       	ldd	r24, Y+43	; 0x2b
    413c:	9c a5       	ldd	r25, Y+44	; 0x2c
    413e:	20 e0       	ldi	r18, 0x00	; 0
    4140:	30 e0       	ldi	r19, 0x00	; 0
    4142:	40 e8       	ldi	r20, 0x80	; 128
    4144:	5f e3       	ldi	r21, 0x3F	; 63
    4146:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    414a:	88 23       	and	r24, r24
    414c:	1c f4       	brge	.+6      	; 0x4154 <LCD_CheckStatusSendCmnd4bit+0x500>
		__ticks = 1;
    414e:	81 e0       	ldi	r24, 0x01	; 1
    4150:	88 a7       	std	Y+40, r24	; 0x28
    4152:	91 c0       	rjmp	.+290    	; 0x4276 <LCD_CheckStatusSendCmnd4bit+0x622>
	else if (__tmp > 255)
    4154:	69 a5       	ldd	r22, Y+41	; 0x29
    4156:	7a a5       	ldd	r23, Y+42	; 0x2a
    4158:	8b a5       	ldd	r24, Y+43	; 0x2b
    415a:	9c a5       	ldd	r25, Y+44	; 0x2c
    415c:	20 e0       	ldi	r18, 0x00	; 0
    415e:	30 e0       	ldi	r19, 0x00	; 0
    4160:	4f e7       	ldi	r20, 0x7F	; 127
    4162:	53 e4       	ldi	r21, 0x43	; 67
    4164:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4168:	18 16       	cp	r1, r24
    416a:	0c f0       	brlt	.+2      	; 0x416e <LCD_CheckStatusSendCmnd4bit+0x51a>
    416c:	7b c0       	rjmp	.+246    	; 0x4264 <LCD_CheckStatusSendCmnd4bit+0x610>
	{
		_delay_ms(__us / 1000.0);
    416e:	6d a5       	ldd	r22, Y+45	; 0x2d
    4170:	7e a5       	ldd	r23, Y+46	; 0x2e
    4172:	8f a5       	ldd	r24, Y+47	; 0x2f
    4174:	98 a9       	ldd	r25, Y+48	; 0x30
    4176:	20 e0       	ldi	r18, 0x00	; 0
    4178:	30 e0       	ldi	r19, 0x00	; 0
    417a:	4a e7       	ldi	r20, 0x7A	; 122
    417c:	54 e4       	ldi	r21, 0x44	; 68
    417e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    4182:	dc 01       	movw	r26, r24
    4184:	cb 01       	movw	r24, r22
    4186:	8c a3       	std	Y+36, r24	; 0x24
    4188:	9d a3       	std	Y+37, r25	; 0x25
    418a:	ae a3       	std	Y+38, r26	; 0x26
    418c:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    418e:	6c a1       	ldd	r22, Y+36	; 0x24
    4190:	7d a1       	ldd	r23, Y+37	; 0x25
    4192:	8e a1       	ldd	r24, Y+38	; 0x26
    4194:	9f a1       	ldd	r25, Y+39	; 0x27
    4196:	20 e0       	ldi	r18, 0x00	; 0
    4198:	30 e0       	ldi	r19, 0x00	; 0
    419a:	4a ef       	ldi	r20, 0xFA	; 250
    419c:	54 e4       	ldi	r21, 0x44	; 68
    419e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    41a2:	dc 01       	movw	r26, r24
    41a4:	cb 01       	movw	r24, r22
    41a6:	88 a3       	std	Y+32, r24	; 0x20
    41a8:	99 a3       	std	Y+33, r25	; 0x21
    41aa:	aa a3       	std	Y+34, r26	; 0x22
    41ac:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    41ae:	68 a1       	ldd	r22, Y+32	; 0x20
    41b0:	79 a1       	ldd	r23, Y+33	; 0x21
    41b2:	8a a1       	ldd	r24, Y+34	; 0x22
    41b4:	9b a1       	ldd	r25, Y+35	; 0x23
    41b6:	20 e0       	ldi	r18, 0x00	; 0
    41b8:	30 e0       	ldi	r19, 0x00	; 0
    41ba:	40 e8       	ldi	r20, 0x80	; 128
    41bc:	5f e3       	ldi	r21, 0x3F	; 63
    41be:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    41c2:	88 23       	and	r24, r24
    41c4:	2c f4       	brge	.+10     	; 0x41d0 <LCD_CheckStatusSendCmnd4bit+0x57c>
		__ticks = 1;
    41c6:	81 e0       	ldi	r24, 0x01	; 1
    41c8:	90 e0       	ldi	r25, 0x00	; 0
    41ca:	9f 8f       	std	Y+31, r25	; 0x1f
    41cc:	8e 8f       	std	Y+30, r24	; 0x1e
    41ce:	3f c0       	rjmp	.+126    	; 0x424e <LCD_CheckStatusSendCmnd4bit+0x5fa>
	else if (__tmp > 65535)
    41d0:	68 a1       	ldd	r22, Y+32	; 0x20
    41d2:	79 a1       	ldd	r23, Y+33	; 0x21
    41d4:	8a a1       	ldd	r24, Y+34	; 0x22
    41d6:	9b a1       	ldd	r25, Y+35	; 0x23
    41d8:	20 e0       	ldi	r18, 0x00	; 0
    41da:	3f ef       	ldi	r19, 0xFF	; 255
    41dc:	4f e7       	ldi	r20, 0x7F	; 127
    41de:	57 e4       	ldi	r21, 0x47	; 71
    41e0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    41e4:	18 16       	cp	r1, r24
    41e6:	4c f5       	brge	.+82     	; 0x423a <LCD_CheckStatusSendCmnd4bit+0x5e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    41e8:	6c a1       	ldd	r22, Y+36	; 0x24
    41ea:	7d a1       	ldd	r23, Y+37	; 0x25
    41ec:	8e a1       	ldd	r24, Y+38	; 0x26
    41ee:	9f a1       	ldd	r25, Y+39	; 0x27
    41f0:	20 e0       	ldi	r18, 0x00	; 0
    41f2:	30 e0       	ldi	r19, 0x00	; 0
    41f4:	40 e2       	ldi	r20, 0x20	; 32
    41f6:	51 e4       	ldi	r21, 0x41	; 65
    41f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    41fc:	dc 01       	movw	r26, r24
    41fe:	cb 01       	movw	r24, r22
    4200:	bc 01       	movw	r22, r24
    4202:	cd 01       	movw	r24, r26
    4204:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4208:	dc 01       	movw	r26, r24
    420a:	cb 01       	movw	r24, r22
    420c:	9f 8f       	std	Y+31, r25	; 0x1f
    420e:	8e 8f       	std	Y+30, r24	; 0x1e
    4210:	0f c0       	rjmp	.+30     	; 0x4230 <LCD_CheckStatusSendCmnd4bit+0x5dc>
    4212:	88 ec       	ldi	r24, 0xC8	; 200
    4214:	90 e0       	ldi	r25, 0x00	; 0
    4216:	9d 8f       	std	Y+29, r25	; 0x1d
    4218:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    421a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    421c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    421e:	01 97       	sbiw	r24, 0x01	; 1
    4220:	f1 f7       	brne	.-4      	; 0x421e <LCD_CheckStatusSendCmnd4bit+0x5ca>
    4222:	9d 8f       	std	Y+29, r25	; 0x1d
    4224:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4226:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4228:	9f 8d       	ldd	r25, Y+31	; 0x1f
    422a:	01 97       	sbiw	r24, 0x01	; 1
    422c:	9f 8f       	std	Y+31, r25	; 0x1f
    422e:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4230:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4232:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4234:	00 97       	sbiw	r24, 0x00	; 0
    4236:	69 f7       	brne	.-38     	; 0x4212 <LCD_CheckStatusSendCmnd4bit+0x5be>
    4238:	24 c0       	rjmp	.+72     	; 0x4282 <LCD_CheckStatusSendCmnd4bit+0x62e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    423a:	68 a1       	ldd	r22, Y+32	; 0x20
    423c:	79 a1       	ldd	r23, Y+33	; 0x21
    423e:	8a a1       	ldd	r24, Y+34	; 0x22
    4240:	9b a1       	ldd	r25, Y+35	; 0x23
    4242:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4246:	dc 01       	movw	r26, r24
    4248:	cb 01       	movw	r24, r22
    424a:	9f 8f       	std	Y+31, r25	; 0x1f
    424c:	8e 8f       	std	Y+30, r24	; 0x1e
    424e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4250:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4252:	9b 8f       	std	Y+27, r25	; 0x1b
    4254:	8a 8f       	std	Y+26, r24	; 0x1a
    4256:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4258:	9b 8d       	ldd	r25, Y+27	; 0x1b
    425a:	01 97       	sbiw	r24, 0x01	; 1
    425c:	f1 f7       	brne	.-4      	; 0x425a <LCD_CheckStatusSendCmnd4bit+0x606>
    425e:	9b 8f       	std	Y+27, r25	; 0x1b
    4260:	8a 8f       	std	Y+26, r24	; 0x1a
    4262:	0f c0       	rjmp	.+30     	; 0x4282 <LCD_CheckStatusSendCmnd4bit+0x62e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4264:	69 a5       	ldd	r22, Y+41	; 0x29
    4266:	7a a5       	ldd	r23, Y+42	; 0x2a
    4268:	8b a5       	ldd	r24, Y+43	; 0x2b
    426a:	9c a5       	ldd	r25, Y+44	; 0x2c
    426c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4270:	dc 01       	movw	r26, r24
    4272:	cb 01       	movw	r24, r22
    4274:	88 a7       	std	Y+40, r24	; 0x28
    4276:	88 a5       	ldd	r24, Y+40	; 0x28
    4278:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    427a:	89 8d       	ldd	r24, Y+25	; 0x19
    427c:	8a 95       	dec	r24
    427e:	f1 f7       	brne	.-4      	; 0x427c <LCD_CheckStatusSendCmnd4bit+0x628>
    4280:	89 8f       	std	Y+25, r24	; 0x19
                _delay_us(1);
                DIO__CheckStatusSetPinValue(LCD__UINT8_CONTROL_PORT, LCD__UINT8_E_PIN, DIO__UINT8_LOW);
    4282:	83 e0       	ldi	r24, 0x03	; 3
    4284:	62 e0       	ldi	r22, 0x02	; 2
    4286:	40 e0       	ldi	r20, 0x00	; 0
    4288:	0e 94 67 08 	call	0x10ce	; 0x10ce <DIO__CheckStatusSetPinValue>
    428c:	80 e0       	ldi	r24, 0x00	; 0
    428e:	90 e0       	ldi	r25, 0x00	; 0
    4290:	a0 e8       	ldi	r26, 0x80	; 128
    4292:	bf e3       	ldi	r27, 0x3F	; 63
    4294:	8d 8b       	std	Y+21, r24	; 0x15
    4296:	9e 8b       	std	Y+22, r25	; 0x16
    4298:	af 8b       	std	Y+23, r26	; 0x17
    429a:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    429c:	6d 89       	ldd	r22, Y+21	; 0x15
    429e:	7e 89       	ldd	r23, Y+22	; 0x16
    42a0:	8f 89       	ldd	r24, Y+23	; 0x17
    42a2:	98 8d       	ldd	r25, Y+24	; 0x18
    42a4:	2b ea       	ldi	r18, 0xAB	; 171
    42a6:	3a ea       	ldi	r19, 0xAA	; 170
    42a8:	4a e2       	ldi	r20, 0x2A	; 42
    42aa:	50 e4       	ldi	r21, 0x40	; 64
    42ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    42b0:	dc 01       	movw	r26, r24
    42b2:	cb 01       	movw	r24, r22
    42b4:	89 8b       	std	Y+17, r24	; 0x11
    42b6:	9a 8b       	std	Y+18, r25	; 0x12
    42b8:	ab 8b       	std	Y+19, r26	; 0x13
    42ba:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    42bc:	69 89       	ldd	r22, Y+17	; 0x11
    42be:	7a 89       	ldd	r23, Y+18	; 0x12
    42c0:	8b 89       	ldd	r24, Y+19	; 0x13
    42c2:	9c 89       	ldd	r25, Y+20	; 0x14
    42c4:	20 e0       	ldi	r18, 0x00	; 0
    42c6:	30 e0       	ldi	r19, 0x00	; 0
    42c8:	40 e8       	ldi	r20, 0x80	; 128
    42ca:	5f e3       	ldi	r21, 0x3F	; 63
    42cc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    42d0:	88 23       	and	r24, r24
    42d2:	1c f4       	brge	.+6      	; 0x42da <LCD_CheckStatusSendCmnd4bit+0x686>
		__ticks = 1;
    42d4:	81 e0       	ldi	r24, 0x01	; 1
    42d6:	88 8b       	std	Y+16, r24	; 0x10
    42d8:	91 c0       	rjmp	.+290    	; 0x43fc <LCD_CheckStatusSendCmnd4bit+0x7a8>
	else if (__tmp > 255)
    42da:	69 89       	ldd	r22, Y+17	; 0x11
    42dc:	7a 89       	ldd	r23, Y+18	; 0x12
    42de:	8b 89       	ldd	r24, Y+19	; 0x13
    42e0:	9c 89       	ldd	r25, Y+20	; 0x14
    42e2:	20 e0       	ldi	r18, 0x00	; 0
    42e4:	30 e0       	ldi	r19, 0x00	; 0
    42e6:	4f e7       	ldi	r20, 0x7F	; 127
    42e8:	53 e4       	ldi	r21, 0x43	; 67
    42ea:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    42ee:	18 16       	cp	r1, r24
    42f0:	0c f0       	brlt	.+2      	; 0x42f4 <LCD_CheckStatusSendCmnd4bit+0x6a0>
    42f2:	7b c0       	rjmp	.+246    	; 0x43ea <LCD_CheckStatusSendCmnd4bit+0x796>
	{
		_delay_ms(__us / 1000.0);
    42f4:	6d 89       	ldd	r22, Y+21	; 0x15
    42f6:	7e 89       	ldd	r23, Y+22	; 0x16
    42f8:	8f 89       	ldd	r24, Y+23	; 0x17
    42fa:	98 8d       	ldd	r25, Y+24	; 0x18
    42fc:	20 e0       	ldi	r18, 0x00	; 0
    42fe:	30 e0       	ldi	r19, 0x00	; 0
    4300:	4a e7       	ldi	r20, 0x7A	; 122
    4302:	54 e4       	ldi	r21, 0x44	; 68
    4304:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    4308:	dc 01       	movw	r26, r24
    430a:	cb 01       	movw	r24, r22
    430c:	8c 87       	std	Y+12, r24	; 0x0c
    430e:	9d 87       	std	Y+13, r25	; 0x0d
    4310:	ae 87       	std	Y+14, r26	; 0x0e
    4312:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4314:	6c 85       	ldd	r22, Y+12	; 0x0c
    4316:	7d 85       	ldd	r23, Y+13	; 0x0d
    4318:	8e 85       	ldd	r24, Y+14	; 0x0e
    431a:	9f 85       	ldd	r25, Y+15	; 0x0f
    431c:	20 e0       	ldi	r18, 0x00	; 0
    431e:	30 e0       	ldi	r19, 0x00	; 0
    4320:	4a ef       	ldi	r20, 0xFA	; 250
    4322:	54 e4       	ldi	r21, 0x44	; 68
    4324:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4328:	dc 01       	movw	r26, r24
    432a:	cb 01       	movw	r24, r22
    432c:	88 87       	std	Y+8, r24	; 0x08
    432e:	99 87       	std	Y+9, r25	; 0x09
    4330:	aa 87       	std	Y+10, r26	; 0x0a
    4332:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    4334:	68 85       	ldd	r22, Y+8	; 0x08
    4336:	79 85       	ldd	r23, Y+9	; 0x09
    4338:	8a 85       	ldd	r24, Y+10	; 0x0a
    433a:	9b 85       	ldd	r25, Y+11	; 0x0b
    433c:	20 e0       	ldi	r18, 0x00	; 0
    433e:	30 e0       	ldi	r19, 0x00	; 0
    4340:	40 e8       	ldi	r20, 0x80	; 128
    4342:	5f e3       	ldi	r21, 0x3F	; 63
    4344:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4348:	88 23       	and	r24, r24
    434a:	2c f4       	brge	.+10     	; 0x4356 <LCD_CheckStatusSendCmnd4bit+0x702>
		__ticks = 1;
    434c:	81 e0       	ldi	r24, 0x01	; 1
    434e:	90 e0       	ldi	r25, 0x00	; 0
    4350:	9f 83       	std	Y+7, r25	; 0x07
    4352:	8e 83       	std	Y+6, r24	; 0x06
    4354:	3f c0       	rjmp	.+126    	; 0x43d4 <LCD_CheckStatusSendCmnd4bit+0x780>
	else if (__tmp > 65535)
    4356:	68 85       	ldd	r22, Y+8	; 0x08
    4358:	79 85       	ldd	r23, Y+9	; 0x09
    435a:	8a 85       	ldd	r24, Y+10	; 0x0a
    435c:	9b 85       	ldd	r25, Y+11	; 0x0b
    435e:	20 e0       	ldi	r18, 0x00	; 0
    4360:	3f ef       	ldi	r19, 0xFF	; 255
    4362:	4f e7       	ldi	r20, 0x7F	; 127
    4364:	57 e4       	ldi	r21, 0x47	; 71
    4366:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    436a:	18 16       	cp	r1, r24
    436c:	4c f5       	brge	.+82     	; 0x43c0 <LCD_CheckStatusSendCmnd4bit+0x76c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    436e:	6c 85       	ldd	r22, Y+12	; 0x0c
    4370:	7d 85       	ldd	r23, Y+13	; 0x0d
    4372:	8e 85       	ldd	r24, Y+14	; 0x0e
    4374:	9f 85       	ldd	r25, Y+15	; 0x0f
    4376:	20 e0       	ldi	r18, 0x00	; 0
    4378:	30 e0       	ldi	r19, 0x00	; 0
    437a:	40 e2       	ldi	r20, 0x20	; 32
    437c:	51 e4       	ldi	r21, 0x41	; 65
    437e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4382:	dc 01       	movw	r26, r24
    4384:	cb 01       	movw	r24, r22
    4386:	bc 01       	movw	r22, r24
    4388:	cd 01       	movw	r24, r26
    438a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    438e:	dc 01       	movw	r26, r24
    4390:	cb 01       	movw	r24, r22
    4392:	9f 83       	std	Y+7, r25	; 0x07
    4394:	8e 83       	std	Y+6, r24	; 0x06
    4396:	0f c0       	rjmp	.+30     	; 0x43b6 <LCD_CheckStatusSendCmnd4bit+0x762>
    4398:	88 ec       	ldi	r24, 0xC8	; 200
    439a:	90 e0       	ldi	r25, 0x00	; 0
    439c:	9d 83       	std	Y+5, r25	; 0x05
    439e:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    43a0:	8c 81       	ldd	r24, Y+4	; 0x04
    43a2:	9d 81       	ldd	r25, Y+5	; 0x05
    43a4:	01 97       	sbiw	r24, 0x01	; 1
    43a6:	f1 f7       	brne	.-4      	; 0x43a4 <LCD_CheckStatusSendCmnd4bit+0x750>
    43a8:	9d 83       	std	Y+5, r25	; 0x05
    43aa:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    43ac:	8e 81       	ldd	r24, Y+6	; 0x06
    43ae:	9f 81       	ldd	r25, Y+7	; 0x07
    43b0:	01 97       	sbiw	r24, 0x01	; 1
    43b2:	9f 83       	std	Y+7, r25	; 0x07
    43b4:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    43b6:	8e 81       	ldd	r24, Y+6	; 0x06
    43b8:	9f 81       	ldd	r25, Y+7	; 0x07
    43ba:	00 97       	sbiw	r24, 0x00	; 0
    43bc:	69 f7       	brne	.-38     	; 0x4398 <LCD_CheckStatusSendCmnd4bit+0x744>
    43be:	24 c0       	rjmp	.+72     	; 0x4408 <LCD_CheckStatusSendCmnd4bit+0x7b4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    43c0:	68 85       	ldd	r22, Y+8	; 0x08
    43c2:	79 85       	ldd	r23, Y+9	; 0x09
    43c4:	8a 85       	ldd	r24, Y+10	; 0x0a
    43c6:	9b 85       	ldd	r25, Y+11	; 0x0b
    43c8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    43cc:	dc 01       	movw	r26, r24
    43ce:	cb 01       	movw	r24, r22
    43d0:	9f 83       	std	Y+7, r25	; 0x07
    43d2:	8e 83       	std	Y+6, r24	; 0x06
    43d4:	8e 81       	ldd	r24, Y+6	; 0x06
    43d6:	9f 81       	ldd	r25, Y+7	; 0x07
    43d8:	9b 83       	std	Y+3, r25	; 0x03
    43da:	8a 83       	std	Y+2, r24	; 0x02
    43dc:	8a 81       	ldd	r24, Y+2	; 0x02
    43de:	9b 81       	ldd	r25, Y+3	; 0x03
    43e0:	01 97       	sbiw	r24, 0x01	; 1
    43e2:	f1 f7       	brne	.-4      	; 0x43e0 <LCD_CheckStatusSendCmnd4bit+0x78c>
    43e4:	9b 83       	std	Y+3, r25	; 0x03
    43e6:	8a 83       	std	Y+2, r24	; 0x02
    43e8:	0f c0       	rjmp	.+30     	; 0x4408 <LCD_CheckStatusSendCmnd4bit+0x7b4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    43ea:	69 89       	ldd	r22, Y+17	; 0x11
    43ec:	7a 89       	ldd	r23, Y+18	; 0x12
    43ee:	8b 89       	ldd	r24, Y+19	; 0x13
    43f0:	9c 89       	ldd	r25, Y+20	; 0x14
    43f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    43f6:	dc 01       	movw	r26, r24
    43f8:	cb 01       	movw	r24, r22
    43fa:	88 8b       	std	Y+16, r24	; 0x10
    43fc:	88 89       	ldd	r24, Y+16	; 0x10
    43fe:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4400:	89 81       	ldd	r24, Y+1	; 0x01
    4402:	8a 95       	dec	r24
    4404:	f1 f7       	brne	.-4      	; 0x4402 <LCD_CheckStatusSendCmnd4bit+0x7ae>
    4406:	89 83       	std	Y+1, r24	; 0x01
        }
        else
        {
                Local_CheckStausReturnValue = CHECK_FAIL;
        }
        return Local_CheckStausReturnValue;
    4408:	fe 01       	movw	r30, r28
    440a:	ef 59       	subi	r30, 0x9F	; 159
    440c:	ff 4f       	sbci	r31, 0xFF	; 255
    440e:	80 81       	ld	r24, Z
}
    4410:	ce 59       	subi	r28, 0x9E	; 158
    4412:	df 4f       	sbci	r29, 0xFF	; 255
    4414:	0f b6       	in	r0, 0x3f	; 63
    4416:	f8 94       	cli
    4418:	de bf       	out	0x3e, r29	; 62
    441a:	0f be       	out	0x3f, r0	; 63
    441c:	cd bf       	out	0x3d, r28	; 61
    441e:	cf 91       	pop	r28
    4420:	df 91       	pop	r29
    4422:	1f 91       	pop	r17
    4424:	0f 91       	pop	r16
    4426:	08 95       	ret

00004428 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    4428:	df 93       	push	r29
    442a:	cf 93       	push	r28
    442c:	cd b7       	in	r28, 0x3d	; 61
    442e:	de b7       	in	r29, 0x3e	; 62
    4430:	27 97       	sbiw	r28, 0x07	; 7
    4432:	0f b6       	in	r0, 0x3f	; 63
    4434:	f8 94       	cli
    4436:	de bf       	out	0x3e, r29	; 62
    4438:	0f be       	out	0x3f, r0	; 63
    443a:	cd bf       	out	0x3d, r28	; 61
    443c:	9d 83       	std	Y+5, r25	; 0x05
    443e:	8c 83       	std	Y+4, r24	; 0x04
    4440:	6e 83       	std	Y+6, r22	; 0x06
    4442:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    4444:	8a e1       	ldi	r24, 0x1A	; 26
    4446:	90 e0       	ldi	r25, 0x00	; 0
    4448:	0e 94 ec 24 	call	0x49d8	; 0x49d8 <pvPortMalloc>
    444c:	9a 83       	std	Y+2, r25	; 0x02
    444e:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    4450:	89 81       	ldd	r24, Y+1	; 0x01
    4452:	9a 81       	ldd	r25, Y+2	; 0x02
    4454:	00 97       	sbiw	r24, 0x00	; 0
    4456:	09 f4       	brne	.+2      	; 0x445a <xCoRoutineCreate+0x32>
    4458:	6f c0       	rjmp	.+222    	; 0x4538 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    445a:	80 91 d6 01 	lds	r24, 0x01D6
    445e:	90 91 d7 01 	lds	r25, 0x01D7
    4462:	00 97       	sbiw	r24, 0x00	; 0
    4464:	41 f4       	brne	.+16     	; 0x4476 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    4466:	89 81       	ldd	r24, Y+1	; 0x01
    4468:	9a 81       	ldd	r25, Y+2	; 0x02
    446a:	90 93 d7 01 	sts	0x01D7, r25
    446e:	80 93 d6 01 	sts	0x01D6, r24
			prvInitialiseCoRoutineLists();
    4472:	0e 94 7b 24 	call	0x48f6	; 0x48f6 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    4476:	8e 81       	ldd	r24, Y+6	; 0x06
    4478:	82 30       	cpi	r24, 0x02	; 2
    447a:	10 f0       	brcs	.+4      	; 0x4480 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    447c:	81 e0       	ldi	r24, 0x01	; 1
    447e:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    4480:	e9 81       	ldd	r30, Y+1	; 0x01
    4482:	fa 81       	ldd	r31, Y+2	; 0x02
    4484:	11 8e       	std	Z+25, r1	; 0x19
    4486:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    4488:	e9 81       	ldd	r30, Y+1	; 0x01
    448a:	fa 81       	ldd	r31, Y+2	; 0x02
    448c:	8e 81       	ldd	r24, Y+6	; 0x06
    448e:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    4490:	e9 81       	ldd	r30, Y+1	; 0x01
    4492:	fa 81       	ldd	r31, Y+2	; 0x02
    4494:	8f 81       	ldd	r24, Y+7	; 0x07
    4496:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    4498:	e9 81       	ldd	r30, Y+1	; 0x01
    449a:	fa 81       	ldd	r31, Y+2	; 0x02
    449c:	8c 81       	ldd	r24, Y+4	; 0x04
    449e:	9d 81       	ldd	r25, Y+5	; 0x05
    44a0:	91 83       	std	Z+1, r25	; 0x01
    44a2:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    44a4:	89 81       	ldd	r24, Y+1	; 0x01
    44a6:	9a 81       	ldd	r25, Y+2	; 0x02
    44a8:	02 96       	adiw	r24, 0x02	; 2
    44aa:	0e 94 82 25 	call	0x4b04	; 0x4b04 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    44ae:	89 81       	ldd	r24, Y+1	; 0x01
    44b0:	9a 81       	ldd	r25, Y+2	; 0x02
    44b2:	0c 96       	adiw	r24, 0x0c	; 12
    44b4:	0e 94 82 25 	call	0x4b04	; 0x4b04 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    44b8:	e9 81       	ldd	r30, Y+1	; 0x01
    44ba:	fa 81       	ldd	r31, Y+2	; 0x02
    44bc:	89 81       	ldd	r24, Y+1	; 0x01
    44be:	9a 81       	ldd	r25, Y+2	; 0x02
    44c0:	91 87       	std	Z+9, r25	; 0x09
    44c2:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    44c4:	e9 81       	ldd	r30, Y+1	; 0x01
    44c6:	fa 81       	ldd	r31, Y+2	; 0x02
    44c8:	89 81       	ldd	r24, Y+1	; 0x01
    44ca:	9a 81       	ldd	r25, Y+2	; 0x02
    44cc:	93 8b       	std	Z+19, r25	; 0x13
    44ce:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    44d0:	8e 81       	ldd	r24, Y+6	; 0x06
    44d2:	28 2f       	mov	r18, r24
    44d4:	30 e0       	ldi	r19, 0x00	; 0
    44d6:	85 e0       	ldi	r24, 0x05	; 5
    44d8:	90 e0       	ldi	r25, 0x00	; 0
    44da:	82 1b       	sub	r24, r18
    44dc:	93 0b       	sbc	r25, r19
    44de:	e9 81       	ldd	r30, Y+1	; 0x01
    44e0:	fa 81       	ldd	r31, Y+2	; 0x02
    44e2:	95 87       	std	Z+13, r25	; 0x0d
    44e4:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    44e6:	e9 81       	ldd	r30, Y+1	; 0x01
    44e8:	fa 81       	ldd	r31, Y+2	; 0x02
    44ea:	96 89       	ldd	r25, Z+22	; 0x16
    44ec:	80 91 d8 01 	lds	r24, 0x01D8
    44f0:	89 17       	cp	r24, r25
    44f2:	28 f4       	brcc	.+10     	; 0x44fe <xCoRoutineCreate+0xd6>
    44f4:	e9 81       	ldd	r30, Y+1	; 0x01
    44f6:	fa 81       	ldd	r31, Y+2	; 0x02
    44f8:	86 89       	ldd	r24, Z+22	; 0x16
    44fa:	80 93 d8 01 	sts	0x01D8, r24
    44fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4500:	fa 81       	ldd	r31, Y+2	; 0x02
    4502:	86 89       	ldd	r24, Z+22	; 0x16
    4504:	28 2f       	mov	r18, r24
    4506:	30 e0       	ldi	r19, 0x00	; 0
    4508:	c9 01       	movw	r24, r18
    450a:	88 0f       	add	r24, r24
    450c:	99 1f       	adc	r25, r25
    450e:	88 0f       	add	r24, r24
    4510:	99 1f       	adc	r25, r25
    4512:	88 0f       	add	r24, r24
    4514:	99 1f       	adc	r25, r25
    4516:	82 0f       	add	r24, r18
    4518:	93 1f       	adc	r25, r19
    451a:	ac 01       	movw	r20, r24
    451c:	41 52       	subi	r20, 0x21	; 33
    451e:	5e 4f       	sbci	r21, 0xFE	; 254
    4520:	89 81       	ldd	r24, Y+1	; 0x01
    4522:	9a 81       	ldd	r25, Y+2	; 0x02
    4524:	9c 01       	movw	r18, r24
    4526:	2e 5f       	subi	r18, 0xFE	; 254
    4528:	3f 4f       	sbci	r19, 0xFF	; 255
    452a:	ca 01       	movw	r24, r20
    452c:	b9 01       	movw	r22, r18
    452e:	0e 94 92 25 	call	0x4b24	; 0x4b24 <vListInsertEnd>

		xReturn = pdPASS;
    4532:	81 e0       	ldi	r24, 0x01	; 1
    4534:	8b 83       	std	Y+3, r24	; 0x03
    4536:	02 c0       	rjmp	.+4      	; 0x453c <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4538:	8f ef       	ldi	r24, 0xFF	; 255
    453a:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    453c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    453e:	27 96       	adiw	r28, 0x07	; 7
    4540:	0f b6       	in	r0, 0x3f	; 63
    4542:	f8 94       	cli
    4544:	de bf       	out	0x3e, r29	; 62
    4546:	0f be       	out	0x3f, r0	; 63
    4548:	cd bf       	out	0x3d, r28	; 61
    454a:	cf 91       	pop	r28
    454c:	df 91       	pop	r29
    454e:	08 95       	ret

00004550 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    4550:	df 93       	push	r29
    4552:	cf 93       	push	r28
    4554:	00 d0       	rcall	.+0      	; 0x4556 <vCoRoutineAddToDelayedList+0x6>
    4556:	00 d0       	rcall	.+0      	; 0x4558 <vCoRoutineAddToDelayedList+0x8>
    4558:	00 d0       	rcall	.+0      	; 0x455a <vCoRoutineAddToDelayedList+0xa>
    455a:	cd b7       	in	r28, 0x3d	; 61
    455c:	de b7       	in	r29, 0x3e	; 62
    455e:	9c 83       	std	Y+4, r25	; 0x04
    4560:	8b 83       	std	Y+3, r24	; 0x03
    4562:	7e 83       	std	Y+6, r23	; 0x06
    4564:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    4566:	20 91 d9 01 	lds	r18, 0x01D9
    456a:	30 91 da 01 	lds	r19, 0x01DA
    456e:	8b 81       	ldd	r24, Y+3	; 0x03
    4570:	9c 81       	ldd	r25, Y+4	; 0x04
    4572:	82 0f       	add	r24, r18
    4574:	93 1f       	adc	r25, r19
    4576:	9a 83       	std	Y+2, r25	; 0x02
    4578:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    457a:	80 91 d6 01 	lds	r24, 0x01D6
    457e:	90 91 d7 01 	lds	r25, 0x01D7
    4582:	02 96       	adiw	r24, 0x02	; 2
    4584:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    4588:	e0 91 d6 01 	lds	r30, 0x01D6
    458c:	f0 91 d7 01 	lds	r31, 0x01D7
    4590:	89 81       	ldd	r24, Y+1	; 0x01
    4592:	9a 81       	ldd	r25, Y+2	; 0x02
    4594:	93 83       	std	Z+3, r25	; 0x03
    4596:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    4598:	20 91 d9 01 	lds	r18, 0x01D9
    459c:	30 91 da 01 	lds	r19, 0x01DA
    45a0:	89 81       	ldd	r24, Y+1	; 0x01
    45a2:	9a 81       	ldd	r25, Y+2	; 0x02
    45a4:	82 17       	cp	r24, r18
    45a6:	93 07       	cpc	r25, r19
    45a8:	70 f4       	brcc	.+28     	; 0x45c6 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    45aa:	80 91 05 02 	lds	r24, 0x0205
    45ae:	90 91 06 02 	lds	r25, 0x0206
    45b2:	20 91 d6 01 	lds	r18, 0x01D6
    45b6:	30 91 d7 01 	lds	r19, 0x01D7
    45ba:	2e 5f       	subi	r18, 0xFE	; 254
    45bc:	3f 4f       	sbci	r19, 0xFF	; 255
    45be:	b9 01       	movw	r22, r18
    45c0:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <vListInsert>
    45c4:	0d c0       	rjmp	.+26     	; 0x45e0 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    45c6:	80 91 03 02 	lds	r24, 0x0203
    45ca:	90 91 04 02 	lds	r25, 0x0204
    45ce:	20 91 d6 01 	lds	r18, 0x01D6
    45d2:	30 91 d7 01 	lds	r19, 0x01D7
    45d6:	2e 5f       	subi	r18, 0xFE	; 254
    45d8:	3f 4f       	sbci	r19, 0xFF	; 255
    45da:	b9 01       	movw	r22, r18
    45dc:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <vListInsert>
	}

	if( pxEventList )
    45e0:	8d 81       	ldd	r24, Y+5	; 0x05
    45e2:	9e 81       	ldd	r25, Y+6	; 0x06
    45e4:	00 97       	sbiw	r24, 0x00	; 0
    45e6:	61 f0       	breq	.+24     	; 0x4600 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    45e8:	80 91 d6 01 	lds	r24, 0x01D6
    45ec:	90 91 d7 01 	lds	r25, 0x01D7
    45f0:	9c 01       	movw	r18, r24
    45f2:	24 5f       	subi	r18, 0xF4	; 244
    45f4:	3f 4f       	sbci	r19, 0xFF	; 255
    45f6:	8d 81       	ldd	r24, Y+5	; 0x05
    45f8:	9e 81       	ldd	r25, Y+6	; 0x06
    45fa:	b9 01       	movw	r22, r18
    45fc:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <vListInsert>
	}
}
    4600:	26 96       	adiw	r28, 0x06	; 6
    4602:	0f b6       	in	r0, 0x3f	; 63
    4604:	f8 94       	cli
    4606:	de bf       	out	0x3e, r29	; 62
    4608:	0f be       	out	0x3f, r0	; 63
    460a:	cd bf       	out	0x3d, r28	; 61
    460c:	cf 91       	pop	r28
    460e:	df 91       	pop	r29
    4610:	08 95       	ret

00004612 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    4612:	df 93       	push	r29
    4614:	cf 93       	push	r28
    4616:	00 d0       	rcall	.+0      	; 0x4618 <prvCheckPendingReadyList+0x6>
    4618:	cd b7       	in	r28, 0x3d	; 61
    461a:	de b7       	in	r29, 0x3e	; 62
    461c:	3a c0       	rjmp	.+116    	; 0x4692 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    461e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    4620:	e0 91 0c 02 	lds	r30, 0x020C
    4624:	f0 91 0d 02 	lds	r31, 0x020D
    4628:	86 81       	ldd	r24, Z+6	; 0x06
    462a:	97 81       	ldd	r25, Z+7	; 0x07
    462c:	9a 83       	std	Y+2, r25	; 0x02
    462e:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    4630:	89 81       	ldd	r24, Y+1	; 0x01
    4632:	9a 81       	ldd	r25, Y+2	; 0x02
    4634:	0c 96       	adiw	r24, 0x0c	; 12
    4636:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    463a:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    463c:	89 81       	ldd	r24, Y+1	; 0x01
    463e:	9a 81       	ldd	r25, Y+2	; 0x02
    4640:	02 96       	adiw	r24, 0x02	; 2
    4642:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    4646:	e9 81       	ldd	r30, Y+1	; 0x01
    4648:	fa 81       	ldd	r31, Y+2	; 0x02
    464a:	96 89       	ldd	r25, Z+22	; 0x16
    464c:	80 91 d8 01 	lds	r24, 0x01D8
    4650:	89 17       	cp	r24, r25
    4652:	28 f4       	brcc	.+10     	; 0x465e <prvCheckPendingReadyList+0x4c>
    4654:	e9 81       	ldd	r30, Y+1	; 0x01
    4656:	fa 81       	ldd	r31, Y+2	; 0x02
    4658:	86 89       	ldd	r24, Z+22	; 0x16
    465a:	80 93 d8 01 	sts	0x01D8, r24
    465e:	e9 81       	ldd	r30, Y+1	; 0x01
    4660:	fa 81       	ldd	r31, Y+2	; 0x02
    4662:	86 89       	ldd	r24, Z+22	; 0x16
    4664:	28 2f       	mov	r18, r24
    4666:	30 e0       	ldi	r19, 0x00	; 0
    4668:	c9 01       	movw	r24, r18
    466a:	88 0f       	add	r24, r24
    466c:	99 1f       	adc	r25, r25
    466e:	88 0f       	add	r24, r24
    4670:	99 1f       	adc	r25, r25
    4672:	88 0f       	add	r24, r24
    4674:	99 1f       	adc	r25, r25
    4676:	82 0f       	add	r24, r18
    4678:	93 1f       	adc	r25, r19
    467a:	ac 01       	movw	r20, r24
    467c:	41 52       	subi	r20, 0x21	; 33
    467e:	5e 4f       	sbci	r21, 0xFE	; 254
    4680:	89 81       	ldd	r24, Y+1	; 0x01
    4682:	9a 81       	ldd	r25, Y+2	; 0x02
    4684:	9c 01       	movw	r18, r24
    4686:	2e 5f       	subi	r18, 0xFE	; 254
    4688:	3f 4f       	sbci	r19, 0xFF	; 255
    468a:	ca 01       	movw	r24, r20
    468c:	b9 01       	movw	r22, r18
    468e:	0e 94 92 25 	call	0x4b24	; 0x4b24 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    4692:	80 91 07 02 	lds	r24, 0x0207
    4696:	88 23       	and	r24, r24
    4698:	09 f0       	breq	.+2      	; 0x469c <prvCheckPendingReadyList+0x8a>
    469a:	c1 cf       	rjmp	.-126    	; 0x461e <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    469c:	0f 90       	pop	r0
    469e:	0f 90       	pop	r0
    46a0:	cf 91       	pop	r28
    46a2:	df 91       	pop	r29
    46a4:	08 95       	ret

000046a6 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    46a6:	df 93       	push	r29
    46a8:	cf 93       	push	r28
    46aa:	00 d0       	rcall	.+0      	; 0x46ac <prvCheckDelayedList+0x6>
    46ac:	00 d0       	rcall	.+0      	; 0x46ae <prvCheckDelayedList+0x8>
    46ae:	cd b7       	in	r28, 0x3d	; 61
    46b0:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    46b2:	0e 94 60 31 	call	0x62c0	; 0x62c0 <xTaskGetTickCount>
    46b6:	20 91 db 01 	lds	r18, 0x01DB
    46ba:	30 91 dc 01 	lds	r19, 0x01DC
    46be:	82 1b       	sub	r24, r18
    46c0:	93 0b       	sbc	r25, r19
    46c2:	90 93 de 01 	sts	0x01DE, r25
    46c6:	80 93 dd 01 	sts	0x01DD, r24
    46ca:	85 c0       	rjmp	.+266    	; 0x47d6 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    46cc:	80 91 d9 01 	lds	r24, 0x01D9
    46d0:	90 91 da 01 	lds	r25, 0x01DA
    46d4:	01 96       	adiw	r24, 0x01	; 1
    46d6:	90 93 da 01 	sts	0x01DA, r25
    46da:	80 93 d9 01 	sts	0x01D9, r24
		xPassedTicks--;
    46de:	80 91 dd 01 	lds	r24, 0x01DD
    46e2:	90 91 de 01 	lds	r25, 0x01DE
    46e6:	01 97       	sbiw	r24, 0x01	; 1
    46e8:	90 93 de 01 	sts	0x01DE, r25
    46ec:	80 93 dd 01 	sts	0x01DD, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    46f0:	80 91 d9 01 	lds	r24, 0x01D9
    46f4:	90 91 da 01 	lds	r25, 0x01DA
    46f8:	00 97       	sbiw	r24, 0x00	; 0
    46fa:	09 f0       	breq	.+2      	; 0x46fe <prvCheckDelayedList+0x58>
    46fc:	64 c0       	rjmp	.+200    	; 0x47c6 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    46fe:	80 91 03 02 	lds	r24, 0x0203
    4702:	90 91 04 02 	lds	r25, 0x0204
    4706:	9a 83       	std	Y+2, r25	; 0x02
    4708:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    470a:	80 91 05 02 	lds	r24, 0x0205
    470e:	90 91 06 02 	lds	r25, 0x0206
    4712:	90 93 04 02 	sts	0x0204, r25
    4716:	80 93 03 02 	sts	0x0203, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    471a:	89 81       	ldd	r24, Y+1	; 0x01
    471c:	9a 81       	ldd	r25, Y+2	; 0x02
    471e:	90 93 06 02 	sts	0x0206, r25
    4722:	80 93 05 02 	sts	0x0205, r24
    4726:	4f c0       	rjmp	.+158    	; 0x47c6 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    4728:	e0 91 03 02 	lds	r30, 0x0203
    472c:	f0 91 04 02 	lds	r31, 0x0204
    4730:	05 80       	ldd	r0, Z+5	; 0x05
    4732:	f6 81       	ldd	r31, Z+6	; 0x06
    4734:	e0 2d       	mov	r30, r0
    4736:	86 81       	ldd	r24, Z+6	; 0x06
    4738:	97 81       	ldd	r25, Z+7	; 0x07
    473a:	9c 83       	std	Y+4, r25	; 0x04
    473c:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    473e:	eb 81       	ldd	r30, Y+3	; 0x03
    4740:	fc 81       	ldd	r31, Y+4	; 0x04
    4742:	22 81       	ldd	r18, Z+2	; 0x02
    4744:	33 81       	ldd	r19, Z+3	; 0x03
    4746:	80 91 d9 01 	lds	r24, 0x01D9
    474a:	90 91 da 01 	lds	r25, 0x01DA
    474e:	82 17       	cp	r24, r18
    4750:	93 07       	cpc	r25, r19
    4752:	08 f4       	brcc	.+2      	; 0x4756 <prvCheckDelayedList+0xb0>
    4754:	40 c0       	rjmp	.+128    	; 0x47d6 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    4756:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    4758:	8b 81       	ldd	r24, Y+3	; 0x03
    475a:	9c 81       	ldd	r25, Y+4	; 0x04
    475c:	02 96       	adiw	r24, 0x02	; 2
    475e:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    4762:	eb 81       	ldd	r30, Y+3	; 0x03
    4764:	fc 81       	ldd	r31, Y+4	; 0x04
    4766:	84 89       	ldd	r24, Z+20	; 0x14
    4768:	95 89       	ldd	r25, Z+21	; 0x15
    476a:	00 97       	sbiw	r24, 0x00	; 0
    476c:	29 f0       	breq	.+10     	; 0x4778 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    476e:	8b 81       	ldd	r24, Y+3	; 0x03
    4770:	9c 81       	ldd	r25, Y+4	; 0x04
    4772:	0c 96       	adiw	r24, 0x0c	; 12
    4774:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    4778:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    477a:	eb 81       	ldd	r30, Y+3	; 0x03
    477c:	fc 81       	ldd	r31, Y+4	; 0x04
    477e:	96 89       	ldd	r25, Z+22	; 0x16
    4780:	80 91 d8 01 	lds	r24, 0x01D8
    4784:	89 17       	cp	r24, r25
    4786:	28 f4       	brcc	.+10     	; 0x4792 <prvCheckDelayedList+0xec>
    4788:	eb 81       	ldd	r30, Y+3	; 0x03
    478a:	fc 81       	ldd	r31, Y+4	; 0x04
    478c:	86 89       	ldd	r24, Z+22	; 0x16
    478e:	80 93 d8 01 	sts	0x01D8, r24
    4792:	eb 81       	ldd	r30, Y+3	; 0x03
    4794:	fc 81       	ldd	r31, Y+4	; 0x04
    4796:	86 89       	ldd	r24, Z+22	; 0x16
    4798:	28 2f       	mov	r18, r24
    479a:	30 e0       	ldi	r19, 0x00	; 0
    479c:	c9 01       	movw	r24, r18
    479e:	88 0f       	add	r24, r24
    47a0:	99 1f       	adc	r25, r25
    47a2:	88 0f       	add	r24, r24
    47a4:	99 1f       	adc	r25, r25
    47a6:	88 0f       	add	r24, r24
    47a8:	99 1f       	adc	r25, r25
    47aa:	82 0f       	add	r24, r18
    47ac:	93 1f       	adc	r25, r19
    47ae:	ac 01       	movw	r20, r24
    47b0:	41 52       	subi	r20, 0x21	; 33
    47b2:	5e 4f       	sbci	r21, 0xFE	; 254
    47b4:	8b 81       	ldd	r24, Y+3	; 0x03
    47b6:	9c 81       	ldd	r25, Y+4	; 0x04
    47b8:	9c 01       	movw	r18, r24
    47ba:	2e 5f       	subi	r18, 0xFE	; 254
    47bc:	3f 4f       	sbci	r19, 0xFF	; 255
    47be:	ca 01       	movw	r24, r20
    47c0:	b9 01       	movw	r22, r18
    47c2:	0e 94 92 25 	call	0x4b24	; 0x4b24 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    47c6:	e0 91 03 02 	lds	r30, 0x0203
    47ca:	f0 91 04 02 	lds	r31, 0x0204
    47ce:	80 81       	ld	r24, Z
    47d0:	88 23       	and	r24, r24
    47d2:	09 f0       	breq	.+2      	; 0x47d6 <prvCheckDelayedList+0x130>
    47d4:	a9 cf       	rjmp	.-174    	; 0x4728 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    47d6:	80 91 dd 01 	lds	r24, 0x01DD
    47da:	90 91 de 01 	lds	r25, 0x01DE
    47de:	00 97       	sbiw	r24, 0x00	; 0
    47e0:	09 f0       	breq	.+2      	; 0x47e4 <prvCheckDelayedList+0x13e>
    47e2:	74 cf       	rjmp	.-280    	; 0x46cc <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    47e4:	80 91 d9 01 	lds	r24, 0x01D9
    47e8:	90 91 da 01 	lds	r25, 0x01DA
    47ec:	90 93 dc 01 	sts	0x01DC, r25
    47f0:	80 93 db 01 	sts	0x01DB, r24
}
    47f4:	0f 90       	pop	r0
    47f6:	0f 90       	pop	r0
    47f8:	0f 90       	pop	r0
    47fa:	0f 90       	pop	r0
    47fc:	cf 91       	pop	r28
    47fe:	df 91       	pop	r29
    4800:	08 95       	ret

00004802 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    4802:	df 93       	push	r29
    4804:	cf 93       	push	r28
    4806:	00 d0       	rcall	.+0      	; 0x4808 <vCoRoutineSchedule+0x6>
    4808:	cd b7       	in	r28, 0x3d	; 61
    480a:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    480c:	0e 94 09 23 	call	0x4612	; 0x4612 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    4810:	0e 94 53 23 	call	0x46a6	; 0x46a6 <prvCheckDelayedList>
    4814:	0a c0       	rjmp	.+20     	; 0x482a <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    4816:	80 91 d8 01 	lds	r24, 0x01D8
    481a:	88 23       	and	r24, r24
    481c:	09 f4       	brne	.+2      	; 0x4820 <vCoRoutineSchedule+0x1e>
    481e:	66 c0       	rjmp	.+204    	; 0x48ec <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    4820:	80 91 d8 01 	lds	r24, 0x01D8
    4824:	81 50       	subi	r24, 0x01	; 1
    4826:	80 93 d8 01 	sts	0x01D8, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    482a:	80 91 d8 01 	lds	r24, 0x01D8
    482e:	28 2f       	mov	r18, r24
    4830:	30 e0       	ldi	r19, 0x00	; 0
    4832:	c9 01       	movw	r24, r18
    4834:	88 0f       	add	r24, r24
    4836:	99 1f       	adc	r25, r25
    4838:	88 0f       	add	r24, r24
    483a:	99 1f       	adc	r25, r25
    483c:	88 0f       	add	r24, r24
    483e:	99 1f       	adc	r25, r25
    4840:	82 0f       	add	r24, r18
    4842:	93 1f       	adc	r25, r19
    4844:	fc 01       	movw	r30, r24
    4846:	e1 52       	subi	r30, 0x21	; 33
    4848:	fe 4f       	sbci	r31, 0xFE	; 254
    484a:	80 81       	ld	r24, Z
    484c:	88 23       	and	r24, r24
    484e:	19 f3       	breq	.-58     	; 0x4816 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    4850:	80 91 d8 01 	lds	r24, 0x01D8
    4854:	28 2f       	mov	r18, r24
    4856:	30 e0       	ldi	r19, 0x00	; 0
    4858:	c9 01       	movw	r24, r18
    485a:	88 0f       	add	r24, r24
    485c:	99 1f       	adc	r25, r25
    485e:	88 0f       	add	r24, r24
    4860:	99 1f       	adc	r25, r25
    4862:	88 0f       	add	r24, r24
    4864:	99 1f       	adc	r25, r25
    4866:	82 0f       	add	r24, r18
    4868:	93 1f       	adc	r25, r19
    486a:	81 52       	subi	r24, 0x21	; 33
    486c:	9e 4f       	sbci	r25, 0xFE	; 254
    486e:	9a 83       	std	Y+2, r25	; 0x02
    4870:	89 83       	std	Y+1, r24	; 0x01
    4872:	e9 81       	ldd	r30, Y+1	; 0x01
    4874:	fa 81       	ldd	r31, Y+2	; 0x02
    4876:	01 80       	ldd	r0, Z+1	; 0x01
    4878:	f2 81       	ldd	r31, Z+2	; 0x02
    487a:	e0 2d       	mov	r30, r0
    487c:	82 81       	ldd	r24, Z+2	; 0x02
    487e:	93 81       	ldd	r25, Z+3	; 0x03
    4880:	e9 81       	ldd	r30, Y+1	; 0x01
    4882:	fa 81       	ldd	r31, Y+2	; 0x02
    4884:	92 83       	std	Z+2, r25	; 0x02
    4886:	81 83       	std	Z+1, r24	; 0x01
    4888:	e9 81       	ldd	r30, Y+1	; 0x01
    488a:	fa 81       	ldd	r31, Y+2	; 0x02
    488c:	21 81       	ldd	r18, Z+1	; 0x01
    488e:	32 81       	ldd	r19, Z+2	; 0x02
    4890:	89 81       	ldd	r24, Y+1	; 0x01
    4892:	9a 81       	ldd	r25, Y+2	; 0x02
    4894:	03 96       	adiw	r24, 0x03	; 3
    4896:	28 17       	cp	r18, r24
    4898:	39 07       	cpc	r19, r25
    489a:	59 f4       	brne	.+22     	; 0x48b2 <vCoRoutineSchedule+0xb0>
    489c:	e9 81       	ldd	r30, Y+1	; 0x01
    489e:	fa 81       	ldd	r31, Y+2	; 0x02
    48a0:	01 80       	ldd	r0, Z+1	; 0x01
    48a2:	f2 81       	ldd	r31, Z+2	; 0x02
    48a4:	e0 2d       	mov	r30, r0
    48a6:	82 81       	ldd	r24, Z+2	; 0x02
    48a8:	93 81       	ldd	r25, Z+3	; 0x03
    48aa:	e9 81       	ldd	r30, Y+1	; 0x01
    48ac:	fa 81       	ldd	r31, Y+2	; 0x02
    48ae:	92 83       	std	Z+2, r25	; 0x02
    48b0:	81 83       	std	Z+1, r24	; 0x01
    48b2:	e9 81       	ldd	r30, Y+1	; 0x01
    48b4:	fa 81       	ldd	r31, Y+2	; 0x02
    48b6:	01 80       	ldd	r0, Z+1	; 0x01
    48b8:	f2 81       	ldd	r31, Z+2	; 0x02
    48ba:	e0 2d       	mov	r30, r0
    48bc:	86 81       	ldd	r24, Z+6	; 0x06
    48be:	97 81       	ldd	r25, Z+7	; 0x07
    48c0:	90 93 d7 01 	sts	0x01D7, r25
    48c4:	80 93 d6 01 	sts	0x01D6, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    48c8:	e0 91 d6 01 	lds	r30, 0x01D6
    48cc:	f0 91 d7 01 	lds	r31, 0x01D7
    48d0:	40 81       	ld	r20, Z
    48d2:	51 81       	ldd	r21, Z+1	; 0x01
    48d4:	80 91 d6 01 	lds	r24, 0x01D6
    48d8:	90 91 d7 01 	lds	r25, 0x01D7
    48dc:	e0 91 d6 01 	lds	r30, 0x01D6
    48e0:	f0 91 d7 01 	lds	r31, 0x01D7
    48e4:	27 89       	ldd	r18, Z+23	; 0x17
    48e6:	62 2f       	mov	r22, r18
    48e8:	fa 01       	movw	r30, r20
    48ea:	09 95       	icall

	return;
}
    48ec:	0f 90       	pop	r0
    48ee:	0f 90       	pop	r0
    48f0:	cf 91       	pop	r28
    48f2:	df 91       	pop	r29
    48f4:	08 95       	ret

000048f6 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    48f6:	df 93       	push	r29
    48f8:	cf 93       	push	r28
    48fa:	0f 92       	push	r0
    48fc:	cd b7       	in	r28, 0x3d	; 61
    48fe:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    4900:	19 82       	std	Y+1, r1	; 0x01
    4902:	13 c0       	rjmp	.+38     	; 0x492a <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    4904:	89 81       	ldd	r24, Y+1	; 0x01
    4906:	28 2f       	mov	r18, r24
    4908:	30 e0       	ldi	r19, 0x00	; 0
    490a:	c9 01       	movw	r24, r18
    490c:	88 0f       	add	r24, r24
    490e:	99 1f       	adc	r25, r25
    4910:	88 0f       	add	r24, r24
    4912:	99 1f       	adc	r25, r25
    4914:	88 0f       	add	r24, r24
    4916:	99 1f       	adc	r25, r25
    4918:	82 0f       	add	r24, r18
    491a:	93 1f       	adc	r25, r19
    491c:	81 52       	subi	r24, 0x21	; 33
    491e:	9e 4f       	sbci	r25, 0xFE	; 254
    4920:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    4924:	89 81       	ldd	r24, Y+1	; 0x01
    4926:	8f 5f       	subi	r24, 0xFF	; 255
    4928:	89 83       	std	Y+1, r24	; 0x01
    492a:	89 81       	ldd	r24, Y+1	; 0x01
    492c:	82 30       	cpi	r24, 0x02	; 2
    492e:	50 f3       	brcs	.-44     	; 0x4904 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    4930:	81 ef       	ldi	r24, 0xF1	; 241
    4932:	91 e0       	ldi	r25, 0x01	; 1
    4934:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    4938:	8a ef       	ldi	r24, 0xFA	; 250
    493a:	91 e0       	ldi	r25, 0x01	; 1
    493c:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    4940:	87 e0       	ldi	r24, 0x07	; 7
    4942:	92 e0       	ldi	r25, 0x02	; 2
    4944:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    4948:	81 ef       	ldi	r24, 0xF1	; 241
    494a:	91 e0       	ldi	r25, 0x01	; 1
    494c:	90 93 04 02 	sts	0x0204, r25
    4950:	80 93 03 02 	sts	0x0203, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    4954:	8a ef       	ldi	r24, 0xFA	; 250
    4956:	91 e0       	ldi	r25, 0x01	; 1
    4958:	90 93 06 02 	sts	0x0206, r25
    495c:	80 93 05 02 	sts	0x0205, r24
}
    4960:	0f 90       	pop	r0
    4962:	cf 91       	pop	r28
    4964:	df 91       	pop	r29
    4966:	08 95       	ret

00004968 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    4968:	df 93       	push	r29
    496a:	cf 93       	push	r28
    496c:	00 d0       	rcall	.+0      	; 0x496e <xCoRoutineRemoveFromEventList+0x6>
    496e:	00 d0       	rcall	.+0      	; 0x4970 <xCoRoutineRemoveFromEventList+0x8>
    4970:	0f 92       	push	r0
    4972:	cd b7       	in	r28, 0x3d	; 61
    4974:	de b7       	in	r29, 0x3e	; 62
    4976:	9d 83       	std	Y+5, r25	; 0x05
    4978:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    497a:	ec 81       	ldd	r30, Y+4	; 0x04
    497c:	fd 81       	ldd	r31, Y+5	; 0x05
    497e:	05 80       	ldd	r0, Z+5	; 0x05
    4980:	f6 81       	ldd	r31, Z+6	; 0x06
    4982:	e0 2d       	mov	r30, r0
    4984:	86 81       	ldd	r24, Z+6	; 0x06
    4986:	97 81       	ldd	r25, Z+7	; 0x07
    4988:	9b 83       	std	Y+3, r25	; 0x03
    498a:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    498c:	8a 81       	ldd	r24, Y+2	; 0x02
    498e:	9b 81       	ldd	r25, Y+3	; 0x03
    4990:	0c 96       	adiw	r24, 0x0c	; 12
    4992:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    4996:	8a 81       	ldd	r24, Y+2	; 0x02
    4998:	9b 81       	ldd	r25, Y+3	; 0x03
    499a:	9c 01       	movw	r18, r24
    499c:	24 5f       	subi	r18, 0xF4	; 244
    499e:	3f 4f       	sbci	r19, 0xFF	; 255
    49a0:	87 e0       	ldi	r24, 0x07	; 7
    49a2:	92 e0       	ldi	r25, 0x02	; 2
    49a4:	b9 01       	movw	r22, r18
    49a6:	0e 94 92 25 	call	0x4b24	; 0x4b24 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    49aa:	ea 81       	ldd	r30, Y+2	; 0x02
    49ac:	fb 81       	ldd	r31, Y+3	; 0x03
    49ae:	96 89       	ldd	r25, Z+22	; 0x16
    49b0:	e0 91 d6 01 	lds	r30, 0x01D6
    49b4:	f0 91 d7 01 	lds	r31, 0x01D7
    49b8:	86 89       	ldd	r24, Z+22	; 0x16
    49ba:	98 17       	cp	r25, r24
    49bc:	18 f0       	brcs	.+6      	; 0x49c4 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    49be:	81 e0       	ldi	r24, 0x01	; 1
    49c0:	89 83       	std	Y+1, r24	; 0x01
    49c2:	01 c0       	rjmp	.+2      	; 0x49c6 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    49c4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    49c6:	89 81       	ldd	r24, Y+1	; 0x01
}
    49c8:	0f 90       	pop	r0
    49ca:	0f 90       	pop	r0
    49cc:	0f 90       	pop	r0
    49ce:	0f 90       	pop	r0
    49d0:	0f 90       	pop	r0
    49d2:	cf 91       	pop	r28
    49d4:	df 91       	pop	r29
    49d6:	08 95       	ret

000049d8 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    49d8:	df 93       	push	r29
    49da:	cf 93       	push	r28
    49dc:	00 d0       	rcall	.+0      	; 0x49de <pvPortMalloc+0x6>
    49de:	00 d0       	rcall	.+0      	; 0x49e0 <pvPortMalloc+0x8>
    49e0:	cd b7       	in	r28, 0x3d	; 61
    49e2:	de b7       	in	r29, 0x3e	; 62
    49e4:	9c 83       	std	Y+4, r25	; 0x04
    49e6:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    49e8:	1a 82       	std	Y+2, r1	; 0x02
    49ea:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    49ec:	0e 94 ca 30 	call	0x6194	; 0x6194 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    49f0:	80 91 10 02 	lds	r24, 0x0210
    49f4:	90 91 11 02 	lds	r25, 0x0211
    49f8:	2b 81       	ldd	r18, Y+3	; 0x03
    49fa:	3c 81       	ldd	r19, Y+4	; 0x04
    49fc:	82 0f       	add	r24, r18
    49fe:	93 1f       	adc	r25, r19
    4a00:	23 e0       	ldi	r18, 0x03	; 3
    4a02:	88 3e       	cpi	r24, 0xE8	; 232
    4a04:	92 07       	cpc	r25, r18
    4a06:	18 f5       	brcc	.+70     	; 0x4a4e <pvPortMalloc+0x76>
    4a08:	20 91 10 02 	lds	r18, 0x0210
    4a0c:	30 91 11 02 	lds	r19, 0x0211
    4a10:	8b 81       	ldd	r24, Y+3	; 0x03
    4a12:	9c 81       	ldd	r25, Y+4	; 0x04
    4a14:	28 0f       	add	r18, r24
    4a16:	39 1f       	adc	r19, r25
    4a18:	80 91 10 02 	lds	r24, 0x0210
    4a1c:	90 91 11 02 	lds	r25, 0x0211
    4a20:	82 17       	cp	r24, r18
    4a22:	93 07       	cpc	r25, r19
    4a24:	a0 f4       	brcc	.+40     	; 0x4a4e <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    4a26:	80 91 10 02 	lds	r24, 0x0210
    4a2a:	90 91 11 02 	lds	r25, 0x0211
    4a2e:	8e 5e       	subi	r24, 0xEE	; 238
    4a30:	9d 4f       	sbci	r25, 0xFD	; 253
    4a32:	9a 83       	std	Y+2, r25	; 0x02
    4a34:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    4a36:	20 91 10 02 	lds	r18, 0x0210
    4a3a:	30 91 11 02 	lds	r19, 0x0211
    4a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    4a40:	9c 81       	ldd	r25, Y+4	; 0x04
    4a42:	82 0f       	add	r24, r18
    4a44:	93 1f       	adc	r25, r19
    4a46:	90 93 11 02 	sts	0x0211, r25
    4a4a:	80 93 10 02 	sts	0x0210, r24
		}	
	}
	xTaskResumeAll();
    4a4e:	0e 94 d6 30 	call	0x61ac	; 0x61ac <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    4a52:	89 81       	ldd	r24, Y+1	; 0x01
    4a54:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4a56:	0f 90       	pop	r0
    4a58:	0f 90       	pop	r0
    4a5a:	0f 90       	pop	r0
    4a5c:	0f 90       	pop	r0
    4a5e:	cf 91       	pop	r28
    4a60:	df 91       	pop	r29
    4a62:	08 95       	ret

00004a64 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    4a64:	df 93       	push	r29
    4a66:	cf 93       	push	r28
    4a68:	00 d0       	rcall	.+0      	; 0x4a6a <vPortFree+0x6>
    4a6a:	cd b7       	in	r28, 0x3d	; 61
    4a6c:	de b7       	in	r29, 0x3e	; 62
    4a6e:	9a 83       	std	Y+2, r25	; 0x02
    4a70:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    4a72:	0f 90       	pop	r0
    4a74:	0f 90       	pop	r0
    4a76:	cf 91       	pop	r28
    4a78:	df 91       	pop	r29
    4a7a:	08 95       	ret

00004a7c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    4a7c:	df 93       	push	r29
    4a7e:	cf 93       	push	r28
    4a80:	cd b7       	in	r28, 0x3d	; 61
    4a82:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    4a84:	10 92 11 02 	sts	0x0211, r1
    4a88:	10 92 10 02 	sts	0x0210, r1
}
    4a8c:	cf 91       	pop	r28
    4a8e:	df 91       	pop	r29
    4a90:	08 95       	ret

00004a92 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    4a92:	df 93       	push	r29
    4a94:	cf 93       	push	r28
    4a96:	cd b7       	in	r28, 0x3d	; 61
    4a98:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    4a9a:	20 91 10 02 	lds	r18, 0x0210
    4a9e:	30 91 11 02 	lds	r19, 0x0211
    4aa2:	88 ee       	ldi	r24, 0xE8	; 232
    4aa4:	93 e0       	ldi	r25, 0x03	; 3
    4aa6:	82 1b       	sub	r24, r18
    4aa8:	93 0b       	sbc	r25, r19
}
    4aaa:	cf 91       	pop	r28
    4aac:	df 91       	pop	r29
    4aae:	08 95       	ret

00004ab0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    4ab0:	df 93       	push	r29
    4ab2:	cf 93       	push	r28
    4ab4:	00 d0       	rcall	.+0      	; 0x4ab6 <vListInitialise+0x6>
    4ab6:	cd b7       	in	r28, 0x3d	; 61
    4ab8:	de b7       	in	r29, 0x3e	; 62
    4aba:	9a 83       	std	Y+2, r25	; 0x02
    4abc:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    4abe:	89 81       	ldd	r24, Y+1	; 0x01
    4ac0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ac2:	03 96       	adiw	r24, 0x03	; 3
    4ac4:	e9 81       	ldd	r30, Y+1	; 0x01
    4ac6:	fa 81       	ldd	r31, Y+2	; 0x02
    4ac8:	92 83       	std	Z+2, r25	; 0x02
    4aca:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    4acc:	e9 81       	ldd	r30, Y+1	; 0x01
    4ace:	fa 81       	ldd	r31, Y+2	; 0x02
    4ad0:	8f ef       	ldi	r24, 0xFF	; 255
    4ad2:	9f ef       	ldi	r25, 0xFF	; 255
    4ad4:	94 83       	std	Z+4, r25	; 0x04
    4ad6:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    4ad8:	89 81       	ldd	r24, Y+1	; 0x01
    4ada:	9a 81       	ldd	r25, Y+2	; 0x02
    4adc:	03 96       	adiw	r24, 0x03	; 3
    4ade:	e9 81       	ldd	r30, Y+1	; 0x01
    4ae0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ae2:	96 83       	std	Z+6, r25	; 0x06
    4ae4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    4ae6:	89 81       	ldd	r24, Y+1	; 0x01
    4ae8:	9a 81       	ldd	r25, Y+2	; 0x02
    4aea:	03 96       	adiw	r24, 0x03	; 3
    4aec:	e9 81       	ldd	r30, Y+1	; 0x01
    4aee:	fa 81       	ldd	r31, Y+2	; 0x02
    4af0:	90 87       	std	Z+8, r25	; 0x08
    4af2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    4af4:	e9 81       	ldd	r30, Y+1	; 0x01
    4af6:	fa 81       	ldd	r31, Y+2	; 0x02
    4af8:	10 82       	st	Z, r1
}
    4afa:	0f 90       	pop	r0
    4afc:	0f 90       	pop	r0
    4afe:	cf 91       	pop	r28
    4b00:	df 91       	pop	r29
    4b02:	08 95       	ret

00004b04 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    4b04:	df 93       	push	r29
    4b06:	cf 93       	push	r28
    4b08:	00 d0       	rcall	.+0      	; 0x4b0a <vListInitialiseItem+0x6>
    4b0a:	cd b7       	in	r28, 0x3d	; 61
    4b0c:	de b7       	in	r29, 0x3e	; 62
    4b0e:	9a 83       	std	Y+2, r25	; 0x02
    4b10:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    4b12:	e9 81       	ldd	r30, Y+1	; 0x01
    4b14:	fa 81       	ldd	r31, Y+2	; 0x02
    4b16:	11 86       	std	Z+9, r1	; 0x09
    4b18:	10 86       	std	Z+8, r1	; 0x08
}
    4b1a:	0f 90       	pop	r0
    4b1c:	0f 90       	pop	r0
    4b1e:	cf 91       	pop	r28
    4b20:	df 91       	pop	r29
    4b22:	08 95       	ret

00004b24 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    4b24:	df 93       	push	r29
    4b26:	cf 93       	push	r28
    4b28:	00 d0       	rcall	.+0      	; 0x4b2a <vListInsertEnd+0x6>
    4b2a:	00 d0       	rcall	.+0      	; 0x4b2c <vListInsertEnd+0x8>
    4b2c:	00 d0       	rcall	.+0      	; 0x4b2e <vListInsertEnd+0xa>
    4b2e:	cd b7       	in	r28, 0x3d	; 61
    4b30:	de b7       	in	r29, 0x3e	; 62
    4b32:	9c 83       	std	Y+4, r25	; 0x04
    4b34:	8b 83       	std	Y+3, r24	; 0x03
    4b36:	7e 83       	std	Y+6, r23	; 0x06
    4b38:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    4b3a:	eb 81       	ldd	r30, Y+3	; 0x03
    4b3c:	fc 81       	ldd	r31, Y+4	; 0x04
    4b3e:	81 81       	ldd	r24, Z+1	; 0x01
    4b40:	92 81       	ldd	r25, Z+2	; 0x02
    4b42:	9a 83       	std	Y+2, r25	; 0x02
    4b44:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    4b46:	e9 81       	ldd	r30, Y+1	; 0x01
    4b48:	fa 81       	ldd	r31, Y+2	; 0x02
    4b4a:	82 81       	ldd	r24, Z+2	; 0x02
    4b4c:	93 81       	ldd	r25, Z+3	; 0x03
    4b4e:	ed 81       	ldd	r30, Y+5	; 0x05
    4b50:	fe 81       	ldd	r31, Y+6	; 0x06
    4b52:	93 83       	std	Z+3, r25	; 0x03
    4b54:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    4b56:	eb 81       	ldd	r30, Y+3	; 0x03
    4b58:	fc 81       	ldd	r31, Y+4	; 0x04
    4b5a:	81 81       	ldd	r24, Z+1	; 0x01
    4b5c:	92 81       	ldd	r25, Z+2	; 0x02
    4b5e:	ed 81       	ldd	r30, Y+5	; 0x05
    4b60:	fe 81       	ldd	r31, Y+6	; 0x06
    4b62:	95 83       	std	Z+5, r25	; 0x05
    4b64:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    4b66:	e9 81       	ldd	r30, Y+1	; 0x01
    4b68:	fa 81       	ldd	r31, Y+2	; 0x02
    4b6a:	02 80       	ldd	r0, Z+2	; 0x02
    4b6c:	f3 81       	ldd	r31, Z+3	; 0x03
    4b6e:	e0 2d       	mov	r30, r0
    4b70:	8d 81       	ldd	r24, Y+5	; 0x05
    4b72:	9e 81       	ldd	r25, Y+6	; 0x06
    4b74:	95 83       	std	Z+5, r25	; 0x05
    4b76:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    4b78:	8d 81       	ldd	r24, Y+5	; 0x05
    4b7a:	9e 81       	ldd	r25, Y+6	; 0x06
    4b7c:	e9 81       	ldd	r30, Y+1	; 0x01
    4b7e:	fa 81       	ldd	r31, Y+2	; 0x02
    4b80:	93 83       	std	Z+3, r25	; 0x03
    4b82:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    4b84:	8d 81       	ldd	r24, Y+5	; 0x05
    4b86:	9e 81       	ldd	r25, Y+6	; 0x06
    4b88:	eb 81       	ldd	r30, Y+3	; 0x03
    4b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    4b8c:	92 83       	std	Z+2, r25	; 0x02
    4b8e:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4b90:	ed 81       	ldd	r30, Y+5	; 0x05
    4b92:	fe 81       	ldd	r31, Y+6	; 0x06
    4b94:	8b 81       	ldd	r24, Y+3	; 0x03
    4b96:	9c 81       	ldd	r25, Y+4	; 0x04
    4b98:	91 87       	std	Z+9, r25	; 0x09
    4b9a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    4b9c:	eb 81       	ldd	r30, Y+3	; 0x03
    4b9e:	fc 81       	ldd	r31, Y+4	; 0x04
    4ba0:	80 81       	ld	r24, Z
    4ba2:	8f 5f       	subi	r24, 0xFF	; 255
    4ba4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ba6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ba8:	80 83       	st	Z, r24
}
    4baa:	26 96       	adiw	r28, 0x06	; 6
    4bac:	0f b6       	in	r0, 0x3f	; 63
    4bae:	f8 94       	cli
    4bb0:	de bf       	out	0x3e, r29	; 62
    4bb2:	0f be       	out	0x3f, r0	; 63
    4bb4:	cd bf       	out	0x3d, r28	; 61
    4bb6:	cf 91       	pop	r28
    4bb8:	df 91       	pop	r29
    4bba:	08 95       	ret

00004bbc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    4bbc:	df 93       	push	r29
    4bbe:	cf 93       	push	r28
    4bc0:	cd b7       	in	r28, 0x3d	; 61
    4bc2:	de b7       	in	r29, 0x3e	; 62
    4bc4:	28 97       	sbiw	r28, 0x08	; 8
    4bc6:	0f b6       	in	r0, 0x3f	; 63
    4bc8:	f8 94       	cli
    4bca:	de bf       	out	0x3e, r29	; 62
    4bcc:	0f be       	out	0x3f, r0	; 63
    4bce:	cd bf       	out	0x3d, r28	; 61
    4bd0:	9e 83       	std	Y+6, r25	; 0x06
    4bd2:	8d 83       	std	Y+5, r24	; 0x05
    4bd4:	78 87       	std	Y+8, r23	; 0x08
    4bd6:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    4bd8:	ef 81       	ldd	r30, Y+7	; 0x07
    4bda:	f8 85       	ldd	r31, Y+8	; 0x08
    4bdc:	80 81       	ld	r24, Z
    4bde:	91 81       	ldd	r25, Z+1	; 0x01
    4be0:	9a 83       	std	Y+2, r25	; 0x02
    4be2:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    4be4:	89 81       	ldd	r24, Y+1	; 0x01
    4be6:	9a 81       	ldd	r25, Y+2	; 0x02
    4be8:	2f ef       	ldi	r18, 0xFF	; 255
    4bea:	8f 3f       	cpi	r24, 0xFF	; 255
    4bec:	92 07       	cpc	r25, r18
    4bee:	39 f4       	brne	.+14     	; 0x4bfe <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    4bf0:	ed 81       	ldd	r30, Y+5	; 0x05
    4bf2:	fe 81       	ldd	r31, Y+6	; 0x06
    4bf4:	87 81       	ldd	r24, Z+7	; 0x07
    4bf6:	90 85       	ldd	r25, Z+8	; 0x08
    4bf8:	9c 83       	std	Y+4, r25	; 0x04
    4bfa:	8b 83       	std	Y+3, r24	; 0x03
    4bfc:	18 c0       	rjmp	.+48     	; 0x4c2e <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    4bfe:	8d 81       	ldd	r24, Y+5	; 0x05
    4c00:	9e 81       	ldd	r25, Y+6	; 0x06
    4c02:	03 96       	adiw	r24, 0x03	; 3
    4c04:	9c 83       	std	Y+4, r25	; 0x04
    4c06:	8b 83       	std	Y+3, r24	; 0x03
    4c08:	06 c0       	rjmp	.+12     	; 0x4c16 <vListInsert+0x5a>
    4c0a:	eb 81       	ldd	r30, Y+3	; 0x03
    4c0c:	fc 81       	ldd	r31, Y+4	; 0x04
    4c0e:	82 81       	ldd	r24, Z+2	; 0x02
    4c10:	93 81       	ldd	r25, Z+3	; 0x03
    4c12:	9c 83       	std	Y+4, r25	; 0x04
    4c14:	8b 83       	std	Y+3, r24	; 0x03
    4c16:	eb 81       	ldd	r30, Y+3	; 0x03
    4c18:	fc 81       	ldd	r31, Y+4	; 0x04
    4c1a:	02 80       	ldd	r0, Z+2	; 0x02
    4c1c:	f3 81       	ldd	r31, Z+3	; 0x03
    4c1e:	e0 2d       	mov	r30, r0
    4c20:	20 81       	ld	r18, Z
    4c22:	31 81       	ldd	r19, Z+1	; 0x01
    4c24:	89 81       	ldd	r24, Y+1	; 0x01
    4c26:	9a 81       	ldd	r25, Y+2	; 0x02
    4c28:	82 17       	cp	r24, r18
    4c2a:	93 07       	cpc	r25, r19
    4c2c:	70 f7       	brcc	.-36     	; 0x4c0a <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    4c2e:	eb 81       	ldd	r30, Y+3	; 0x03
    4c30:	fc 81       	ldd	r31, Y+4	; 0x04
    4c32:	82 81       	ldd	r24, Z+2	; 0x02
    4c34:	93 81       	ldd	r25, Z+3	; 0x03
    4c36:	ef 81       	ldd	r30, Y+7	; 0x07
    4c38:	f8 85       	ldd	r31, Y+8	; 0x08
    4c3a:	93 83       	std	Z+3, r25	; 0x03
    4c3c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    4c3e:	ef 81       	ldd	r30, Y+7	; 0x07
    4c40:	f8 85       	ldd	r31, Y+8	; 0x08
    4c42:	02 80       	ldd	r0, Z+2	; 0x02
    4c44:	f3 81       	ldd	r31, Z+3	; 0x03
    4c46:	e0 2d       	mov	r30, r0
    4c48:	8f 81       	ldd	r24, Y+7	; 0x07
    4c4a:	98 85       	ldd	r25, Y+8	; 0x08
    4c4c:	95 83       	std	Z+5, r25	; 0x05
    4c4e:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    4c50:	ef 81       	ldd	r30, Y+7	; 0x07
    4c52:	f8 85       	ldd	r31, Y+8	; 0x08
    4c54:	8b 81       	ldd	r24, Y+3	; 0x03
    4c56:	9c 81       	ldd	r25, Y+4	; 0x04
    4c58:	95 83       	std	Z+5, r25	; 0x05
    4c5a:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    4c5c:	8f 81       	ldd	r24, Y+7	; 0x07
    4c5e:	98 85       	ldd	r25, Y+8	; 0x08
    4c60:	eb 81       	ldd	r30, Y+3	; 0x03
    4c62:	fc 81       	ldd	r31, Y+4	; 0x04
    4c64:	93 83       	std	Z+3, r25	; 0x03
    4c66:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4c68:	ef 81       	ldd	r30, Y+7	; 0x07
    4c6a:	f8 85       	ldd	r31, Y+8	; 0x08
    4c6c:	8d 81       	ldd	r24, Y+5	; 0x05
    4c6e:	9e 81       	ldd	r25, Y+6	; 0x06
    4c70:	91 87       	std	Z+9, r25	; 0x09
    4c72:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    4c74:	ed 81       	ldd	r30, Y+5	; 0x05
    4c76:	fe 81       	ldd	r31, Y+6	; 0x06
    4c78:	80 81       	ld	r24, Z
    4c7a:	8f 5f       	subi	r24, 0xFF	; 255
    4c7c:	ed 81       	ldd	r30, Y+5	; 0x05
    4c7e:	fe 81       	ldd	r31, Y+6	; 0x06
    4c80:	80 83       	st	Z, r24
}
    4c82:	28 96       	adiw	r28, 0x08	; 8
    4c84:	0f b6       	in	r0, 0x3f	; 63
    4c86:	f8 94       	cli
    4c88:	de bf       	out	0x3e, r29	; 62
    4c8a:	0f be       	out	0x3f, r0	; 63
    4c8c:	cd bf       	out	0x3d, r28	; 61
    4c8e:	cf 91       	pop	r28
    4c90:	df 91       	pop	r29
    4c92:	08 95       	ret

00004c94 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    4c94:	df 93       	push	r29
    4c96:	cf 93       	push	r28
    4c98:	00 d0       	rcall	.+0      	; 0x4c9a <vListRemove+0x6>
    4c9a:	00 d0       	rcall	.+0      	; 0x4c9c <vListRemove+0x8>
    4c9c:	cd b7       	in	r28, 0x3d	; 61
    4c9e:	de b7       	in	r29, 0x3e	; 62
    4ca0:	9c 83       	std	Y+4, r25	; 0x04
    4ca2:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    4ca4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ca6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ca8:	a2 81       	ldd	r26, Z+2	; 0x02
    4caa:	b3 81       	ldd	r27, Z+3	; 0x03
    4cac:	eb 81       	ldd	r30, Y+3	; 0x03
    4cae:	fc 81       	ldd	r31, Y+4	; 0x04
    4cb0:	84 81       	ldd	r24, Z+4	; 0x04
    4cb2:	95 81       	ldd	r25, Z+5	; 0x05
    4cb4:	15 96       	adiw	r26, 0x05	; 5
    4cb6:	9c 93       	st	X, r25
    4cb8:	8e 93       	st	-X, r24
    4cba:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    4cbc:	eb 81       	ldd	r30, Y+3	; 0x03
    4cbe:	fc 81       	ldd	r31, Y+4	; 0x04
    4cc0:	a4 81       	ldd	r26, Z+4	; 0x04
    4cc2:	b5 81       	ldd	r27, Z+5	; 0x05
    4cc4:	eb 81       	ldd	r30, Y+3	; 0x03
    4cc6:	fc 81       	ldd	r31, Y+4	; 0x04
    4cc8:	82 81       	ldd	r24, Z+2	; 0x02
    4cca:	93 81       	ldd	r25, Z+3	; 0x03
    4ccc:	13 96       	adiw	r26, 0x03	; 3
    4cce:	9c 93       	st	X, r25
    4cd0:	8e 93       	st	-X, r24
    4cd2:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    4cd4:	eb 81       	ldd	r30, Y+3	; 0x03
    4cd6:	fc 81       	ldd	r31, Y+4	; 0x04
    4cd8:	80 85       	ldd	r24, Z+8	; 0x08
    4cda:	91 85       	ldd	r25, Z+9	; 0x09
    4cdc:	9a 83       	std	Y+2, r25	; 0x02
    4cde:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    4ce0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ce2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ce4:	21 81       	ldd	r18, Z+1	; 0x01
    4ce6:	32 81       	ldd	r19, Z+2	; 0x02
    4ce8:	8b 81       	ldd	r24, Y+3	; 0x03
    4cea:	9c 81       	ldd	r25, Y+4	; 0x04
    4cec:	28 17       	cp	r18, r24
    4cee:	39 07       	cpc	r19, r25
    4cf0:	41 f4       	brne	.+16     	; 0x4d02 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    4cf2:	eb 81       	ldd	r30, Y+3	; 0x03
    4cf4:	fc 81       	ldd	r31, Y+4	; 0x04
    4cf6:	84 81       	ldd	r24, Z+4	; 0x04
    4cf8:	95 81       	ldd	r25, Z+5	; 0x05
    4cfa:	e9 81       	ldd	r30, Y+1	; 0x01
    4cfc:	fa 81       	ldd	r31, Y+2	; 0x02
    4cfe:	92 83       	std	Z+2, r25	; 0x02
    4d00:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    4d02:	eb 81       	ldd	r30, Y+3	; 0x03
    4d04:	fc 81       	ldd	r31, Y+4	; 0x04
    4d06:	11 86       	std	Z+9, r1	; 0x09
    4d08:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    4d0a:	e9 81       	ldd	r30, Y+1	; 0x01
    4d0c:	fa 81       	ldd	r31, Y+2	; 0x02
    4d0e:	80 81       	ld	r24, Z
    4d10:	81 50       	subi	r24, 0x01	; 1
    4d12:	e9 81       	ldd	r30, Y+1	; 0x01
    4d14:	fa 81       	ldd	r31, Y+2	; 0x02
    4d16:	80 83       	st	Z, r24
}
    4d18:	0f 90       	pop	r0
    4d1a:	0f 90       	pop	r0
    4d1c:	0f 90       	pop	r0
    4d1e:	0f 90       	pop	r0
    4d20:	cf 91       	pop	r28
    4d22:	df 91       	pop	r29
    4d24:	08 95       	ret

00004d26 <main>:
/* create global semphaor*/

xSemaphoreHandle App_LCDSemph;

int main (void)
{
    4d26:	af 92       	push	r10
    4d28:	bf 92       	push	r11
    4d2a:	cf 92       	push	r12
    4d2c:	df 92       	push	r13
    4d2e:	ef 92       	push	r14
    4d30:	ff 92       	push	r15
    4d32:	0f 93       	push	r16
    4d34:	df 93       	push	r29
    4d36:	cf 93       	push	r28
    4d38:	cd b7       	in	r28, 0x3d	; 61
    4d3a:	de b7       	in	r29, 0x3e	; 62

	DIO_VoidInit();
    4d3c:	0e 94 17 07 	call	0xe2e	; 0xe2e <DIO_VoidInit>
	LCD_VoidInit4bit();
    4d40:	0e 94 6e 17 	call	0x2edc	; 0x2edc <LCD_VoidInit4bit>
    /* create semaphor */
    vSemaphoreCreateBinary(App_LCDSemph);
    4d44:	81 e0       	ldi	r24, 0x01	; 1
    4d46:	60 e0       	ldi	r22, 0x00	; 0
    4d48:	0e 94 0d 2a 	call	0x541a	; 0x541a <xQueueCreate>
    4d4c:	90 93 5e 06 	sts	0x065E, r25
    4d50:	80 93 5d 06 	sts	0x065D, r24
    4d54:	80 91 5d 06 	lds	r24, 0x065D
    4d58:	90 91 5e 06 	lds	r25, 0x065E
    4d5c:	00 97       	sbiw	r24, 0x00	; 0
    4d5e:	59 f0       	breq	.+22     	; 0x4d76 <main+0x50>
    4d60:	80 91 5d 06 	lds	r24, 0x065D
    4d64:	90 91 5e 06 	lds	r25, 0x065E
    4d68:	60 e0       	ldi	r22, 0x00	; 0
    4d6a:	70 e0       	ldi	r23, 0x00	; 0
    4d6c:	40 e0       	ldi	r20, 0x00	; 0
    4d6e:	50 e0       	ldi	r21, 0x00	; 0
    4d70:	20 e0       	ldi	r18, 0x00	; 0
    4d72:	0e 94 b6 2a 	call	0x556c	; 0x556c <xQueueGenericSend>

   xTaskCreate(&App_VoidTask1,NULL,200,NULL,1,NULL);
    4d76:	8b ee       	ldi	r24, 0xEB	; 235
    4d78:	96 e2       	ldi	r25, 0x26	; 38
    4d7a:	60 e0       	ldi	r22, 0x00	; 0
    4d7c:	70 e0       	ldi	r23, 0x00	; 0
    4d7e:	48 ec       	ldi	r20, 0xC8	; 200
    4d80:	50 e0       	ldi	r21, 0x00	; 0
    4d82:	20 e0       	ldi	r18, 0x00	; 0
    4d84:	30 e0       	ldi	r19, 0x00	; 0
    4d86:	01 e0       	ldi	r16, 0x01	; 1
    4d88:	ee 24       	eor	r14, r14
    4d8a:	ff 24       	eor	r15, r15
    4d8c:	cc 24       	eor	r12, r12
    4d8e:	dd 24       	eor	r13, r13
    4d90:	aa 24       	eor	r10, r10
    4d92:	bb 24       	eor	r11, r11
    4d94:	0e 94 8e 2e 	call	0x5d1c	; 0x5d1c <xTaskGenericCreate>
   xTaskCreate(&App_VoidTask2,NULL,200,NULL,1,NULL);
    4d98:	83 e1       	ldi	r24, 0x13	; 19
    4d9a:	97 e2       	ldi	r25, 0x27	; 39
    4d9c:	60 e0       	ldi	r22, 0x00	; 0
    4d9e:	70 e0       	ldi	r23, 0x00	; 0
    4da0:	48 ec       	ldi	r20, 0xC8	; 200
    4da2:	50 e0       	ldi	r21, 0x00	; 0
    4da4:	20 e0       	ldi	r18, 0x00	; 0
    4da6:	30 e0       	ldi	r19, 0x00	; 0
    4da8:	01 e0       	ldi	r16, 0x01	; 1
    4daa:	ee 24       	eor	r14, r14
    4dac:	ff 24       	eor	r15, r15
    4dae:	cc 24       	eor	r12, r12
    4db0:	dd 24       	eor	r13, r13
    4db2:	aa 24       	eor	r10, r10
    4db4:	bb 24       	eor	r11, r11
    4db6:	0e 94 8e 2e 	call	0x5d1c	; 0x5d1c <xTaskGenericCreate>


   vTaskStartScheduler();
    4dba:	0e 94 87 30 	call	0x610e	; 0x610e <vTaskStartScheduler>
return 0;
    4dbe:	80 e0       	ldi	r24, 0x00	; 0
    4dc0:	90 e0       	ldi	r25, 0x00	; 0
}
    4dc2:	cf 91       	pop	r28
    4dc4:	df 91       	pop	r29
    4dc6:	0f 91       	pop	r16
    4dc8:	ff 90       	pop	r15
    4dca:	ef 90       	pop	r14
    4dcc:	df 90       	pop	r13
    4dce:	cf 90       	pop	r12
    4dd0:	bf 90       	pop	r11
    4dd2:	af 90       	pop	r10
    4dd4:	08 95       	ret

00004dd6 <App_VoidTask1>:

Void  App_VoidTask1(Void * Copy_Pv)
{
    4dd6:	df 93       	push	r29
    4dd8:	cf 93       	push	r28
    4dda:	00 d0       	rcall	.+0      	; 0x4ddc <App_VoidTask1+0x6>
    4ddc:	cd b7       	in	r28, 0x3d	; 61
    4dde:	de b7       	in	r29, 0x3e	; 62
    4de0:	9a 83       	std	Y+2, r25	; 0x02
    4de2:	89 83       	std	Y+1, r24	; 0x01

     while(TRUE)
     {
    	if(xSemaphoreTake(App_LCDSemph,portMAX_DELAY)== pdTRUE)
    4de4:	80 91 5d 06 	lds	r24, 0x065D
    4de8:	90 91 5e 06 	lds	r25, 0x065E
    4dec:	60 e0       	ldi	r22, 0x00	; 0
    4dee:	70 e0       	ldi	r23, 0x00	; 0
    4df0:	4f ef       	ldi	r20, 0xFF	; 255
    4df2:	5f ef       	ldi	r21, 0xFF	; 255
    4df4:	20 e0       	ldi	r18, 0x00	; 0
    4df6:	0e 94 a1 2b 	call	0x5742	; 0x5742 <xQueueGenericReceive>
    4dfa:	81 30       	cpi	r24, 0x01	; 1
    4dfc:	99 f7       	brne	.-26     	; 0x4de4 <App_VoidTask1+0xe>
    	{

    		LCD_CheckStatusWriteString("I AM TASK1");
    4dfe:	80 e6       	ldi	r24, 0x60	; 96
    4e00:	90 e0       	ldi	r25, 0x00	; 0
    4e02:	0e 94 0e 12 	call	0x241c	; 0x241c <LCD_CheckStatusWriteString>

    		xSemaphoreGive(App_LCDSemph);
    4e06:	80 91 5d 06 	lds	r24, 0x065D
    4e0a:	90 91 5e 06 	lds	r25, 0x065E
    4e0e:	60 e0       	ldi	r22, 0x00	; 0
    4e10:	70 e0       	ldi	r23, 0x00	; 0
    4e12:	40 e0       	ldi	r20, 0x00	; 0
    4e14:	50 e0       	ldi	r21, 0x00	; 0
    4e16:	20 e0       	ldi	r18, 0x00	; 0
    4e18:	0e 94 b6 2a 	call	0x556c	; 0x556c <xQueueGenericSend>

             vTaskDelay(1000);
    4e1c:	88 ee       	ldi	r24, 0xE8	; 232
    4e1e:	93 e0       	ldi	r25, 0x03	; 3
    4e20:	0e 94 52 30 	call	0x60a4	; 0x60a4 <vTaskDelay>
    4e24:	df cf       	rjmp	.-66     	; 0x4de4 <App_VoidTask1+0xe>

00004e26 <App_VoidTask2>:
      }
     }
}

Void  App_VoidTask2(Void * Copy_Pv)
{
    4e26:	df 93       	push	r29
    4e28:	cf 93       	push	r28
    4e2a:	00 d0       	rcall	.+0      	; 0x4e2c <App_VoidTask2+0x6>
    4e2c:	cd b7       	in	r28, 0x3d	; 61
    4e2e:	de b7       	in	r29, 0x3e	; 62
    4e30:	9a 83       	std	Y+2, r25	; 0x02
    4e32:	89 83       	std	Y+1, r24	; 0x01
    while(TRUE)
{

    	if(xSemaphoreTake(App_LCDSemph,portMAX_DELAY)== pdTRUE){
    4e34:	80 91 5d 06 	lds	r24, 0x065D
    4e38:	90 91 5e 06 	lds	r25, 0x065E
    4e3c:	60 e0       	ldi	r22, 0x00	; 0
    4e3e:	70 e0       	ldi	r23, 0x00	; 0
    4e40:	4f ef       	ldi	r20, 0xFF	; 255
    4e42:	5f ef       	ldi	r21, 0xFF	; 255
    4e44:	20 e0       	ldi	r18, 0x00	; 0
    4e46:	0e 94 a1 2b 	call	0x5742	; 0x5742 <xQueueGenericReceive>
    4e4a:	81 30       	cpi	r24, 0x01	; 1
    4e4c:	99 f7       	brne	.-26     	; 0x4e34 <App_VoidTask2+0xe>

    		LCD_CheckStatusWriteString("I AM TASK2");
    4e4e:	8b e6       	ldi	r24, 0x6B	; 107
    4e50:	90 e0       	ldi	r25, 0x00	; 0
    4e52:	0e 94 0e 12 	call	0x241c	; 0x241c <LCD_CheckStatusWriteString>

             xSemaphoreGive(App_LCDSemph);
    4e56:	80 91 5d 06 	lds	r24, 0x065D
    4e5a:	90 91 5e 06 	lds	r25, 0x065E
    4e5e:	60 e0       	ldi	r22, 0x00	; 0
    4e60:	70 e0       	ldi	r23, 0x00	; 0
    4e62:	40 e0       	ldi	r20, 0x00	; 0
    4e64:	50 e0       	ldi	r21, 0x00	; 0
    4e66:	20 e0       	ldi	r18, 0x00	; 0
    4e68:	0e 94 b6 2a 	call	0x556c	; 0x556c <xQueueGenericSend>
    		vTaskDelay(1000);
    4e6c:	88 ee       	ldi	r24, 0xE8	; 232
    4e6e:	93 e0       	ldi	r25, 0x03	; 3
    4e70:	0e 94 52 30 	call	0x60a4	; 0x60a4 <vTaskDelay>
    4e74:	df cf       	rjmp	.-66     	; 0x4e34 <App_VoidTask2+0xe>

00004e76 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    4e76:	df 93       	push	r29
    4e78:	cf 93       	push	r28
    4e7a:	cd b7       	in	r28, 0x3d	; 61
    4e7c:	de b7       	in	r29, 0x3e	; 62
    4e7e:	28 97       	sbiw	r28, 0x08	; 8
    4e80:	0f b6       	in	r0, 0x3f	; 63
    4e82:	f8 94       	cli
    4e84:	de bf       	out	0x3e, r29	; 62
    4e86:	0f be       	out	0x3f, r0	; 63
    4e88:	cd bf       	out	0x3d, r28	; 61
    4e8a:	9c 83       	std	Y+4, r25	; 0x04
    4e8c:	8b 83       	std	Y+3, r24	; 0x03
    4e8e:	7e 83       	std	Y+6, r23	; 0x06
    4e90:	6d 83       	std	Y+5, r22	; 0x05
    4e92:	58 87       	std	Y+8, r21	; 0x08
    4e94:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    4e96:	eb 81       	ldd	r30, Y+3	; 0x03
    4e98:	fc 81       	ldd	r31, Y+4	; 0x04
    4e9a:	81 e1       	ldi	r24, 0x11	; 17
    4e9c:	80 83       	st	Z, r24
	pxTopOfStack--;
    4e9e:	8b 81       	ldd	r24, Y+3	; 0x03
    4ea0:	9c 81       	ldd	r25, Y+4	; 0x04
    4ea2:	01 97       	sbiw	r24, 0x01	; 1
    4ea4:	9c 83       	std	Y+4, r25	; 0x04
    4ea6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    4ea8:	eb 81       	ldd	r30, Y+3	; 0x03
    4eaa:	fc 81       	ldd	r31, Y+4	; 0x04
    4eac:	82 e2       	ldi	r24, 0x22	; 34
    4eae:	80 83       	st	Z, r24
	pxTopOfStack--;
    4eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    4eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    4eb4:	01 97       	sbiw	r24, 0x01	; 1
    4eb6:	9c 83       	std	Y+4, r25	; 0x04
    4eb8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    4eba:	eb 81       	ldd	r30, Y+3	; 0x03
    4ebc:	fc 81       	ldd	r31, Y+4	; 0x04
    4ebe:	83 e3       	ldi	r24, 0x33	; 51
    4ec0:	80 83       	st	Z, r24
	pxTopOfStack--;
    4ec2:	8b 81       	ldd	r24, Y+3	; 0x03
    4ec4:	9c 81       	ldd	r25, Y+4	; 0x04
    4ec6:	01 97       	sbiw	r24, 0x01	; 1
    4ec8:	9c 83       	std	Y+4, r25	; 0x04
    4eca:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    4ecc:	8d 81       	ldd	r24, Y+5	; 0x05
    4ece:	9e 81       	ldd	r25, Y+6	; 0x06
    4ed0:	9a 83       	std	Y+2, r25	; 0x02
    4ed2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    4ed4:	89 81       	ldd	r24, Y+1	; 0x01
    4ed6:	eb 81       	ldd	r30, Y+3	; 0x03
    4ed8:	fc 81       	ldd	r31, Y+4	; 0x04
    4eda:	80 83       	st	Z, r24
	pxTopOfStack--;
    4edc:	8b 81       	ldd	r24, Y+3	; 0x03
    4ede:	9c 81       	ldd	r25, Y+4	; 0x04
    4ee0:	01 97       	sbiw	r24, 0x01	; 1
    4ee2:	9c 83       	std	Y+4, r25	; 0x04
    4ee4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    4ee6:	89 81       	ldd	r24, Y+1	; 0x01
    4ee8:	9a 81       	ldd	r25, Y+2	; 0x02
    4eea:	89 2f       	mov	r24, r25
    4eec:	99 27       	eor	r25, r25
    4eee:	9a 83       	std	Y+2, r25	; 0x02
    4ef0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    4ef2:	89 81       	ldd	r24, Y+1	; 0x01
    4ef4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ef6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ef8:	80 83       	st	Z, r24
	pxTopOfStack--;
    4efa:	8b 81       	ldd	r24, Y+3	; 0x03
    4efc:	9c 81       	ldd	r25, Y+4	; 0x04
    4efe:	01 97       	sbiw	r24, 0x01	; 1
    4f00:	9c 83       	std	Y+4, r25	; 0x04
    4f02:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    4f04:	eb 81       	ldd	r30, Y+3	; 0x03
    4f06:	fc 81       	ldd	r31, Y+4	; 0x04
    4f08:	10 82       	st	Z, r1
	pxTopOfStack--;
    4f0a:	8b 81       	ldd	r24, Y+3	; 0x03
    4f0c:	9c 81       	ldd	r25, Y+4	; 0x04
    4f0e:	01 97       	sbiw	r24, 0x01	; 1
    4f10:	9c 83       	std	Y+4, r25	; 0x04
    4f12:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    4f14:	eb 81       	ldd	r30, Y+3	; 0x03
    4f16:	fc 81       	ldd	r31, Y+4	; 0x04
    4f18:	80 e8       	ldi	r24, 0x80	; 128
    4f1a:	80 83       	st	Z, r24
	pxTopOfStack--;
    4f1c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f1e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f20:	01 97       	sbiw	r24, 0x01	; 1
    4f22:	9c 83       	std	Y+4, r25	; 0x04
    4f24:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    4f26:	eb 81       	ldd	r30, Y+3	; 0x03
    4f28:	fc 81       	ldd	r31, Y+4	; 0x04
    4f2a:	10 82       	st	Z, r1
	pxTopOfStack--;
    4f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f2e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f30:	01 97       	sbiw	r24, 0x01	; 1
    4f32:	9c 83       	std	Y+4, r25	; 0x04
    4f34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    4f36:	eb 81       	ldd	r30, Y+3	; 0x03
    4f38:	fc 81       	ldd	r31, Y+4	; 0x04
    4f3a:	82 e0       	ldi	r24, 0x02	; 2
    4f3c:	80 83       	st	Z, r24
	pxTopOfStack--;
    4f3e:	8b 81       	ldd	r24, Y+3	; 0x03
    4f40:	9c 81       	ldd	r25, Y+4	; 0x04
    4f42:	01 97       	sbiw	r24, 0x01	; 1
    4f44:	9c 83       	std	Y+4, r25	; 0x04
    4f46:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    4f48:	eb 81       	ldd	r30, Y+3	; 0x03
    4f4a:	fc 81       	ldd	r31, Y+4	; 0x04
    4f4c:	83 e0       	ldi	r24, 0x03	; 3
    4f4e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4f50:	8b 81       	ldd	r24, Y+3	; 0x03
    4f52:	9c 81       	ldd	r25, Y+4	; 0x04
    4f54:	01 97       	sbiw	r24, 0x01	; 1
    4f56:	9c 83       	std	Y+4, r25	; 0x04
    4f58:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    4f5a:	eb 81       	ldd	r30, Y+3	; 0x03
    4f5c:	fc 81       	ldd	r31, Y+4	; 0x04
    4f5e:	84 e0       	ldi	r24, 0x04	; 4
    4f60:	80 83       	st	Z, r24
	pxTopOfStack--;
    4f62:	8b 81       	ldd	r24, Y+3	; 0x03
    4f64:	9c 81       	ldd	r25, Y+4	; 0x04
    4f66:	01 97       	sbiw	r24, 0x01	; 1
    4f68:	9c 83       	std	Y+4, r25	; 0x04
    4f6a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    4f6c:	eb 81       	ldd	r30, Y+3	; 0x03
    4f6e:	fc 81       	ldd	r31, Y+4	; 0x04
    4f70:	85 e0       	ldi	r24, 0x05	; 5
    4f72:	80 83       	st	Z, r24
	pxTopOfStack--;
    4f74:	8b 81       	ldd	r24, Y+3	; 0x03
    4f76:	9c 81       	ldd	r25, Y+4	; 0x04
    4f78:	01 97       	sbiw	r24, 0x01	; 1
    4f7a:	9c 83       	std	Y+4, r25	; 0x04
    4f7c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    4f7e:	eb 81       	ldd	r30, Y+3	; 0x03
    4f80:	fc 81       	ldd	r31, Y+4	; 0x04
    4f82:	86 e0       	ldi	r24, 0x06	; 6
    4f84:	80 83       	st	Z, r24
	pxTopOfStack--;
    4f86:	8b 81       	ldd	r24, Y+3	; 0x03
    4f88:	9c 81       	ldd	r25, Y+4	; 0x04
    4f8a:	01 97       	sbiw	r24, 0x01	; 1
    4f8c:	9c 83       	std	Y+4, r25	; 0x04
    4f8e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    4f90:	eb 81       	ldd	r30, Y+3	; 0x03
    4f92:	fc 81       	ldd	r31, Y+4	; 0x04
    4f94:	87 e0       	ldi	r24, 0x07	; 7
    4f96:	80 83       	st	Z, r24
	pxTopOfStack--;
    4f98:	8b 81       	ldd	r24, Y+3	; 0x03
    4f9a:	9c 81       	ldd	r25, Y+4	; 0x04
    4f9c:	01 97       	sbiw	r24, 0x01	; 1
    4f9e:	9c 83       	std	Y+4, r25	; 0x04
    4fa0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    4fa2:	eb 81       	ldd	r30, Y+3	; 0x03
    4fa4:	fc 81       	ldd	r31, Y+4	; 0x04
    4fa6:	88 e0       	ldi	r24, 0x08	; 8
    4fa8:	80 83       	st	Z, r24
	pxTopOfStack--;
    4faa:	8b 81       	ldd	r24, Y+3	; 0x03
    4fac:	9c 81       	ldd	r25, Y+4	; 0x04
    4fae:	01 97       	sbiw	r24, 0x01	; 1
    4fb0:	9c 83       	std	Y+4, r25	; 0x04
    4fb2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    4fb4:	eb 81       	ldd	r30, Y+3	; 0x03
    4fb6:	fc 81       	ldd	r31, Y+4	; 0x04
    4fb8:	89 e0       	ldi	r24, 0x09	; 9
    4fba:	80 83       	st	Z, r24
	pxTopOfStack--;
    4fbc:	8b 81       	ldd	r24, Y+3	; 0x03
    4fbe:	9c 81       	ldd	r25, Y+4	; 0x04
    4fc0:	01 97       	sbiw	r24, 0x01	; 1
    4fc2:	9c 83       	std	Y+4, r25	; 0x04
    4fc4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    4fc6:	eb 81       	ldd	r30, Y+3	; 0x03
    4fc8:	fc 81       	ldd	r31, Y+4	; 0x04
    4fca:	80 e1       	ldi	r24, 0x10	; 16
    4fcc:	80 83       	st	Z, r24
	pxTopOfStack--;
    4fce:	8b 81       	ldd	r24, Y+3	; 0x03
    4fd0:	9c 81       	ldd	r25, Y+4	; 0x04
    4fd2:	01 97       	sbiw	r24, 0x01	; 1
    4fd4:	9c 83       	std	Y+4, r25	; 0x04
    4fd6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    4fd8:	eb 81       	ldd	r30, Y+3	; 0x03
    4fda:	fc 81       	ldd	r31, Y+4	; 0x04
    4fdc:	81 e1       	ldi	r24, 0x11	; 17
    4fde:	80 83       	st	Z, r24
	pxTopOfStack--;
    4fe0:	8b 81       	ldd	r24, Y+3	; 0x03
    4fe2:	9c 81       	ldd	r25, Y+4	; 0x04
    4fe4:	01 97       	sbiw	r24, 0x01	; 1
    4fe6:	9c 83       	std	Y+4, r25	; 0x04
    4fe8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    4fea:	eb 81       	ldd	r30, Y+3	; 0x03
    4fec:	fc 81       	ldd	r31, Y+4	; 0x04
    4fee:	82 e1       	ldi	r24, 0x12	; 18
    4ff0:	80 83       	st	Z, r24
	pxTopOfStack--;
    4ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    4ff4:	9c 81       	ldd	r25, Y+4	; 0x04
    4ff6:	01 97       	sbiw	r24, 0x01	; 1
    4ff8:	9c 83       	std	Y+4, r25	; 0x04
    4ffa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    4ffc:	eb 81       	ldd	r30, Y+3	; 0x03
    4ffe:	fc 81       	ldd	r31, Y+4	; 0x04
    5000:	83 e1       	ldi	r24, 0x13	; 19
    5002:	80 83       	st	Z, r24
	pxTopOfStack--;
    5004:	8b 81       	ldd	r24, Y+3	; 0x03
    5006:	9c 81       	ldd	r25, Y+4	; 0x04
    5008:	01 97       	sbiw	r24, 0x01	; 1
    500a:	9c 83       	std	Y+4, r25	; 0x04
    500c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    500e:	eb 81       	ldd	r30, Y+3	; 0x03
    5010:	fc 81       	ldd	r31, Y+4	; 0x04
    5012:	84 e1       	ldi	r24, 0x14	; 20
    5014:	80 83       	st	Z, r24
	pxTopOfStack--;
    5016:	8b 81       	ldd	r24, Y+3	; 0x03
    5018:	9c 81       	ldd	r25, Y+4	; 0x04
    501a:	01 97       	sbiw	r24, 0x01	; 1
    501c:	9c 83       	std	Y+4, r25	; 0x04
    501e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    5020:	eb 81       	ldd	r30, Y+3	; 0x03
    5022:	fc 81       	ldd	r31, Y+4	; 0x04
    5024:	85 e1       	ldi	r24, 0x15	; 21
    5026:	80 83       	st	Z, r24
	pxTopOfStack--;
    5028:	8b 81       	ldd	r24, Y+3	; 0x03
    502a:	9c 81       	ldd	r25, Y+4	; 0x04
    502c:	01 97       	sbiw	r24, 0x01	; 1
    502e:	9c 83       	std	Y+4, r25	; 0x04
    5030:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    5032:	eb 81       	ldd	r30, Y+3	; 0x03
    5034:	fc 81       	ldd	r31, Y+4	; 0x04
    5036:	86 e1       	ldi	r24, 0x16	; 22
    5038:	80 83       	st	Z, r24
	pxTopOfStack--;
    503a:	8b 81       	ldd	r24, Y+3	; 0x03
    503c:	9c 81       	ldd	r25, Y+4	; 0x04
    503e:	01 97       	sbiw	r24, 0x01	; 1
    5040:	9c 83       	std	Y+4, r25	; 0x04
    5042:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    5044:	eb 81       	ldd	r30, Y+3	; 0x03
    5046:	fc 81       	ldd	r31, Y+4	; 0x04
    5048:	87 e1       	ldi	r24, 0x17	; 23
    504a:	80 83       	st	Z, r24
	pxTopOfStack--;
    504c:	8b 81       	ldd	r24, Y+3	; 0x03
    504e:	9c 81       	ldd	r25, Y+4	; 0x04
    5050:	01 97       	sbiw	r24, 0x01	; 1
    5052:	9c 83       	std	Y+4, r25	; 0x04
    5054:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    5056:	eb 81       	ldd	r30, Y+3	; 0x03
    5058:	fc 81       	ldd	r31, Y+4	; 0x04
    505a:	88 e1       	ldi	r24, 0x18	; 24
    505c:	80 83       	st	Z, r24
	pxTopOfStack--;
    505e:	8b 81       	ldd	r24, Y+3	; 0x03
    5060:	9c 81       	ldd	r25, Y+4	; 0x04
    5062:	01 97       	sbiw	r24, 0x01	; 1
    5064:	9c 83       	std	Y+4, r25	; 0x04
    5066:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    5068:	eb 81       	ldd	r30, Y+3	; 0x03
    506a:	fc 81       	ldd	r31, Y+4	; 0x04
    506c:	89 e1       	ldi	r24, 0x19	; 25
    506e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5070:	8b 81       	ldd	r24, Y+3	; 0x03
    5072:	9c 81       	ldd	r25, Y+4	; 0x04
    5074:	01 97       	sbiw	r24, 0x01	; 1
    5076:	9c 83       	std	Y+4, r25	; 0x04
    5078:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    507a:	eb 81       	ldd	r30, Y+3	; 0x03
    507c:	fc 81       	ldd	r31, Y+4	; 0x04
    507e:	80 e2       	ldi	r24, 0x20	; 32
    5080:	80 83       	st	Z, r24
	pxTopOfStack--;
    5082:	8b 81       	ldd	r24, Y+3	; 0x03
    5084:	9c 81       	ldd	r25, Y+4	; 0x04
    5086:	01 97       	sbiw	r24, 0x01	; 1
    5088:	9c 83       	std	Y+4, r25	; 0x04
    508a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    508c:	eb 81       	ldd	r30, Y+3	; 0x03
    508e:	fc 81       	ldd	r31, Y+4	; 0x04
    5090:	81 e2       	ldi	r24, 0x21	; 33
    5092:	80 83       	st	Z, r24
	pxTopOfStack--;
    5094:	8b 81       	ldd	r24, Y+3	; 0x03
    5096:	9c 81       	ldd	r25, Y+4	; 0x04
    5098:	01 97       	sbiw	r24, 0x01	; 1
    509a:	9c 83       	std	Y+4, r25	; 0x04
    509c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    509e:	eb 81       	ldd	r30, Y+3	; 0x03
    50a0:	fc 81       	ldd	r31, Y+4	; 0x04
    50a2:	82 e2       	ldi	r24, 0x22	; 34
    50a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    50a6:	8b 81       	ldd	r24, Y+3	; 0x03
    50a8:	9c 81       	ldd	r25, Y+4	; 0x04
    50aa:	01 97       	sbiw	r24, 0x01	; 1
    50ac:	9c 83       	std	Y+4, r25	; 0x04
    50ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    50b0:	eb 81       	ldd	r30, Y+3	; 0x03
    50b2:	fc 81       	ldd	r31, Y+4	; 0x04
    50b4:	83 e2       	ldi	r24, 0x23	; 35
    50b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    50b8:	8b 81       	ldd	r24, Y+3	; 0x03
    50ba:	9c 81       	ldd	r25, Y+4	; 0x04
    50bc:	01 97       	sbiw	r24, 0x01	; 1
    50be:	9c 83       	std	Y+4, r25	; 0x04
    50c0:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    50c2:	8f 81       	ldd	r24, Y+7	; 0x07
    50c4:	98 85       	ldd	r25, Y+8	; 0x08
    50c6:	9a 83       	std	Y+2, r25	; 0x02
    50c8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    50ca:	89 81       	ldd	r24, Y+1	; 0x01
    50cc:	eb 81       	ldd	r30, Y+3	; 0x03
    50ce:	fc 81       	ldd	r31, Y+4	; 0x04
    50d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    50d2:	8b 81       	ldd	r24, Y+3	; 0x03
    50d4:	9c 81       	ldd	r25, Y+4	; 0x04
    50d6:	01 97       	sbiw	r24, 0x01	; 1
    50d8:	9c 83       	std	Y+4, r25	; 0x04
    50da:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    50dc:	89 81       	ldd	r24, Y+1	; 0x01
    50de:	9a 81       	ldd	r25, Y+2	; 0x02
    50e0:	89 2f       	mov	r24, r25
    50e2:	99 27       	eor	r25, r25
    50e4:	9a 83       	std	Y+2, r25	; 0x02
    50e6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    50e8:	89 81       	ldd	r24, Y+1	; 0x01
    50ea:	eb 81       	ldd	r30, Y+3	; 0x03
    50ec:	fc 81       	ldd	r31, Y+4	; 0x04
    50ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    50f0:	8b 81       	ldd	r24, Y+3	; 0x03
    50f2:	9c 81       	ldd	r25, Y+4	; 0x04
    50f4:	01 97       	sbiw	r24, 0x01	; 1
    50f6:	9c 83       	std	Y+4, r25	; 0x04
    50f8:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    50fa:	eb 81       	ldd	r30, Y+3	; 0x03
    50fc:	fc 81       	ldd	r31, Y+4	; 0x04
    50fe:	86 e2       	ldi	r24, 0x26	; 38
    5100:	80 83       	st	Z, r24
	pxTopOfStack--;
    5102:	8b 81       	ldd	r24, Y+3	; 0x03
    5104:	9c 81       	ldd	r25, Y+4	; 0x04
    5106:	01 97       	sbiw	r24, 0x01	; 1
    5108:	9c 83       	std	Y+4, r25	; 0x04
    510a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    510c:	eb 81       	ldd	r30, Y+3	; 0x03
    510e:	fc 81       	ldd	r31, Y+4	; 0x04
    5110:	87 e2       	ldi	r24, 0x27	; 39
    5112:	80 83       	st	Z, r24
	pxTopOfStack--;
    5114:	8b 81       	ldd	r24, Y+3	; 0x03
    5116:	9c 81       	ldd	r25, Y+4	; 0x04
    5118:	01 97       	sbiw	r24, 0x01	; 1
    511a:	9c 83       	std	Y+4, r25	; 0x04
    511c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    511e:	eb 81       	ldd	r30, Y+3	; 0x03
    5120:	fc 81       	ldd	r31, Y+4	; 0x04
    5122:	88 e2       	ldi	r24, 0x28	; 40
    5124:	80 83       	st	Z, r24
	pxTopOfStack--;
    5126:	8b 81       	ldd	r24, Y+3	; 0x03
    5128:	9c 81       	ldd	r25, Y+4	; 0x04
    512a:	01 97       	sbiw	r24, 0x01	; 1
    512c:	9c 83       	std	Y+4, r25	; 0x04
    512e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    5130:	eb 81       	ldd	r30, Y+3	; 0x03
    5132:	fc 81       	ldd	r31, Y+4	; 0x04
    5134:	89 e2       	ldi	r24, 0x29	; 41
    5136:	80 83       	st	Z, r24
	pxTopOfStack--;
    5138:	8b 81       	ldd	r24, Y+3	; 0x03
    513a:	9c 81       	ldd	r25, Y+4	; 0x04
    513c:	01 97       	sbiw	r24, 0x01	; 1
    513e:	9c 83       	std	Y+4, r25	; 0x04
    5140:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    5142:	eb 81       	ldd	r30, Y+3	; 0x03
    5144:	fc 81       	ldd	r31, Y+4	; 0x04
    5146:	80 e3       	ldi	r24, 0x30	; 48
    5148:	80 83       	st	Z, r24
	pxTopOfStack--;
    514a:	8b 81       	ldd	r24, Y+3	; 0x03
    514c:	9c 81       	ldd	r25, Y+4	; 0x04
    514e:	01 97       	sbiw	r24, 0x01	; 1
    5150:	9c 83       	std	Y+4, r25	; 0x04
    5152:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    5154:	eb 81       	ldd	r30, Y+3	; 0x03
    5156:	fc 81       	ldd	r31, Y+4	; 0x04
    5158:	81 e3       	ldi	r24, 0x31	; 49
    515a:	80 83       	st	Z, r24
	pxTopOfStack--;
    515c:	8b 81       	ldd	r24, Y+3	; 0x03
    515e:	9c 81       	ldd	r25, Y+4	; 0x04
    5160:	01 97       	sbiw	r24, 0x01	; 1
    5162:	9c 83       	std	Y+4, r25	; 0x04
    5164:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    5166:	8b 81       	ldd	r24, Y+3	; 0x03
    5168:	9c 81       	ldd	r25, Y+4	; 0x04
}
    516a:	28 96       	adiw	r28, 0x08	; 8
    516c:	0f b6       	in	r0, 0x3f	; 63
    516e:	f8 94       	cli
    5170:	de bf       	out	0x3e, r29	; 62
    5172:	0f be       	out	0x3f, r0	; 63
    5174:	cd bf       	out	0x3d, r28	; 61
    5176:	cf 91       	pop	r28
    5178:	df 91       	pop	r29
    517a:	08 95       	ret

0000517c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    517c:	df 93       	push	r29
    517e:	cf 93       	push	r28
    5180:	cd b7       	in	r28, 0x3d	; 61
    5182:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    5184:	0e 94 ae 29 	call	0x535c	; 0x535c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    5188:	a0 91 fa 05 	lds	r26, 0x05FA
    518c:	b0 91 fb 05 	lds	r27, 0x05FB
    5190:	cd 91       	ld	r28, X+
    5192:	cd bf       	out	0x3d, r28	; 61
    5194:	dd 91       	ld	r29, X+
    5196:	de bf       	out	0x3e, r29	; 62
    5198:	ff 91       	pop	r31
    519a:	ef 91       	pop	r30
    519c:	df 91       	pop	r29
    519e:	cf 91       	pop	r28
    51a0:	bf 91       	pop	r27
    51a2:	af 91       	pop	r26
    51a4:	9f 91       	pop	r25
    51a6:	8f 91       	pop	r24
    51a8:	7f 91       	pop	r23
    51aa:	6f 91       	pop	r22
    51ac:	5f 91       	pop	r21
    51ae:	4f 91       	pop	r20
    51b0:	3f 91       	pop	r19
    51b2:	2f 91       	pop	r18
    51b4:	1f 91       	pop	r17
    51b6:	0f 91       	pop	r16
    51b8:	ff 90       	pop	r15
    51ba:	ef 90       	pop	r14
    51bc:	df 90       	pop	r13
    51be:	cf 90       	pop	r12
    51c0:	bf 90       	pop	r11
    51c2:	af 90       	pop	r10
    51c4:	9f 90       	pop	r9
    51c6:	8f 90       	pop	r8
    51c8:	7f 90       	pop	r7
    51ca:	6f 90       	pop	r6
    51cc:	5f 90       	pop	r5
    51ce:	4f 90       	pop	r4
    51d0:	3f 90       	pop	r3
    51d2:	2f 90       	pop	r2
    51d4:	1f 90       	pop	r1
    51d6:	0f 90       	pop	r0
    51d8:	0f be       	out	0x3f, r0	; 63
    51da:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    51dc:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    51de:	81 e0       	ldi	r24, 0x01	; 1
}
    51e0:	cf 91       	pop	r28
    51e2:	df 91       	pop	r29
    51e4:	08 95       	ret

000051e6 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    51e6:	df 93       	push	r29
    51e8:	cf 93       	push	r28
    51ea:	cd b7       	in	r28, 0x3d	; 61
    51ec:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    51ee:	cf 91       	pop	r28
    51f0:	df 91       	pop	r29
    51f2:	08 95       	ret

000051f4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    51f4:	0f 92       	push	r0
    51f6:	0f b6       	in	r0, 0x3f	; 63
    51f8:	f8 94       	cli
    51fa:	0f 92       	push	r0
    51fc:	1f 92       	push	r1
    51fe:	11 24       	eor	r1, r1
    5200:	2f 92       	push	r2
    5202:	3f 92       	push	r3
    5204:	4f 92       	push	r4
    5206:	5f 92       	push	r5
    5208:	6f 92       	push	r6
    520a:	7f 92       	push	r7
    520c:	8f 92       	push	r8
    520e:	9f 92       	push	r9
    5210:	af 92       	push	r10
    5212:	bf 92       	push	r11
    5214:	cf 92       	push	r12
    5216:	df 92       	push	r13
    5218:	ef 92       	push	r14
    521a:	ff 92       	push	r15
    521c:	0f 93       	push	r16
    521e:	1f 93       	push	r17
    5220:	2f 93       	push	r18
    5222:	3f 93       	push	r19
    5224:	4f 93       	push	r20
    5226:	5f 93       	push	r21
    5228:	6f 93       	push	r22
    522a:	7f 93       	push	r23
    522c:	8f 93       	push	r24
    522e:	9f 93       	push	r25
    5230:	af 93       	push	r26
    5232:	bf 93       	push	r27
    5234:	cf 93       	push	r28
    5236:	df 93       	push	r29
    5238:	ef 93       	push	r30
    523a:	ff 93       	push	r31
    523c:	a0 91 fa 05 	lds	r26, 0x05FA
    5240:	b0 91 fb 05 	lds	r27, 0x05FB
    5244:	0d b6       	in	r0, 0x3d	; 61
    5246:	0d 92       	st	X+, r0
    5248:	0e b6       	in	r0, 0x3e	; 62
    524a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    524c:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5250:	a0 91 fa 05 	lds	r26, 0x05FA
    5254:	b0 91 fb 05 	lds	r27, 0x05FB
    5258:	cd 91       	ld	r28, X+
    525a:	cd bf       	out	0x3d, r28	; 61
    525c:	dd 91       	ld	r29, X+
    525e:	de bf       	out	0x3e, r29	; 62
    5260:	ff 91       	pop	r31
    5262:	ef 91       	pop	r30
    5264:	df 91       	pop	r29
    5266:	cf 91       	pop	r28
    5268:	bf 91       	pop	r27
    526a:	af 91       	pop	r26
    526c:	9f 91       	pop	r25
    526e:	8f 91       	pop	r24
    5270:	7f 91       	pop	r23
    5272:	6f 91       	pop	r22
    5274:	5f 91       	pop	r21
    5276:	4f 91       	pop	r20
    5278:	3f 91       	pop	r19
    527a:	2f 91       	pop	r18
    527c:	1f 91       	pop	r17
    527e:	0f 91       	pop	r16
    5280:	ff 90       	pop	r15
    5282:	ef 90       	pop	r14
    5284:	df 90       	pop	r13
    5286:	cf 90       	pop	r12
    5288:	bf 90       	pop	r11
    528a:	af 90       	pop	r10
    528c:	9f 90       	pop	r9
    528e:	8f 90       	pop	r8
    5290:	7f 90       	pop	r7
    5292:	6f 90       	pop	r6
    5294:	5f 90       	pop	r5
    5296:	4f 90       	pop	r4
    5298:	3f 90       	pop	r3
    529a:	2f 90       	pop	r2
    529c:	1f 90       	pop	r1
    529e:	0f 90       	pop	r0
    52a0:	0f be       	out	0x3f, r0	; 63
    52a2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    52a4:	08 95       	ret

000052a6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    52a6:	0f 92       	push	r0
    52a8:	0f b6       	in	r0, 0x3f	; 63
    52aa:	f8 94       	cli
    52ac:	0f 92       	push	r0
    52ae:	1f 92       	push	r1
    52b0:	11 24       	eor	r1, r1
    52b2:	2f 92       	push	r2
    52b4:	3f 92       	push	r3
    52b6:	4f 92       	push	r4
    52b8:	5f 92       	push	r5
    52ba:	6f 92       	push	r6
    52bc:	7f 92       	push	r7
    52be:	8f 92       	push	r8
    52c0:	9f 92       	push	r9
    52c2:	af 92       	push	r10
    52c4:	bf 92       	push	r11
    52c6:	cf 92       	push	r12
    52c8:	df 92       	push	r13
    52ca:	ef 92       	push	r14
    52cc:	ff 92       	push	r15
    52ce:	0f 93       	push	r16
    52d0:	1f 93       	push	r17
    52d2:	2f 93       	push	r18
    52d4:	3f 93       	push	r19
    52d6:	4f 93       	push	r20
    52d8:	5f 93       	push	r21
    52da:	6f 93       	push	r22
    52dc:	7f 93       	push	r23
    52de:	8f 93       	push	r24
    52e0:	9f 93       	push	r25
    52e2:	af 93       	push	r26
    52e4:	bf 93       	push	r27
    52e6:	cf 93       	push	r28
    52e8:	df 93       	push	r29
    52ea:	ef 93       	push	r30
    52ec:	ff 93       	push	r31
    52ee:	a0 91 fa 05 	lds	r26, 0x05FA
    52f2:	b0 91 fb 05 	lds	r27, 0x05FB
    52f6:	0d b6       	in	r0, 0x3d	; 61
    52f8:	0d 92       	st	X+, r0
    52fa:	0e b6       	in	r0, 0x3e	; 62
    52fc:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    52fe:	0e 94 95 31 	call	0x632a	; 0x632a <vTaskIncrementTick>
	vTaskSwitchContext();
    5302:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5306:	a0 91 fa 05 	lds	r26, 0x05FA
    530a:	b0 91 fb 05 	lds	r27, 0x05FB
    530e:	cd 91       	ld	r28, X+
    5310:	cd bf       	out	0x3d, r28	; 61
    5312:	dd 91       	ld	r29, X+
    5314:	de bf       	out	0x3e, r29	; 62
    5316:	ff 91       	pop	r31
    5318:	ef 91       	pop	r30
    531a:	df 91       	pop	r29
    531c:	cf 91       	pop	r28
    531e:	bf 91       	pop	r27
    5320:	af 91       	pop	r26
    5322:	9f 91       	pop	r25
    5324:	8f 91       	pop	r24
    5326:	7f 91       	pop	r23
    5328:	6f 91       	pop	r22
    532a:	5f 91       	pop	r21
    532c:	4f 91       	pop	r20
    532e:	3f 91       	pop	r19
    5330:	2f 91       	pop	r18
    5332:	1f 91       	pop	r17
    5334:	0f 91       	pop	r16
    5336:	ff 90       	pop	r15
    5338:	ef 90       	pop	r14
    533a:	df 90       	pop	r13
    533c:	cf 90       	pop	r12
    533e:	bf 90       	pop	r11
    5340:	af 90       	pop	r10
    5342:	9f 90       	pop	r9
    5344:	8f 90       	pop	r8
    5346:	7f 90       	pop	r7
    5348:	6f 90       	pop	r6
    534a:	5f 90       	pop	r5
    534c:	4f 90       	pop	r4
    534e:	3f 90       	pop	r3
    5350:	2f 90       	pop	r2
    5352:	1f 90       	pop	r1
    5354:	0f 90       	pop	r0
    5356:	0f be       	out	0x3f, r0	; 63
    5358:	0f 90       	pop	r0

	asm volatile ( "ret" );
    535a:	08 95       	ret

0000535c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    535c:	df 93       	push	r29
    535e:	cf 93       	push	r28
    5360:	00 d0       	rcall	.+0      	; 0x5362 <prvSetupTimerInterrupt+0x6>
    5362:	00 d0       	rcall	.+0      	; 0x5364 <prvSetupTimerInterrupt+0x8>
    5364:	00 d0       	rcall	.+0      	; 0x5366 <prvSetupTimerInterrupt+0xa>
    5366:	cd b7       	in	r28, 0x3d	; 61
    5368:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    536a:	80 e8       	ldi	r24, 0x80	; 128
    536c:	98 e3       	ldi	r25, 0x38	; 56
    536e:	a1 e0       	ldi	r26, 0x01	; 1
    5370:	b0 e0       	ldi	r27, 0x00	; 0
    5372:	8b 83       	std	Y+3, r24	; 0x03
    5374:	9c 83       	std	Y+4, r25	; 0x04
    5376:	ad 83       	std	Y+5, r26	; 0x05
    5378:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    537a:	8b 81       	ldd	r24, Y+3	; 0x03
    537c:	9c 81       	ldd	r25, Y+4	; 0x04
    537e:	ad 81       	ldd	r26, Y+5	; 0x05
    5380:	be 81       	ldd	r27, Y+6	; 0x06
    5382:	68 94       	set
    5384:	15 f8       	bld	r1, 5
    5386:	b6 95       	lsr	r27
    5388:	a7 95       	ror	r26
    538a:	97 95       	ror	r25
    538c:	87 95       	ror	r24
    538e:	16 94       	lsr	r1
    5390:	d1 f7       	brne	.-12     	; 0x5386 <prvSetupTimerInterrupt+0x2a>
    5392:	8b 83       	std	Y+3, r24	; 0x03
    5394:	9c 83       	std	Y+4, r25	; 0x04
    5396:	ad 83       	std	Y+5, r26	; 0x05
    5398:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    539a:	8b 81       	ldd	r24, Y+3	; 0x03
    539c:	9c 81       	ldd	r25, Y+4	; 0x04
    539e:	ad 81       	ldd	r26, Y+5	; 0x05
    53a0:	be 81       	ldd	r27, Y+6	; 0x06
    53a2:	01 97       	sbiw	r24, 0x01	; 1
    53a4:	a1 09       	sbc	r26, r1
    53a6:	b1 09       	sbc	r27, r1
    53a8:	8b 83       	std	Y+3, r24	; 0x03
    53aa:	9c 83       	std	Y+4, r25	; 0x04
    53ac:	ad 83       	std	Y+5, r26	; 0x05
    53ae:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    53b0:	8b 81       	ldd	r24, Y+3	; 0x03
    53b2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    53b4:	8b 81       	ldd	r24, Y+3	; 0x03
    53b6:	9c 81       	ldd	r25, Y+4	; 0x04
    53b8:	ad 81       	ldd	r26, Y+5	; 0x05
    53ba:	be 81       	ldd	r27, Y+6	; 0x06
    53bc:	89 2f       	mov	r24, r25
    53be:	9a 2f       	mov	r25, r26
    53c0:	ab 2f       	mov	r26, r27
    53c2:	bb 27       	eor	r27, r27
    53c4:	8b 83       	std	Y+3, r24	; 0x03
    53c6:	9c 83       	std	Y+4, r25	; 0x04
    53c8:	ad 83       	std	Y+5, r26	; 0x05
    53ca:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    53cc:	8b 81       	ldd	r24, Y+3	; 0x03
    53ce:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    53d0:	eb e4       	ldi	r30, 0x4B	; 75
    53d2:	f0 e0       	ldi	r31, 0x00	; 0
    53d4:	8a 81       	ldd	r24, Y+2	; 0x02
    53d6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    53d8:	ea e4       	ldi	r30, 0x4A	; 74
    53da:	f0 e0       	ldi	r31, 0x00	; 0
    53dc:	89 81       	ldd	r24, Y+1	; 0x01
    53de:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    53e0:	8b e0       	ldi	r24, 0x0B	; 11
    53e2:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    53e4:	ee e4       	ldi	r30, 0x4E	; 78
    53e6:	f0 e0       	ldi	r31, 0x00	; 0
    53e8:	89 81       	ldd	r24, Y+1	; 0x01
    53ea:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    53ec:	e9 e5       	ldi	r30, 0x59	; 89
    53ee:	f0 e0       	ldi	r31, 0x00	; 0
    53f0:	80 81       	ld	r24, Z
    53f2:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    53f4:	89 81       	ldd	r24, Y+1	; 0x01
    53f6:	80 61       	ori	r24, 0x10	; 16
    53f8:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    53fa:	e9 e5       	ldi	r30, 0x59	; 89
    53fc:	f0 e0       	ldi	r31, 0x00	; 0
    53fe:	89 81       	ldd	r24, Y+1	; 0x01
    5400:	80 83       	st	Z, r24
}
    5402:	26 96       	adiw	r28, 0x06	; 6
    5404:	0f b6       	in	r0, 0x3f	; 63
    5406:	f8 94       	cli
    5408:	de bf       	out	0x3e, r29	; 62
    540a:	0f be       	out	0x3f, r0	; 63
    540c:	cd bf       	out	0x3d, r28	; 61
    540e:	cf 91       	pop	r28
    5410:	df 91       	pop	r29
    5412:	08 95       	ret

00005414 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    5414:	0e 94 53 29 	call	0x52a6	; 0x52a6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    5418:	18 95       	reti

0000541a <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    541a:	df 93       	push	r29
    541c:	cf 93       	push	r28
    541e:	cd b7       	in	r28, 0x3d	; 61
    5420:	de b7       	in	r29, 0x3e	; 62
    5422:	28 97       	sbiw	r28, 0x08	; 8
    5424:	0f b6       	in	r0, 0x3f	; 63
    5426:	f8 94       	cli
    5428:	de bf       	out	0x3e, r29	; 62
    542a:	0f be       	out	0x3f, r0	; 63
    542c:	cd bf       	out	0x3d, r28	; 61
    542e:	8f 83       	std	Y+7, r24	; 0x07
    5430:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    5432:	1a 82       	std	Y+2, r1	; 0x02
    5434:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    5436:	8f 81       	ldd	r24, Y+7	; 0x07
    5438:	88 23       	and	r24, r24
    543a:	09 f4       	brne	.+2      	; 0x543e <xQueueCreate+0x24>
    543c:	8c c0       	rjmp	.+280    	; 0x5556 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    543e:	8f e1       	ldi	r24, 0x1F	; 31
    5440:	90 e0       	ldi	r25, 0x00	; 0
    5442:	0e 94 ec 24 	call	0x49d8	; 0x49d8 <pvPortMalloc>
    5446:	9e 83       	std	Y+6, r25	; 0x06
    5448:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    544a:	8d 81       	ldd	r24, Y+5	; 0x05
    544c:	9e 81       	ldd	r25, Y+6	; 0x06
    544e:	00 97       	sbiw	r24, 0x00	; 0
    5450:	09 f4       	brne	.+2      	; 0x5454 <xQueueCreate+0x3a>
    5452:	81 c0       	rjmp	.+258    	; 0x5556 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    5454:	8f 81       	ldd	r24, Y+7	; 0x07
    5456:	28 2f       	mov	r18, r24
    5458:	30 e0       	ldi	r19, 0x00	; 0
    545a:	88 85       	ldd	r24, Y+8	; 0x08
    545c:	88 2f       	mov	r24, r24
    545e:	90 e0       	ldi	r25, 0x00	; 0
    5460:	ac 01       	movw	r20, r24
    5462:	24 9f       	mul	r18, r20
    5464:	c0 01       	movw	r24, r0
    5466:	25 9f       	mul	r18, r21
    5468:	90 0d       	add	r25, r0
    546a:	34 9f       	mul	r19, r20
    546c:	90 0d       	add	r25, r0
    546e:	11 24       	eor	r1, r1
    5470:	01 96       	adiw	r24, 0x01	; 1
    5472:	9c 83       	std	Y+4, r25	; 0x04
    5474:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    5476:	8b 81       	ldd	r24, Y+3	; 0x03
    5478:	9c 81       	ldd	r25, Y+4	; 0x04
    547a:	0e 94 ec 24 	call	0x49d8	; 0x49d8 <pvPortMalloc>
    547e:	ed 81       	ldd	r30, Y+5	; 0x05
    5480:	fe 81       	ldd	r31, Y+6	; 0x06
    5482:	91 83       	std	Z+1, r25	; 0x01
    5484:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    5486:	ed 81       	ldd	r30, Y+5	; 0x05
    5488:	fe 81       	ldd	r31, Y+6	; 0x06
    548a:	80 81       	ld	r24, Z
    548c:	91 81       	ldd	r25, Z+1	; 0x01
    548e:	00 97       	sbiw	r24, 0x00	; 0
    5490:	09 f4       	brne	.+2      	; 0x5494 <xQueueCreate+0x7a>
    5492:	5d c0       	rjmp	.+186    	; 0x554e <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    5494:	ed 81       	ldd	r30, Y+5	; 0x05
    5496:	fe 81       	ldd	r31, Y+6	; 0x06
    5498:	40 81       	ld	r20, Z
    549a:	51 81       	ldd	r21, Z+1	; 0x01
    549c:	8f 81       	ldd	r24, Y+7	; 0x07
    549e:	28 2f       	mov	r18, r24
    54a0:	30 e0       	ldi	r19, 0x00	; 0
    54a2:	88 85       	ldd	r24, Y+8	; 0x08
    54a4:	88 2f       	mov	r24, r24
    54a6:	90 e0       	ldi	r25, 0x00	; 0
    54a8:	bc 01       	movw	r22, r24
    54aa:	26 9f       	mul	r18, r22
    54ac:	c0 01       	movw	r24, r0
    54ae:	27 9f       	mul	r18, r23
    54b0:	90 0d       	add	r25, r0
    54b2:	36 9f       	mul	r19, r22
    54b4:	90 0d       	add	r25, r0
    54b6:	11 24       	eor	r1, r1
    54b8:	84 0f       	add	r24, r20
    54ba:	95 1f       	adc	r25, r21
    54bc:	ed 81       	ldd	r30, Y+5	; 0x05
    54be:	fe 81       	ldd	r31, Y+6	; 0x06
    54c0:	93 83       	std	Z+3, r25	; 0x03
    54c2:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    54c4:	ed 81       	ldd	r30, Y+5	; 0x05
    54c6:	fe 81       	ldd	r31, Y+6	; 0x06
    54c8:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    54ca:	ed 81       	ldd	r30, Y+5	; 0x05
    54cc:	fe 81       	ldd	r31, Y+6	; 0x06
    54ce:	80 81       	ld	r24, Z
    54d0:	91 81       	ldd	r25, Z+1	; 0x01
    54d2:	ed 81       	ldd	r30, Y+5	; 0x05
    54d4:	fe 81       	ldd	r31, Y+6	; 0x06
    54d6:	95 83       	std	Z+5, r25	; 0x05
    54d8:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    54da:	ed 81       	ldd	r30, Y+5	; 0x05
    54dc:	fe 81       	ldd	r31, Y+6	; 0x06
    54de:	40 81       	ld	r20, Z
    54e0:	51 81       	ldd	r21, Z+1	; 0x01
    54e2:	8f 81       	ldd	r24, Y+7	; 0x07
    54e4:	88 2f       	mov	r24, r24
    54e6:	90 e0       	ldi	r25, 0x00	; 0
    54e8:	9c 01       	movw	r18, r24
    54ea:	21 50       	subi	r18, 0x01	; 1
    54ec:	30 40       	sbci	r19, 0x00	; 0
    54ee:	88 85       	ldd	r24, Y+8	; 0x08
    54f0:	88 2f       	mov	r24, r24
    54f2:	90 e0       	ldi	r25, 0x00	; 0
    54f4:	bc 01       	movw	r22, r24
    54f6:	26 9f       	mul	r18, r22
    54f8:	c0 01       	movw	r24, r0
    54fa:	27 9f       	mul	r18, r23
    54fc:	90 0d       	add	r25, r0
    54fe:	36 9f       	mul	r19, r22
    5500:	90 0d       	add	r25, r0
    5502:	11 24       	eor	r1, r1
    5504:	84 0f       	add	r24, r20
    5506:	95 1f       	adc	r25, r21
    5508:	ed 81       	ldd	r30, Y+5	; 0x05
    550a:	fe 81       	ldd	r31, Y+6	; 0x06
    550c:	97 83       	std	Z+7, r25	; 0x07
    550e:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    5510:	ed 81       	ldd	r30, Y+5	; 0x05
    5512:	fe 81       	ldd	r31, Y+6	; 0x06
    5514:	8f 81       	ldd	r24, Y+7	; 0x07
    5516:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    5518:	ed 81       	ldd	r30, Y+5	; 0x05
    551a:	fe 81       	ldd	r31, Y+6	; 0x06
    551c:	88 85       	ldd	r24, Y+8	; 0x08
    551e:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    5520:	ed 81       	ldd	r30, Y+5	; 0x05
    5522:	fe 81       	ldd	r31, Y+6	; 0x06
    5524:	8f ef       	ldi	r24, 0xFF	; 255
    5526:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    5528:	ed 81       	ldd	r30, Y+5	; 0x05
    552a:	fe 81       	ldd	r31, Y+6	; 0x06
    552c:	8f ef       	ldi	r24, 0xFF	; 255
    552e:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    5530:	8d 81       	ldd	r24, Y+5	; 0x05
    5532:	9e 81       	ldd	r25, Y+6	; 0x06
    5534:	08 96       	adiw	r24, 0x08	; 8
    5536:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    553a:	8d 81       	ldd	r24, Y+5	; 0x05
    553c:	9e 81       	ldd	r25, Y+6	; 0x06
    553e:	41 96       	adiw	r24, 0x11	; 17
    5540:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    5544:	8d 81       	ldd	r24, Y+5	; 0x05
    5546:	9e 81       	ldd	r25, Y+6	; 0x06
    5548:	9a 83       	std	Y+2, r25	; 0x02
    554a:	89 83       	std	Y+1, r24	; 0x01
    554c:	04 c0       	rjmp	.+8      	; 0x5556 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    554e:	8d 81       	ldd	r24, Y+5	; 0x05
    5550:	9e 81       	ldd	r25, Y+6	; 0x06
    5552:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    5556:	89 81       	ldd	r24, Y+1	; 0x01
    5558:	9a 81       	ldd	r25, Y+2	; 0x02
}
    555a:	28 96       	adiw	r28, 0x08	; 8
    555c:	0f b6       	in	r0, 0x3f	; 63
    555e:	f8 94       	cli
    5560:	de bf       	out	0x3e, r29	; 62
    5562:	0f be       	out	0x3f, r0	; 63
    5564:	cd bf       	out	0x3d, r28	; 61
    5566:	cf 91       	pop	r28
    5568:	df 91       	pop	r29
    556a:	08 95       	ret

0000556c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    556c:	df 93       	push	r29
    556e:	cf 93       	push	r28
    5570:	cd b7       	in	r28, 0x3d	; 61
    5572:	de b7       	in	r29, 0x3e	; 62
    5574:	2c 97       	sbiw	r28, 0x0c	; 12
    5576:	0f b6       	in	r0, 0x3f	; 63
    5578:	f8 94       	cli
    557a:	de bf       	out	0x3e, r29	; 62
    557c:	0f be       	out	0x3f, r0	; 63
    557e:	cd bf       	out	0x3d, r28	; 61
    5580:	9e 83       	std	Y+6, r25	; 0x06
    5582:	8d 83       	std	Y+5, r24	; 0x05
    5584:	78 87       	std	Y+8, r23	; 0x08
    5586:	6f 83       	std	Y+7, r22	; 0x07
    5588:	5a 87       	std	Y+10, r21	; 0x0a
    558a:	49 87       	std	Y+9, r20	; 0x09
    558c:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    558e:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    5590:	0f b6       	in	r0, 0x3f	; 63
    5592:	f8 94       	cli
    5594:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    5596:	ed 81       	ldd	r30, Y+5	; 0x05
    5598:	fe 81       	ldd	r31, Y+6	; 0x06
    559a:	92 8d       	ldd	r25, Z+26	; 0x1a
    559c:	ed 81       	ldd	r30, Y+5	; 0x05
    559e:	fe 81       	ldd	r31, Y+6	; 0x06
    55a0:	83 8d       	ldd	r24, Z+27	; 0x1b
    55a2:	98 17       	cp	r25, r24
    55a4:	d8 f4       	brcc	.+54     	; 0x55dc <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    55a6:	8d 81       	ldd	r24, Y+5	; 0x05
    55a8:	9e 81       	ldd	r25, Y+6	; 0x06
    55aa:	2f 81       	ldd	r18, Y+7	; 0x07
    55ac:	38 85       	ldd	r19, Y+8	; 0x08
    55ae:	b9 01       	movw	r22, r18
    55b0:	4b 85       	ldd	r20, Y+11	; 0x0b
    55b2:	0e 94 f1 2c 	call	0x59e2	; 0x59e2 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    55b6:	ed 81       	ldd	r30, Y+5	; 0x05
    55b8:	fe 81       	ldd	r31, Y+6	; 0x06
    55ba:	81 89       	ldd	r24, Z+17	; 0x11
    55bc:	88 23       	and	r24, r24
    55be:	49 f0       	breq	.+18     	; 0x55d2 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    55c0:	8d 81       	ldd	r24, Y+5	; 0x05
    55c2:	9e 81       	ldd	r25, Y+6	; 0x06
    55c4:	41 96       	adiw	r24, 0x11	; 17
    55c6:	0e 94 06 33 	call	0x660c	; 0x660c <xTaskRemoveFromEventList>
    55ca:	81 30       	cpi	r24, 0x01	; 1
    55cc:	11 f4       	brne	.+4      	; 0x55d2 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    55ce:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    55d2:	0f 90       	pop	r0
    55d4:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    55d6:	81 e0       	ldi	r24, 0x01	; 1
    55d8:	8c 87       	std	Y+12, r24	; 0x0c
    55da:	5c c0       	rjmp	.+184    	; 0x5694 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    55dc:	89 85       	ldd	r24, Y+9	; 0x09
    55de:	9a 85       	ldd	r25, Y+10	; 0x0a
    55e0:	00 97       	sbiw	r24, 0x00	; 0
    55e2:	21 f4       	brne	.+8      	; 0x55ec <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    55e4:	0f 90       	pop	r0
    55e6:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    55e8:	1c 86       	std	Y+12, r1	; 0x0c
    55ea:	54 c0       	rjmp	.+168    	; 0x5694 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    55ec:	89 81       	ldd	r24, Y+1	; 0x01
    55ee:	88 23       	and	r24, r24
    55f0:	31 f4       	brne	.+12     	; 0x55fe <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    55f2:	ce 01       	movw	r24, r28
    55f4:	02 96       	adiw	r24, 0x02	; 2
    55f6:	0e 94 6e 33 	call	0x66dc	; 0x66dc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    55fa:	81 e0       	ldi	r24, 0x01	; 1
    55fc:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    55fe:	0f 90       	pop	r0
    5600:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5602:	0e 94 ca 30 	call	0x6194	; 0x6194 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5606:	0f b6       	in	r0, 0x3f	; 63
    5608:	f8 94       	cli
    560a:	0f 92       	push	r0
    560c:	ed 81       	ldd	r30, Y+5	; 0x05
    560e:	fe 81       	ldd	r31, Y+6	; 0x06
    5610:	85 8d       	ldd	r24, Z+29	; 0x1d
    5612:	8f 3f       	cpi	r24, 0xFF	; 255
    5614:	19 f4       	brne	.+6      	; 0x561c <xQueueGenericSend+0xb0>
    5616:	ed 81       	ldd	r30, Y+5	; 0x05
    5618:	fe 81       	ldd	r31, Y+6	; 0x06
    561a:	15 8e       	std	Z+29, r1	; 0x1d
    561c:	ed 81       	ldd	r30, Y+5	; 0x05
    561e:	fe 81       	ldd	r31, Y+6	; 0x06
    5620:	86 8d       	ldd	r24, Z+30	; 0x1e
    5622:	8f 3f       	cpi	r24, 0xFF	; 255
    5624:	19 f4       	brne	.+6      	; 0x562c <xQueueGenericSend+0xc0>
    5626:	ed 81       	ldd	r30, Y+5	; 0x05
    5628:	fe 81       	ldd	r31, Y+6	; 0x06
    562a:	16 8e       	std	Z+30, r1	; 0x1e
    562c:	0f 90       	pop	r0
    562e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5630:	ce 01       	movw	r24, r28
    5632:	02 96       	adiw	r24, 0x02	; 2
    5634:	9e 01       	movw	r18, r28
    5636:	27 5f       	subi	r18, 0xF7	; 247
    5638:	3f 4f       	sbci	r19, 0xFF	; 255
    563a:	b9 01       	movw	r22, r18
    563c:	0e 94 87 33 	call	0x670e	; 0x670e <xTaskCheckForTimeOut>
    5640:	88 23       	and	r24, r24
    5642:	09 f5       	brne	.+66     	; 0x5686 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    5644:	8d 81       	ldd	r24, Y+5	; 0x05
    5646:	9e 81       	ldd	r25, Y+6	; 0x06
    5648:	0e 94 55 2e 	call	0x5caa	; 0x5caa <prvIsQueueFull>
    564c:	88 23       	and	r24, r24
    564e:	a1 f0       	breq	.+40     	; 0x5678 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    5650:	8d 81       	ldd	r24, Y+5	; 0x05
    5652:	9e 81       	ldd	r25, Y+6	; 0x06
    5654:	08 96       	adiw	r24, 0x08	; 8
    5656:	29 85       	ldd	r18, Y+9	; 0x09
    5658:	3a 85       	ldd	r19, Y+10	; 0x0a
    565a:	b9 01       	movw	r22, r18
    565c:	0e 94 d0 32 	call	0x65a0	; 0x65a0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    5660:	8d 81       	ldd	r24, Y+5	; 0x05
    5662:	9e 81       	ldd	r25, Y+6	; 0x06
    5664:	0e 94 ce 2d 	call	0x5b9c	; 0x5b9c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    5668:	0e 94 d6 30 	call	0x61ac	; 0x61ac <xTaskResumeAll>
    566c:	88 23       	and	r24, r24
    566e:	09 f0       	breq	.+2      	; 0x5672 <xQueueGenericSend+0x106>
    5670:	8f cf       	rjmp	.-226    	; 0x5590 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    5672:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <vPortYield>
    5676:	8c cf       	rjmp	.-232    	; 0x5590 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5678:	8d 81       	ldd	r24, Y+5	; 0x05
    567a:	9e 81       	ldd	r25, Y+6	; 0x06
    567c:	0e 94 ce 2d 	call	0x5b9c	; 0x5b9c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5680:	0e 94 d6 30 	call	0x61ac	; 0x61ac <xTaskResumeAll>
    5684:	85 cf       	rjmp	.-246    	; 0x5590 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    5686:	8d 81       	ldd	r24, Y+5	; 0x05
    5688:	9e 81       	ldd	r25, Y+6	; 0x06
    568a:	0e 94 ce 2d 	call	0x5b9c	; 0x5b9c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    568e:	0e 94 d6 30 	call	0x61ac	; 0x61ac <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    5692:	1c 86       	std	Y+12, r1	; 0x0c
    5694:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    5696:	2c 96       	adiw	r28, 0x0c	; 12
    5698:	0f b6       	in	r0, 0x3f	; 63
    569a:	f8 94       	cli
    569c:	de bf       	out	0x3e, r29	; 62
    569e:	0f be       	out	0x3f, r0	; 63
    56a0:	cd bf       	out	0x3d, r28	; 61
    56a2:	cf 91       	pop	r28
    56a4:	df 91       	pop	r29
    56a6:	08 95       	ret

000056a8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    56a8:	df 93       	push	r29
    56aa:	cf 93       	push	r28
    56ac:	cd b7       	in	r28, 0x3d	; 61
    56ae:	de b7       	in	r29, 0x3e	; 62
    56b0:	29 97       	sbiw	r28, 0x09	; 9
    56b2:	0f b6       	in	r0, 0x3f	; 63
    56b4:	f8 94       	cli
    56b6:	de bf       	out	0x3e, r29	; 62
    56b8:	0f be       	out	0x3f, r0	; 63
    56ba:	cd bf       	out	0x3d, r28	; 61
    56bc:	9c 83       	std	Y+4, r25	; 0x04
    56be:	8b 83       	std	Y+3, r24	; 0x03
    56c0:	7e 83       	std	Y+6, r23	; 0x06
    56c2:	6d 83       	std	Y+5, r22	; 0x05
    56c4:	58 87       	std	Y+8, r21	; 0x08
    56c6:	4f 83       	std	Y+7, r20	; 0x07
    56c8:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    56ca:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    56cc:	eb 81       	ldd	r30, Y+3	; 0x03
    56ce:	fc 81       	ldd	r31, Y+4	; 0x04
    56d0:	92 8d       	ldd	r25, Z+26	; 0x1a
    56d2:	eb 81       	ldd	r30, Y+3	; 0x03
    56d4:	fc 81       	ldd	r31, Y+4	; 0x04
    56d6:	83 8d       	ldd	r24, Z+27	; 0x1b
    56d8:	98 17       	cp	r25, r24
    56da:	40 f5       	brcc	.+80     	; 0x572c <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    56dc:	8b 81       	ldd	r24, Y+3	; 0x03
    56de:	9c 81       	ldd	r25, Y+4	; 0x04
    56e0:	2d 81       	ldd	r18, Y+5	; 0x05
    56e2:	3e 81       	ldd	r19, Y+6	; 0x06
    56e4:	b9 01       	movw	r22, r18
    56e6:	49 85       	ldd	r20, Y+9	; 0x09
    56e8:	0e 94 f1 2c 	call	0x59e2	; 0x59e2 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    56ec:	eb 81       	ldd	r30, Y+3	; 0x03
    56ee:	fc 81       	ldd	r31, Y+4	; 0x04
    56f0:	86 8d       	ldd	r24, Z+30	; 0x1e
    56f2:	8f 3f       	cpi	r24, 0xFF	; 255
    56f4:	89 f4       	brne	.+34     	; 0x5718 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    56f6:	eb 81       	ldd	r30, Y+3	; 0x03
    56f8:	fc 81       	ldd	r31, Y+4	; 0x04
    56fa:	81 89       	ldd	r24, Z+17	; 0x11
    56fc:	88 23       	and	r24, r24
    56fe:	99 f0       	breq	.+38     	; 0x5726 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5700:	8b 81       	ldd	r24, Y+3	; 0x03
    5702:	9c 81       	ldd	r25, Y+4	; 0x04
    5704:	41 96       	adiw	r24, 0x11	; 17
    5706:	0e 94 06 33 	call	0x660c	; 0x660c <xTaskRemoveFromEventList>
    570a:	88 23       	and	r24, r24
    570c:	61 f0       	breq	.+24     	; 0x5726 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    570e:	ef 81       	ldd	r30, Y+7	; 0x07
    5710:	f8 85       	ldd	r31, Y+8	; 0x08
    5712:	81 e0       	ldi	r24, 0x01	; 1
    5714:	80 83       	st	Z, r24
    5716:	07 c0       	rjmp	.+14     	; 0x5726 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    5718:	eb 81       	ldd	r30, Y+3	; 0x03
    571a:	fc 81       	ldd	r31, Y+4	; 0x04
    571c:	86 8d       	ldd	r24, Z+30	; 0x1e
    571e:	8f 5f       	subi	r24, 0xFF	; 255
    5720:	eb 81       	ldd	r30, Y+3	; 0x03
    5722:	fc 81       	ldd	r31, Y+4	; 0x04
    5724:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    5726:	81 e0       	ldi	r24, 0x01	; 1
    5728:	8a 83       	std	Y+2, r24	; 0x02
    572a:	01 c0       	rjmp	.+2      	; 0x572e <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    572c:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    572e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5730:	29 96       	adiw	r28, 0x09	; 9
    5732:	0f b6       	in	r0, 0x3f	; 63
    5734:	f8 94       	cli
    5736:	de bf       	out	0x3e, r29	; 62
    5738:	0f be       	out	0x3f, r0	; 63
    573a:	cd bf       	out	0x3d, r28	; 61
    573c:	cf 91       	pop	r28
    573e:	df 91       	pop	r29
    5740:	08 95       	ret

00005742 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    5742:	df 93       	push	r29
    5744:	cf 93       	push	r28
    5746:	cd b7       	in	r28, 0x3d	; 61
    5748:	de b7       	in	r29, 0x3e	; 62
    574a:	2e 97       	sbiw	r28, 0x0e	; 14
    574c:	0f b6       	in	r0, 0x3f	; 63
    574e:	f8 94       	cli
    5750:	de bf       	out	0x3e, r29	; 62
    5752:	0f be       	out	0x3f, r0	; 63
    5754:	cd bf       	out	0x3d, r28	; 61
    5756:	98 87       	std	Y+8, r25	; 0x08
    5758:	8f 83       	std	Y+7, r24	; 0x07
    575a:	7a 87       	std	Y+10, r23	; 0x0a
    575c:	69 87       	std	Y+9, r22	; 0x09
    575e:	5c 87       	std	Y+12, r21	; 0x0c
    5760:	4b 87       	std	Y+11, r20	; 0x0b
    5762:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    5764:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    5766:	0f b6       	in	r0, 0x3f	; 63
    5768:	f8 94       	cli
    576a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    576c:	ef 81       	ldd	r30, Y+7	; 0x07
    576e:	f8 85       	ldd	r31, Y+8	; 0x08
    5770:	82 8d       	ldd	r24, Z+26	; 0x1a
    5772:	88 23       	and	r24, r24
    5774:	09 f4       	brne	.+2      	; 0x5778 <xQueueGenericReceive+0x36>
    5776:	3f c0       	rjmp	.+126    	; 0x57f6 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    5778:	ef 81       	ldd	r30, Y+7	; 0x07
    577a:	f8 85       	ldd	r31, Y+8	; 0x08
    577c:	86 81       	ldd	r24, Z+6	; 0x06
    577e:	97 81       	ldd	r25, Z+7	; 0x07
    5780:	9a 83       	std	Y+2, r25	; 0x02
    5782:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    5784:	8f 81       	ldd	r24, Y+7	; 0x07
    5786:	98 85       	ldd	r25, Y+8	; 0x08
    5788:	29 85       	ldd	r18, Y+9	; 0x09
    578a:	3a 85       	ldd	r19, Y+10	; 0x0a
    578c:	b9 01       	movw	r22, r18
    578e:	0e 94 86 2d 	call	0x5b0c	; 0x5b0c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    5792:	8d 85       	ldd	r24, Y+13	; 0x0d
    5794:	88 23       	and	r24, r24
    5796:	b1 f4       	brne	.+44     	; 0x57c4 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    5798:	ef 81       	ldd	r30, Y+7	; 0x07
    579a:	f8 85       	ldd	r31, Y+8	; 0x08
    579c:	82 8d       	ldd	r24, Z+26	; 0x1a
    579e:	81 50       	subi	r24, 0x01	; 1
    57a0:	ef 81       	ldd	r30, Y+7	; 0x07
    57a2:	f8 85       	ldd	r31, Y+8	; 0x08
    57a4:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    57a6:	ef 81       	ldd	r30, Y+7	; 0x07
    57a8:	f8 85       	ldd	r31, Y+8	; 0x08
    57aa:	80 85       	ldd	r24, Z+8	; 0x08
    57ac:	88 23       	and	r24, r24
    57ae:	f1 f0       	breq	.+60     	; 0x57ec <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    57b0:	8f 81       	ldd	r24, Y+7	; 0x07
    57b2:	98 85       	ldd	r25, Y+8	; 0x08
    57b4:	08 96       	adiw	r24, 0x08	; 8
    57b6:	0e 94 06 33 	call	0x660c	; 0x660c <xTaskRemoveFromEventList>
    57ba:	81 30       	cpi	r24, 0x01	; 1
    57bc:	b9 f4       	brne	.+46     	; 0x57ec <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    57be:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <vPortYield>
    57c2:	14 c0       	rjmp	.+40     	; 0x57ec <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    57c4:	ef 81       	ldd	r30, Y+7	; 0x07
    57c6:	f8 85       	ldd	r31, Y+8	; 0x08
    57c8:	89 81       	ldd	r24, Y+1	; 0x01
    57ca:	9a 81       	ldd	r25, Y+2	; 0x02
    57cc:	97 83       	std	Z+7, r25	; 0x07
    57ce:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    57d0:	ef 81       	ldd	r30, Y+7	; 0x07
    57d2:	f8 85       	ldd	r31, Y+8	; 0x08
    57d4:	81 89       	ldd	r24, Z+17	; 0x11
    57d6:	88 23       	and	r24, r24
    57d8:	49 f0       	breq	.+18     	; 0x57ec <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    57da:	8f 81       	ldd	r24, Y+7	; 0x07
    57dc:	98 85       	ldd	r25, Y+8	; 0x08
    57de:	41 96       	adiw	r24, 0x11	; 17
    57e0:	0e 94 06 33 	call	0x660c	; 0x660c <xTaskRemoveFromEventList>
    57e4:	88 23       	and	r24, r24
    57e6:	11 f0       	breq	.+4      	; 0x57ec <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    57e8:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    57ec:	0f 90       	pop	r0
    57ee:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    57f0:	81 e0       	ldi	r24, 0x01	; 1
    57f2:	8e 87       	std	Y+14, r24	; 0x0e
    57f4:	5c c0       	rjmp	.+184    	; 0x58ae <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    57f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    57f8:	9c 85       	ldd	r25, Y+12	; 0x0c
    57fa:	00 97       	sbiw	r24, 0x00	; 0
    57fc:	21 f4       	brne	.+8      	; 0x5806 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    57fe:	0f 90       	pop	r0
    5800:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    5802:	1e 86       	std	Y+14, r1	; 0x0e
    5804:	54 c0       	rjmp	.+168    	; 0x58ae <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    5806:	8b 81       	ldd	r24, Y+3	; 0x03
    5808:	88 23       	and	r24, r24
    580a:	31 f4       	brne	.+12     	; 0x5818 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    580c:	ce 01       	movw	r24, r28
    580e:	04 96       	adiw	r24, 0x04	; 4
    5810:	0e 94 6e 33 	call	0x66dc	; 0x66dc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5814:	81 e0       	ldi	r24, 0x01	; 1
    5816:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    5818:	0f 90       	pop	r0
    581a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    581c:	0e 94 ca 30 	call	0x6194	; 0x6194 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5820:	0f b6       	in	r0, 0x3f	; 63
    5822:	f8 94       	cli
    5824:	0f 92       	push	r0
    5826:	ef 81       	ldd	r30, Y+7	; 0x07
    5828:	f8 85       	ldd	r31, Y+8	; 0x08
    582a:	85 8d       	ldd	r24, Z+29	; 0x1d
    582c:	8f 3f       	cpi	r24, 0xFF	; 255
    582e:	19 f4       	brne	.+6      	; 0x5836 <xQueueGenericReceive+0xf4>
    5830:	ef 81       	ldd	r30, Y+7	; 0x07
    5832:	f8 85       	ldd	r31, Y+8	; 0x08
    5834:	15 8e       	std	Z+29, r1	; 0x1d
    5836:	ef 81       	ldd	r30, Y+7	; 0x07
    5838:	f8 85       	ldd	r31, Y+8	; 0x08
    583a:	86 8d       	ldd	r24, Z+30	; 0x1e
    583c:	8f 3f       	cpi	r24, 0xFF	; 255
    583e:	19 f4       	brne	.+6      	; 0x5846 <xQueueGenericReceive+0x104>
    5840:	ef 81       	ldd	r30, Y+7	; 0x07
    5842:	f8 85       	ldd	r31, Y+8	; 0x08
    5844:	16 8e       	std	Z+30, r1	; 0x1e
    5846:	0f 90       	pop	r0
    5848:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    584a:	ce 01       	movw	r24, r28
    584c:	04 96       	adiw	r24, 0x04	; 4
    584e:	9e 01       	movw	r18, r28
    5850:	25 5f       	subi	r18, 0xF5	; 245
    5852:	3f 4f       	sbci	r19, 0xFF	; 255
    5854:	b9 01       	movw	r22, r18
    5856:	0e 94 87 33 	call	0x670e	; 0x670e <xTaskCheckForTimeOut>
    585a:	88 23       	and	r24, r24
    585c:	09 f5       	brne	.+66     	; 0x58a0 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    585e:	8f 81       	ldd	r24, Y+7	; 0x07
    5860:	98 85       	ldd	r25, Y+8	; 0x08
    5862:	0e 94 22 2e 	call	0x5c44	; 0x5c44 <prvIsQueueEmpty>
    5866:	88 23       	and	r24, r24
    5868:	a1 f0       	breq	.+40     	; 0x5892 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    586a:	8f 81       	ldd	r24, Y+7	; 0x07
    586c:	98 85       	ldd	r25, Y+8	; 0x08
    586e:	41 96       	adiw	r24, 0x11	; 17
    5870:	2b 85       	ldd	r18, Y+11	; 0x0b
    5872:	3c 85       	ldd	r19, Y+12	; 0x0c
    5874:	b9 01       	movw	r22, r18
    5876:	0e 94 d0 32 	call	0x65a0	; 0x65a0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    587a:	8f 81       	ldd	r24, Y+7	; 0x07
    587c:	98 85       	ldd	r25, Y+8	; 0x08
    587e:	0e 94 ce 2d 	call	0x5b9c	; 0x5b9c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    5882:	0e 94 d6 30 	call	0x61ac	; 0x61ac <xTaskResumeAll>
    5886:	88 23       	and	r24, r24
    5888:	09 f0       	breq	.+2      	; 0x588c <xQueueGenericReceive+0x14a>
    588a:	6d cf       	rjmp	.-294    	; 0x5766 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    588c:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <vPortYield>
    5890:	6a cf       	rjmp	.-300    	; 0x5766 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5892:	8f 81       	ldd	r24, Y+7	; 0x07
    5894:	98 85       	ldd	r25, Y+8	; 0x08
    5896:	0e 94 ce 2d 	call	0x5b9c	; 0x5b9c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    589a:	0e 94 d6 30 	call	0x61ac	; 0x61ac <xTaskResumeAll>
    589e:	63 cf       	rjmp	.-314    	; 0x5766 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    58a0:	8f 81       	ldd	r24, Y+7	; 0x07
    58a2:	98 85       	ldd	r25, Y+8	; 0x08
    58a4:	0e 94 ce 2d 	call	0x5b9c	; 0x5b9c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    58a8:	0e 94 d6 30 	call	0x61ac	; 0x61ac <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    58ac:	1e 86       	std	Y+14, r1	; 0x0e
    58ae:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    58b0:	2e 96       	adiw	r28, 0x0e	; 14
    58b2:	0f b6       	in	r0, 0x3f	; 63
    58b4:	f8 94       	cli
    58b6:	de bf       	out	0x3e, r29	; 62
    58b8:	0f be       	out	0x3f, r0	; 63
    58ba:	cd bf       	out	0x3d, r28	; 61
    58bc:	cf 91       	pop	r28
    58be:	df 91       	pop	r29
    58c0:	08 95       	ret

000058c2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    58c2:	df 93       	push	r29
    58c4:	cf 93       	push	r28
    58c6:	cd b7       	in	r28, 0x3d	; 61
    58c8:	de b7       	in	r29, 0x3e	; 62
    58ca:	28 97       	sbiw	r28, 0x08	; 8
    58cc:	0f b6       	in	r0, 0x3f	; 63
    58ce:	f8 94       	cli
    58d0:	de bf       	out	0x3e, r29	; 62
    58d2:	0f be       	out	0x3f, r0	; 63
    58d4:	cd bf       	out	0x3d, r28	; 61
    58d6:	9c 83       	std	Y+4, r25	; 0x04
    58d8:	8b 83       	std	Y+3, r24	; 0x03
    58da:	7e 83       	std	Y+6, r23	; 0x06
    58dc:	6d 83       	std	Y+5, r22	; 0x05
    58de:	58 87       	std	Y+8, r21	; 0x08
    58e0:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    58e2:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    58e4:	eb 81       	ldd	r30, Y+3	; 0x03
    58e6:	fc 81       	ldd	r31, Y+4	; 0x04
    58e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    58ea:	88 23       	and	r24, r24
    58ec:	71 f1       	breq	.+92     	; 0x594a <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    58ee:	8b 81       	ldd	r24, Y+3	; 0x03
    58f0:	9c 81       	ldd	r25, Y+4	; 0x04
    58f2:	2d 81       	ldd	r18, Y+5	; 0x05
    58f4:	3e 81       	ldd	r19, Y+6	; 0x06
    58f6:	b9 01       	movw	r22, r18
    58f8:	0e 94 86 2d 	call	0x5b0c	; 0x5b0c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    58fc:	eb 81       	ldd	r30, Y+3	; 0x03
    58fe:	fc 81       	ldd	r31, Y+4	; 0x04
    5900:	82 8d       	ldd	r24, Z+26	; 0x1a
    5902:	81 50       	subi	r24, 0x01	; 1
    5904:	eb 81       	ldd	r30, Y+3	; 0x03
    5906:	fc 81       	ldd	r31, Y+4	; 0x04
    5908:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    590a:	eb 81       	ldd	r30, Y+3	; 0x03
    590c:	fc 81       	ldd	r31, Y+4	; 0x04
    590e:	85 8d       	ldd	r24, Z+29	; 0x1d
    5910:	8f 3f       	cpi	r24, 0xFF	; 255
    5912:	89 f4       	brne	.+34     	; 0x5936 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5914:	eb 81       	ldd	r30, Y+3	; 0x03
    5916:	fc 81       	ldd	r31, Y+4	; 0x04
    5918:	80 85       	ldd	r24, Z+8	; 0x08
    591a:	88 23       	and	r24, r24
    591c:	99 f0       	breq	.+38     	; 0x5944 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    591e:	8b 81       	ldd	r24, Y+3	; 0x03
    5920:	9c 81       	ldd	r25, Y+4	; 0x04
    5922:	08 96       	adiw	r24, 0x08	; 8
    5924:	0e 94 06 33 	call	0x660c	; 0x660c <xTaskRemoveFromEventList>
    5928:	88 23       	and	r24, r24
    592a:	61 f0       	breq	.+24     	; 0x5944 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    592c:	ef 81       	ldd	r30, Y+7	; 0x07
    592e:	f8 85       	ldd	r31, Y+8	; 0x08
    5930:	81 e0       	ldi	r24, 0x01	; 1
    5932:	80 83       	st	Z, r24
    5934:	07 c0       	rjmp	.+14     	; 0x5944 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    5936:	eb 81       	ldd	r30, Y+3	; 0x03
    5938:	fc 81       	ldd	r31, Y+4	; 0x04
    593a:	85 8d       	ldd	r24, Z+29	; 0x1d
    593c:	8f 5f       	subi	r24, 0xFF	; 255
    593e:	eb 81       	ldd	r30, Y+3	; 0x03
    5940:	fc 81       	ldd	r31, Y+4	; 0x04
    5942:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    5944:	81 e0       	ldi	r24, 0x01	; 1
    5946:	8a 83       	std	Y+2, r24	; 0x02
    5948:	01 c0       	rjmp	.+2      	; 0x594c <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    594a:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    594c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    594e:	28 96       	adiw	r28, 0x08	; 8
    5950:	0f b6       	in	r0, 0x3f	; 63
    5952:	f8 94       	cli
    5954:	de bf       	out	0x3e, r29	; 62
    5956:	0f be       	out	0x3f, r0	; 63
    5958:	cd bf       	out	0x3d, r28	; 61
    595a:	cf 91       	pop	r28
    595c:	df 91       	pop	r29
    595e:	08 95       	ret

00005960 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    5960:	df 93       	push	r29
    5962:	cf 93       	push	r28
    5964:	00 d0       	rcall	.+0      	; 0x5966 <uxQueueMessagesWaiting+0x6>
    5966:	0f 92       	push	r0
    5968:	cd b7       	in	r28, 0x3d	; 61
    596a:	de b7       	in	r29, 0x3e	; 62
    596c:	9b 83       	std	Y+3, r25	; 0x03
    596e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    5970:	0f b6       	in	r0, 0x3f	; 63
    5972:	f8 94       	cli
    5974:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    5976:	ea 81       	ldd	r30, Y+2	; 0x02
    5978:	fb 81       	ldd	r31, Y+3	; 0x03
    597a:	82 8d       	ldd	r24, Z+26	; 0x1a
    597c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    597e:	0f 90       	pop	r0
    5980:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    5982:	89 81       	ldd	r24, Y+1	; 0x01
}
    5984:	0f 90       	pop	r0
    5986:	0f 90       	pop	r0
    5988:	0f 90       	pop	r0
    598a:	cf 91       	pop	r28
    598c:	df 91       	pop	r29
    598e:	08 95       	ret

00005990 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    5990:	df 93       	push	r29
    5992:	cf 93       	push	r28
    5994:	00 d0       	rcall	.+0      	; 0x5996 <uxQueueMessagesWaitingFromISR+0x6>
    5996:	0f 92       	push	r0
    5998:	cd b7       	in	r28, 0x3d	; 61
    599a:	de b7       	in	r29, 0x3e	; 62
    599c:	9b 83       	std	Y+3, r25	; 0x03
    599e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    59a0:	ea 81       	ldd	r30, Y+2	; 0x02
    59a2:	fb 81       	ldd	r31, Y+3	; 0x03
    59a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    59a6:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    59a8:	89 81       	ldd	r24, Y+1	; 0x01
}
    59aa:	0f 90       	pop	r0
    59ac:	0f 90       	pop	r0
    59ae:	0f 90       	pop	r0
    59b0:	cf 91       	pop	r28
    59b2:	df 91       	pop	r29
    59b4:	08 95       	ret

000059b6 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    59b6:	df 93       	push	r29
    59b8:	cf 93       	push	r28
    59ba:	00 d0       	rcall	.+0      	; 0x59bc <vQueueDelete+0x6>
    59bc:	cd b7       	in	r28, 0x3d	; 61
    59be:	de b7       	in	r29, 0x3e	; 62
    59c0:	9a 83       	std	Y+2, r25	; 0x02
    59c2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    59c4:	e9 81       	ldd	r30, Y+1	; 0x01
    59c6:	fa 81       	ldd	r31, Y+2	; 0x02
    59c8:	80 81       	ld	r24, Z
    59ca:	91 81       	ldd	r25, Z+1	; 0x01
    59cc:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortFree>
	vPortFree( pxQueue );
    59d0:	89 81       	ldd	r24, Y+1	; 0x01
    59d2:	9a 81       	ldd	r25, Y+2	; 0x02
    59d4:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortFree>
}
    59d8:	0f 90       	pop	r0
    59da:	0f 90       	pop	r0
    59dc:	cf 91       	pop	r28
    59de:	df 91       	pop	r29
    59e0:	08 95       	ret

000059e2 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    59e2:	df 93       	push	r29
    59e4:	cf 93       	push	r28
    59e6:	00 d0       	rcall	.+0      	; 0x59e8 <prvCopyDataToQueue+0x6>
    59e8:	00 d0       	rcall	.+0      	; 0x59ea <prvCopyDataToQueue+0x8>
    59ea:	0f 92       	push	r0
    59ec:	cd b7       	in	r28, 0x3d	; 61
    59ee:	de b7       	in	r29, 0x3e	; 62
    59f0:	9a 83       	std	Y+2, r25	; 0x02
    59f2:	89 83       	std	Y+1, r24	; 0x01
    59f4:	7c 83       	std	Y+4, r23	; 0x04
    59f6:	6b 83       	std	Y+3, r22	; 0x03
    59f8:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    59fa:	e9 81       	ldd	r30, Y+1	; 0x01
    59fc:	fa 81       	ldd	r31, Y+2	; 0x02
    59fe:	84 8d       	ldd	r24, Z+28	; 0x1c
    5a00:	88 23       	and	r24, r24
    5a02:	09 f4       	brne	.+2      	; 0x5a06 <prvCopyDataToQueue+0x24>
    5a04:	74 c0       	rjmp	.+232    	; 0x5aee <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    5a06:	8d 81       	ldd	r24, Y+5	; 0x05
    5a08:	88 23       	and	r24, r24
    5a0a:	99 f5       	brne	.+102    	; 0x5a72 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    5a0c:	e9 81       	ldd	r30, Y+1	; 0x01
    5a0e:	fa 81       	ldd	r31, Y+2	; 0x02
    5a10:	64 81       	ldd	r22, Z+4	; 0x04
    5a12:	75 81       	ldd	r23, Z+5	; 0x05
    5a14:	e9 81       	ldd	r30, Y+1	; 0x01
    5a16:	fa 81       	ldd	r31, Y+2	; 0x02
    5a18:	84 8d       	ldd	r24, Z+28	; 0x1c
    5a1a:	48 2f       	mov	r20, r24
    5a1c:	50 e0       	ldi	r21, 0x00	; 0
    5a1e:	2b 81       	ldd	r18, Y+3	; 0x03
    5a20:	3c 81       	ldd	r19, Y+4	; 0x04
    5a22:	cb 01       	movw	r24, r22
    5a24:	b9 01       	movw	r22, r18
    5a26:	0e 94 f1 35 	call	0x6be2	; 0x6be2 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    5a2a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a2c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a2e:	24 81       	ldd	r18, Z+4	; 0x04
    5a30:	35 81       	ldd	r19, Z+5	; 0x05
    5a32:	e9 81       	ldd	r30, Y+1	; 0x01
    5a34:	fa 81       	ldd	r31, Y+2	; 0x02
    5a36:	84 8d       	ldd	r24, Z+28	; 0x1c
    5a38:	88 2f       	mov	r24, r24
    5a3a:	90 e0       	ldi	r25, 0x00	; 0
    5a3c:	82 0f       	add	r24, r18
    5a3e:	93 1f       	adc	r25, r19
    5a40:	e9 81       	ldd	r30, Y+1	; 0x01
    5a42:	fa 81       	ldd	r31, Y+2	; 0x02
    5a44:	95 83       	std	Z+5, r25	; 0x05
    5a46:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    5a48:	e9 81       	ldd	r30, Y+1	; 0x01
    5a4a:	fa 81       	ldd	r31, Y+2	; 0x02
    5a4c:	24 81       	ldd	r18, Z+4	; 0x04
    5a4e:	35 81       	ldd	r19, Z+5	; 0x05
    5a50:	e9 81       	ldd	r30, Y+1	; 0x01
    5a52:	fa 81       	ldd	r31, Y+2	; 0x02
    5a54:	82 81       	ldd	r24, Z+2	; 0x02
    5a56:	93 81       	ldd	r25, Z+3	; 0x03
    5a58:	28 17       	cp	r18, r24
    5a5a:	39 07       	cpc	r19, r25
    5a5c:	08 f4       	brcc	.+2      	; 0x5a60 <prvCopyDataToQueue+0x7e>
    5a5e:	47 c0       	rjmp	.+142    	; 0x5aee <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    5a60:	e9 81       	ldd	r30, Y+1	; 0x01
    5a62:	fa 81       	ldd	r31, Y+2	; 0x02
    5a64:	80 81       	ld	r24, Z
    5a66:	91 81       	ldd	r25, Z+1	; 0x01
    5a68:	e9 81       	ldd	r30, Y+1	; 0x01
    5a6a:	fa 81       	ldd	r31, Y+2	; 0x02
    5a6c:	95 83       	std	Z+5, r25	; 0x05
    5a6e:	84 83       	std	Z+4, r24	; 0x04
    5a70:	3e c0       	rjmp	.+124    	; 0x5aee <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    5a72:	e9 81       	ldd	r30, Y+1	; 0x01
    5a74:	fa 81       	ldd	r31, Y+2	; 0x02
    5a76:	66 81       	ldd	r22, Z+6	; 0x06
    5a78:	77 81       	ldd	r23, Z+7	; 0x07
    5a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a7e:	84 8d       	ldd	r24, Z+28	; 0x1c
    5a80:	48 2f       	mov	r20, r24
    5a82:	50 e0       	ldi	r21, 0x00	; 0
    5a84:	2b 81       	ldd	r18, Y+3	; 0x03
    5a86:	3c 81       	ldd	r19, Y+4	; 0x04
    5a88:	cb 01       	movw	r24, r22
    5a8a:	b9 01       	movw	r22, r18
    5a8c:	0e 94 f1 35 	call	0x6be2	; 0x6be2 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    5a90:	e9 81       	ldd	r30, Y+1	; 0x01
    5a92:	fa 81       	ldd	r31, Y+2	; 0x02
    5a94:	26 81       	ldd	r18, Z+6	; 0x06
    5a96:	37 81       	ldd	r19, Z+7	; 0x07
    5a98:	e9 81       	ldd	r30, Y+1	; 0x01
    5a9a:	fa 81       	ldd	r31, Y+2	; 0x02
    5a9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    5a9e:	88 2f       	mov	r24, r24
    5aa0:	90 e0       	ldi	r25, 0x00	; 0
    5aa2:	90 95       	com	r25
    5aa4:	81 95       	neg	r24
    5aa6:	9f 4f       	sbci	r25, 0xFF	; 255
    5aa8:	82 0f       	add	r24, r18
    5aaa:	93 1f       	adc	r25, r19
    5aac:	e9 81       	ldd	r30, Y+1	; 0x01
    5aae:	fa 81       	ldd	r31, Y+2	; 0x02
    5ab0:	97 83       	std	Z+7, r25	; 0x07
    5ab2:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    5ab4:	e9 81       	ldd	r30, Y+1	; 0x01
    5ab6:	fa 81       	ldd	r31, Y+2	; 0x02
    5ab8:	26 81       	ldd	r18, Z+6	; 0x06
    5aba:	37 81       	ldd	r19, Z+7	; 0x07
    5abc:	e9 81       	ldd	r30, Y+1	; 0x01
    5abe:	fa 81       	ldd	r31, Y+2	; 0x02
    5ac0:	80 81       	ld	r24, Z
    5ac2:	91 81       	ldd	r25, Z+1	; 0x01
    5ac4:	28 17       	cp	r18, r24
    5ac6:	39 07       	cpc	r19, r25
    5ac8:	90 f4       	brcc	.+36     	; 0x5aee <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    5aca:	e9 81       	ldd	r30, Y+1	; 0x01
    5acc:	fa 81       	ldd	r31, Y+2	; 0x02
    5ace:	22 81       	ldd	r18, Z+2	; 0x02
    5ad0:	33 81       	ldd	r19, Z+3	; 0x03
    5ad2:	e9 81       	ldd	r30, Y+1	; 0x01
    5ad4:	fa 81       	ldd	r31, Y+2	; 0x02
    5ad6:	84 8d       	ldd	r24, Z+28	; 0x1c
    5ad8:	88 2f       	mov	r24, r24
    5ada:	90 e0       	ldi	r25, 0x00	; 0
    5adc:	90 95       	com	r25
    5ade:	81 95       	neg	r24
    5ae0:	9f 4f       	sbci	r25, 0xFF	; 255
    5ae2:	82 0f       	add	r24, r18
    5ae4:	93 1f       	adc	r25, r19
    5ae6:	e9 81       	ldd	r30, Y+1	; 0x01
    5ae8:	fa 81       	ldd	r31, Y+2	; 0x02
    5aea:	97 83       	std	Z+7, r25	; 0x07
    5aec:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    5aee:	e9 81       	ldd	r30, Y+1	; 0x01
    5af0:	fa 81       	ldd	r31, Y+2	; 0x02
    5af2:	82 8d       	ldd	r24, Z+26	; 0x1a
    5af4:	8f 5f       	subi	r24, 0xFF	; 255
    5af6:	e9 81       	ldd	r30, Y+1	; 0x01
    5af8:	fa 81       	ldd	r31, Y+2	; 0x02
    5afa:	82 8f       	std	Z+26, r24	; 0x1a
}
    5afc:	0f 90       	pop	r0
    5afe:	0f 90       	pop	r0
    5b00:	0f 90       	pop	r0
    5b02:	0f 90       	pop	r0
    5b04:	0f 90       	pop	r0
    5b06:	cf 91       	pop	r28
    5b08:	df 91       	pop	r29
    5b0a:	08 95       	ret

00005b0c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    5b0c:	df 93       	push	r29
    5b0e:	cf 93       	push	r28
    5b10:	00 d0       	rcall	.+0      	; 0x5b12 <prvCopyDataFromQueue+0x6>
    5b12:	00 d0       	rcall	.+0      	; 0x5b14 <prvCopyDataFromQueue+0x8>
    5b14:	cd b7       	in	r28, 0x3d	; 61
    5b16:	de b7       	in	r29, 0x3e	; 62
    5b18:	9a 83       	std	Y+2, r25	; 0x02
    5b1a:	89 83       	std	Y+1, r24	; 0x01
    5b1c:	7c 83       	std	Y+4, r23	; 0x04
    5b1e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    5b20:	e9 81       	ldd	r30, Y+1	; 0x01
    5b22:	fa 81       	ldd	r31, Y+2	; 0x02
    5b24:	80 81       	ld	r24, Z
    5b26:	91 81       	ldd	r25, Z+1	; 0x01
    5b28:	00 97       	sbiw	r24, 0x00	; 0
    5b2a:	89 f1       	breq	.+98     	; 0x5b8e <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    5b2c:	e9 81       	ldd	r30, Y+1	; 0x01
    5b2e:	fa 81       	ldd	r31, Y+2	; 0x02
    5b30:	26 81       	ldd	r18, Z+6	; 0x06
    5b32:	37 81       	ldd	r19, Z+7	; 0x07
    5b34:	e9 81       	ldd	r30, Y+1	; 0x01
    5b36:	fa 81       	ldd	r31, Y+2	; 0x02
    5b38:	84 8d       	ldd	r24, Z+28	; 0x1c
    5b3a:	88 2f       	mov	r24, r24
    5b3c:	90 e0       	ldi	r25, 0x00	; 0
    5b3e:	82 0f       	add	r24, r18
    5b40:	93 1f       	adc	r25, r19
    5b42:	e9 81       	ldd	r30, Y+1	; 0x01
    5b44:	fa 81       	ldd	r31, Y+2	; 0x02
    5b46:	97 83       	std	Z+7, r25	; 0x07
    5b48:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    5b4a:	e9 81       	ldd	r30, Y+1	; 0x01
    5b4c:	fa 81       	ldd	r31, Y+2	; 0x02
    5b4e:	26 81       	ldd	r18, Z+6	; 0x06
    5b50:	37 81       	ldd	r19, Z+7	; 0x07
    5b52:	e9 81       	ldd	r30, Y+1	; 0x01
    5b54:	fa 81       	ldd	r31, Y+2	; 0x02
    5b56:	82 81       	ldd	r24, Z+2	; 0x02
    5b58:	93 81       	ldd	r25, Z+3	; 0x03
    5b5a:	28 17       	cp	r18, r24
    5b5c:	39 07       	cpc	r19, r25
    5b5e:	40 f0       	brcs	.+16     	; 0x5b70 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    5b60:	e9 81       	ldd	r30, Y+1	; 0x01
    5b62:	fa 81       	ldd	r31, Y+2	; 0x02
    5b64:	80 81       	ld	r24, Z
    5b66:	91 81       	ldd	r25, Z+1	; 0x01
    5b68:	e9 81       	ldd	r30, Y+1	; 0x01
    5b6a:	fa 81       	ldd	r31, Y+2	; 0x02
    5b6c:	97 83       	std	Z+7, r25	; 0x07
    5b6e:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    5b70:	e9 81       	ldd	r30, Y+1	; 0x01
    5b72:	fa 81       	ldd	r31, Y+2	; 0x02
    5b74:	46 81       	ldd	r20, Z+6	; 0x06
    5b76:	57 81       	ldd	r21, Z+7	; 0x07
    5b78:	e9 81       	ldd	r30, Y+1	; 0x01
    5b7a:	fa 81       	ldd	r31, Y+2	; 0x02
    5b7c:	84 8d       	ldd	r24, Z+28	; 0x1c
    5b7e:	28 2f       	mov	r18, r24
    5b80:	30 e0       	ldi	r19, 0x00	; 0
    5b82:	8b 81       	ldd	r24, Y+3	; 0x03
    5b84:	9c 81       	ldd	r25, Y+4	; 0x04
    5b86:	ba 01       	movw	r22, r20
    5b88:	a9 01       	movw	r20, r18
    5b8a:	0e 94 f1 35 	call	0x6be2	; 0x6be2 <memcpy>
	}
}
    5b8e:	0f 90       	pop	r0
    5b90:	0f 90       	pop	r0
    5b92:	0f 90       	pop	r0
    5b94:	0f 90       	pop	r0
    5b96:	cf 91       	pop	r28
    5b98:	df 91       	pop	r29
    5b9a:	08 95       	ret

00005b9c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    5b9c:	df 93       	push	r29
    5b9e:	cf 93       	push	r28
    5ba0:	00 d0       	rcall	.+0      	; 0x5ba2 <prvUnlockQueue+0x6>
    5ba2:	cd b7       	in	r28, 0x3d	; 61
    5ba4:	de b7       	in	r29, 0x3e	; 62
    5ba6:	9a 83       	std	Y+2, r25	; 0x02
    5ba8:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    5baa:	0f b6       	in	r0, 0x3f	; 63
    5bac:	f8 94       	cli
    5bae:	0f 92       	push	r0
    5bb0:	15 c0       	rjmp	.+42     	; 0x5bdc <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5bb2:	e9 81       	ldd	r30, Y+1	; 0x01
    5bb4:	fa 81       	ldd	r31, Y+2	; 0x02
    5bb6:	81 89       	ldd	r24, Z+17	; 0x11
    5bb8:	88 23       	and	r24, r24
    5bba:	a9 f0       	breq	.+42     	; 0x5be6 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5bbc:	89 81       	ldd	r24, Y+1	; 0x01
    5bbe:	9a 81       	ldd	r25, Y+2	; 0x02
    5bc0:	41 96       	adiw	r24, 0x11	; 17
    5bc2:	0e 94 06 33 	call	0x660c	; 0x660c <xTaskRemoveFromEventList>
    5bc6:	88 23       	and	r24, r24
    5bc8:	11 f0       	breq	.+4      	; 0x5bce <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    5bca:	0e 94 e4 33 	call	0x67c8	; 0x67c8 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    5bce:	e9 81       	ldd	r30, Y+1	; 0x01
    5bd0:	fa 81       	ldd	r31, Y+2	; 0x02
    5bd2:	86 8d       	ldd	r24, Z+30	; 0x1e
    5bd4:	81 50       	subi	r24, 0x01	; 1
    5bd6:	e9 81       	ldd	r30, Y+1	; 0x01
    5bd8:	fa 81       	ldd	r31, Y+2	; 0x02
    5bda:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    5bdc:	e9 81       	ldd	r30, Y+1	; 0x01
    5bde:	fa 81       	ldd	r31, Y+2	; 0x02
    5be0:	86 8d       	ldd	r24, Z+30	; 0x1e
    5be2:	18 16       	cp	r1, r24
    5be4:	34 f3       	brlt	.-52     	; 0x5bb2 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    5be6:	e9 81       	ldd	r30, Y+1	; 0x01
    5be8:	fa 81       	ldd	r31, Y+2	; 0x02
    5bea:	8f ef       	ldi	r24, 0xFF	; 255
    5bec:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    5bee:	0f 90       	pop	r0
    5bf0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    5bf2:	0f b6       	in	r0, 0x3f	; 63
    5bf4:	f8 94       	cli
    5bf6:	0f 92       	push	r0
    5bf8:	15 c0       	rjmp	.+42     	; 0x5c24 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5bfa:	e9 81       	ldd	r30, Y+1	; 0x01
    5bfc:	fa 81       	ldd	r31, Y+2	; 0x02
    5bfe:	80 85       	ldd	r24, Z+8	; 0x08
    5c00:	88 23       	and	r24, r24
    5c02:	a9 f0       	breq	.+42     	; 0x5c2e <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5c04:	89 81       	ldd	r24, Y+1	; 0x01
    5c06:	9a 81       	ldd	r25, Y+2	; 0x02
    5c08:	08 96       	adiw	r24, 0x08	; 8
    5c0a:	0e 94 06 33 	call	0x660c	; 0x660c <xTaskRemoveFromEventList>
    5c0e:	88 23       	and	r24, r24
    5c10:	11 f0       	breq	.+4      	; 0x5c16 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    5c12:	0e 94 e4 33 	call	0x67c8	; 0x67c8 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    5c16:	e9 81       	ldd	r30, Y+1	; 0x01
    5c18:	fa 81       	ldd	r31, Y+2	; 0x02
    5c1a:	85 8d       	ldd	r24, Z+29	; 0x1d
    5c1c:	81 50       	subi	r24, 0x01	; 1
    5c1e:	e9 81       	ldd	r30, Y+1	; 0x01
    5c20:	fa 81       	ldd	r31, Y+2	; 0x02
    5c22:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    5c24:	e9 81       	ldd	r30, Y+1	; 0x01
    5c26:	fa 81       	ldd	r31, Y+2	; 0x02
    5c28:	85 8d       	ldd	r24, Z+29	; 0x1d
    5c2a:	18 16       	cp	r1, r24
    5c2c:	34 f3       	brlt	.-52     	; 0x5bfa <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    5c2e:	e9 81       	ldd	r30, Y+1	; 0x01
    5c30:	fa 81       	ldd	r31, Y+2	; 0x02
    5c32:	8f ef       	ldi	r24, 0xFF	; 255
    5c34:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    5c36:	0f 90       	pop	r0
    5c38:	0f be       	out	0x3f, r0	; 63
}
    5c3a:	0f 90       	pop	r0
    5c3c:	0f 90       	pop	r0
    5c3e:	cf 91       	pop	r28
    5c40:	df 91       	pop	r29
    5c42:	08 95       	ret

00005c44 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    5c44:	df 93       	push	r29
    5c46:	cf 93       	push	r28
    5c48:	00 d0       	rcall	.+0      	; 0x5c4a <prvIsQueueEmpty+0x6>
    5c4a:	0f 92       	push	r0
    5c4c:	cd b7       	in	r28, 0x3d	; 61
    5c4e:	de b7       	in	r29, 0x3e	; 62
    5c50:	9b 83       	std	Y+3, r25	; 0x03
    5c52:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    5c54:	0f b6       	in	r0, 0x3f	; 63
    5c56:	f8 94       	cli
    5c58:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    5c5a:	ea 81       	ldd	r30, Y+2	; 0x02
    5c5c:	fb 81       	ldd	r31, Y+3	; 0x03
    5c5e:	82 8d       	ldd	r24, Z+26	; 0x1a
    5c60:	19 82       	std	Y+1, r1	; 0x01
    5c62:	88 23       	and	r24, r24
    5c64:	11 f4       	brne	.+4      	; 0x5c6a <prvIsQueueEmpty+0x26>
    5c66:	81 e0       	ldi	r24, 0x01	; 1
    5c68:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    5c6a:	0f 90       	pop	r0
    5c6c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5c6e:	89 81       	ldd	r24, Y+1	; 0x01
}
    5c70:	0f 90       	pop	r0
    5c72:	0f 90       	pop	r0
    5c74:	0f 90       	pop	r0
    5c76:	cf 91       	pop	r28
    5c78:	df 91       	pop	r29
    5c7a:	08 95       	ret

00005c7c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    5c7c:	df 93       	push	r29
    5c7e:	cf 93       	push	r28
    5c80:	00 d0       	rcall	.+0      	; 0x5c82 <xQueueIsQueueEmptyFromISR+0x6>
    5c82:	0f 92       	push	r0
    5c84:	cd b7       	in	r28, 0x3d	; 61
    5c86:	de b7       	in	r29, 0x3e	; 62
    5c88:	9b 83       	std	Y+3, r25	; 0x03
    5c8a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    5c8c:	ea 81       	ldd	r30, Y+2	; 0x02
    5c8e:	fb 81       	ldd	r31, Y+3	; 0x03
    5c90:	82 8d       	ldd	r24, Z+26	; 0x1a
    5c92:	19 82       	std	Y+1, r1	; 0x01
    5c94:	88 23       	and	r24, r24
    5c96:	11 f4       	brne	.+4      	; 0x5c9c <xQueueIsQueueEmptyFromISR+0x20>
    5c98:	81 e0       	ldi	r24, 0x01	; 1
    5c9a:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    5c9c:	89 81       	ldd	r24, Y+1	; 0x01
}
    5c9e:	0f 90       	pop	r0
    5ca0:	0f 90       	pop	r0
    5ca2:	0f 90       	pop	r0
    5ca4:	cf 91       	pop	r28
    5ca6:	df 91       	pop	r29
    5ca8:	08 95       	ret

00005caa <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    5caa:	df 93       	push	r29
    5cac:	cf 93       	push	r28
    5cae:	00 d0       	rcall	.+0      	; 0x5cb0 <prvIsQueueFull+0x6>
    5cb0:	0f 92       	push	r0
    5cb2:	cd b7       	in	r28, 0x3d	; 61
    5cb4:	de b7       	in	r29, 0x3e	; 62
    5cb6:	9b 83       	std	Y+3, r25	; 0x03
    5cb8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    5cba:	0f b6       	in	r0, 0x3f	; 63
    5cbc:	f8 94       	cli
    5cbe:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    5cc0:	ea 81       	ldd	r30, Y+2	; 0x02
    5cc2:	fb 81       	ldd	r31, Y+3	; 0x03
    5cc4:	92 8d       	ldd	r25, Z+26	; 0x1a
    5cc6:	ea 81       	ldd	r30, Y+2	; 0x02
    5cc8:	fb 81       	ldd	r31, Y+3	; 0x03
    5cca:	83 8d       	ldd	r24, Z+27	; 0x1b
    5ccc:	19 82       	std	Y+1, r1	; 0x01
    5cce:	98 17       	cp	r25, r24
    5cd0:	11 f4       	brne	.+4      	; 0x5cd6 <prvIsQueueFull+0x2c>
    5cd2:	81 e0       	ldi	r24, 0x01	; 1
    5cd4:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    5cd6:	0f 90       	pop	r0
    5cd8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5cda:	89 81       	ldd	r24, Y+1	; 0x01
}
    5cdc:	0f 90       	pop	r0
    5cde:	0f 90       	pop	r0
    5ce0:	0f 90       	pop	r0
    5ce2:	cf 91       	pop	r28
    5ce4:	df 91       	pop	r29
    5ce6:	08 95       	ret

00005ce8 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    5ce8:	df 93       	push	r29
    5cea:	cf 93       	push	r28
    5cec:	00 d0       	rcall	.+0      	; 0x5cee <xQueueIsQueueFullFromISR+0x6>
    5cee:	0f 92       	push	r0
    5cf0:	cd b7       	in	r28, 0x3d	; 61
    5cf2:	de b7       	in	r29, 0x3e	; 62
    5cf4:	9b 83       	std	Y+3, r25	; 0x03
    5cf6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    5cf8:	ea 81       	ldd	r30, Y+2	; 0x02
    5cfa:	fb 81       	ldd	r31, Y+3	; 0x03
    5cfc:	92 8d       	ldd	r25, Z+26	; 0x1a
    5cfe:	ea 81       	ldd	r30, Y+2	; 0x02
    5d00:	fb 81       	ldd	r31, Y+3	; 0x03
    5d02:	83 8d       	ldd	r24, Z+27	; 0x1b
    5d04:	19 82       	std	Y+1, r1	; 0x01
    5d06:	98 17       	cp	r25, r24
    5d08:	11 f4       	brne	.+4      	; 0x5d0e <xQueueIsQueueFullFromISR+0x26>
    5d0a:	81 e0       	ldi	r24, 0x01	; 1
    5d0c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    5d0e:	89 81       	ldd	r24, Y+1	; 0x01
}
    5d10:	0f 90       	pop	r0
    5d12:	0f 90       	pop	r0
    5d14:	0f 90       	pop	r0
    5d16:	cf 91       	pop	r28
    5d18:	df 91       	pop	r29
    5d1a:	08 95       	ret

00005d1c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    5d1c:	af 92       	push	r10
    5d1e:	bf 92       	push	r11
    5d20:	cf 92       	push	r12
    5d22:	df 92       	push	r13
    5d24:	ef 92       	push	r14
    5d26:	ff 92       	push	r15
    5d28:	0f 93       	push	r16
    5d2a:	1f 93       	push	r17
    5d2c:	df 93       	push	r29
    5d2e:	cf 93       	push	r28
    5d30:	cd b7       	in	r28, 0x3d	; 61
    5d32:	de b7       	in	r29, 0x3e	; 62
    5d34:	64 97       	sbiw	r28, 0x14	; 20
    5d36:	0f b6       	in	r0, 0x3f	; 63
    5d38:	f8 94       	cli
    5d3a:	de bf       	out	0x3e, r29	; 62
    5d3c:	0f be       	out	0x3f, r0	; 63
    5d3e:	cd bf       	out	0x3d, r28	; 61
    5d40:	9f 83       	std	Y+7, r25	; 0x07
    5d42:	8e 83       	std	Y+6, r24	; 0x06
    5d44:	79 87       	std	Y+9, r23	; 0x09
    5d46:	68 87       	std	Y+8, r22	; 0x08
    5d48:	5b 87       	std	Y+11, r21	; 0x0b
    5d4a:	4a 87       	std	Y+10, r20	; 0x0a
    5d4c:	3d 87       	std	Y+13, r19	; 0x0d
    5d4e:	2c 87       	std	Y+12, r18	; 0x0c
    5d50:	0e 87       	std	Y+14, r16	; 0x0e
    5d52:	f8 8a       	std	Y+16, r15	; 0x10
    5d54:	ef 86       	std	Y+15, r14	; 0x0f
    5d56:	da 8a       	std	Y+18, r13	; 0x12
    5d58:	c9 8a       	std	Y+17, r12	; 0x11
    5d5a:	bc 8a       	std	Y+20, r11	; 0x14
    5d5c:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    5d5e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d60:	9b 85       	ldd	r25, Y+11	; 0x0b
    5d62:	29 89       	ldd	r18, Y+17	; 0x11
    5d64:	3a 89       	ldd	r19, Y+18	; 0x12
    5d66:	b9 01       	movw	r22, r18
    5d68:	0e 94 13 35 	call	0x6a26	; 0x6a26 <prvAllocateTCBAndStack>
    5d6c:	9c 83       	std	Y+4, r25	; 0x04
    5d6e:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    5d70:	8b 81       	ldd	r24, Y+3	; 0x03
    5d72:	9c 81       	ldd	r25, Y+4	; 0x04
    5d74:	00 97       	sbiw	r24, 0x00	; 0
    5d76:	09 f4       	brne	.+2      	; 0x5d7a <xTaskGenericCreate+0x5e>
    5d78:	99 c0       	rjmp	.+306    	; 0x5eac <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    5d7a:	eb 81       	ldd	r30, Y+3	; 0x03
    5d7c:	fc 81       	ldd	r31, Y+4	; 0x04
    5d7e:	27 89       	ldd	r18, Z+23	; 0x17
    5d80:	30 8d       	ldd	r19, Z+24	; 0x18
    5d82:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d84:	9b 85       	ldd	r25, Y+11	; 0x0b
    5d86:	01 97       	sbiw	r24, 0x01	; 1
    5d88:	82 0f       	add	r24, r18
    5d8a:	93 1f       	adc	r25, r19
    5d8c:	9a 83       	std	Y+2, r25	; 0x02
    5d8e:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    5d90:	8b 81       	ldd	r24, Y+3	; 0x03
    5d92:	9c 81       	ldd	r25, Y+4	; 0x04
    5d94:	28 85       	ldd	r18, Y+8	; 0x08
    5d96:	39 85       	ldd	r19, Y+9	; 0x09
    5d98:	eb 89       	ldd	r30, Y+19	; 0x13
    5d9a:	fc 89       	ldd	r31, Y+20	; 0x14
    5d9c:	aa 85       	ldd	r26, Y+10	; 0x0a
    5d9e:	bb 85       	ldd	r27, Y+11	; 0x0b
    5da0:	b9 01       	movw	r22, r18
    5da2:	4e 85       	ldd	r20, Y+14	; 0x0e
    5da4:	9f 01       	movw	r18, r30
    5da6:	8d 01       	movw	r16, r26
    5da8:	0e 94 f8 33 	call	0x67f0	; 0x67f0 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    5dac:	89 81       	ldd	r24, Y+1	; 0x01
    5dae:	9a 81       	ldd	r25, Y+2	; 0x02
    5db0:	2e 81       	ldd	r18, Y+6	; 0x06
    5db2:	3f 81       	ldd	r19, Y+7	; 0x07
    5db4:	4c 85       	ldd	r20, Y+12	; 0x0c
    5db6:	5d 85       	ldd	r21, Y+13	; 0x0d
    5db8:	b9 01       	movw	r22, r18
    5dba:	0e 94 3b 27 	call	0x4e76	; 0x4e76 <pxPortInitialiseStack>
    5dbe:	eb 81       	ldd	r30, Y+3	; 0x03
    5dc0:	fc 81       	ldd	r31, Y+4	; 0x04
    5dc2:	91 83       	std	Z+1, r25	; 0x01
    5dc4:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    5dc6:	8f 85       	ldd	r24, Y+15	; 0x0f
    5dc8:	98 89       	ldd	r25, Y+16	; 0x10
    5dca:	00 97       	sbiw	r24, 0x00	; 0
    5dcc:	31 f0       	breq	.+12     	; 0x5dda <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    5dce:	ef 85       	ldd	r30, Y+15	; 0x0f
    5dd0:	f8 89       	ldd	r31, Y+16	; 0x10
    5dd2:	8b 81       	ldd	r24, Y+3	; 0x03
    5dd4:	9c 81       	ldd	r25, Y+4	; 0x04
    5dd6:	91 83       	std	Z+1, r25	; 0x01
    5dd8:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    5dda:	0f b6       	in	r0, 0x3f	; 63
    5ddc:	f8 94       	cli
    5dde:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    5de0:	80 91 fd 05 	lds	r24, 0x05FD
    5de4:	8f 5f       	subi	r24, 0xFF	; 255
    5de6:	80 93 fd 05 	sts	0x05FD, r24
			if( pxCurrentTCB == NULL )
    5dea:	80 91 fa 05 	lds	r24, 0x05FA
    5dee:	90 91 fb 05 	lds	r25, 0x05FB
    5df2:	00 97       	sbiw	r24, 0x00	; 0
    5df4:	69 f4       	brne	.+26     	; 0x5e10 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    5df6:	8b 81       	ldd	r24, Y+3	; 0x03
    5df8:	9c 81       	ldd	r25, Y+4	; 0x04
    5dfa:	90 93 fb 05 	sts	0x05FB, r25
    5dfe:	80 93 fa 05 	sts	0x05FA, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    5e02:	80 91 fd 05 	lds	r24, 0x05FD
    5e06:	81 30       	cpi	r24, 0x01	; 1
    5e08:	a9 f4       	brne	.+42     	; 0x5e34 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    5e0a:	0e 94 4f 34 	call	0x689e	; 0x689e <prvInitialiseTaskLists>
    5e0e:	12 c0       	rjmp	.+36     	; 0x5e34 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    5e10:	80 91 02 06 	lds	r24, 0x0602
    5e14:	88 23       	and	r24, r24
    5e16:	71 f4       	brne	.+28     	; 0x5e34 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    5e18:	e0 91 fa 05 	lds	r30, 0x05FA
    5e1c:	f0 91 fb 05 	lds	r31, 0x05FB
    5e20:	96 89       	ldd	r25, Z+22	; 0x16
    5e22:	8e 85       	ldd	r24, Y+14	; 0x0e
    5e24:	89 17       	cp	r24, r25
    5e26:	30 f0       	brcs	.+12     	; 0x5e34 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    5e28:	8b 81       	ldd	r24, Y+3	; 0x03
    5e2a:	9c 81       	ldd	r25, Y+4	; 0x04
    5e2c:	90 93 fb 05 	sts	0x05FB, r25
    5e30:	80 93 fa 05 	sts	0x05FA, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    5e34:	eb 81       	ldd	r30, Y+3	; 0x03
    5e36:	fc 81       	ldd	r31, Y+4	; 0x04
    5e38:	96 89       	ldd	r25, Z+22	; 0x16
    5e3a:	80 91 00 06 	lds	r24, 0x0600
    5e3e:	89 17       	cp	r24, r25
    5e40:	28 f4       	brcc	.+10     	; 0x5e4c <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    5e42:	eb 81       	ldd	r30, Y+3	; 0x03
    5e44:	fc 81       	ldd	r31, Y+4	; 0x04
    5e46:	86 89       	ldd	r24, Z+22	; 0x16
    5e48:	80 93 00 06 	sts	0x0600, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    5e4c:	80 91 07 06 	lds	r24, 0x0607
    5e50:	8f 5f       	subi	r24, 0xFF	; 255
    5e52:	80 93 07 06 	sts	0x0607, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    5e56:	eb 81       	ldd	r30, Y+3	; 0x03
    5e58:	fc 81       	ldd	r31, Y+4	; 0x04
    5e5a:	96 89       	ldd	r25, Z+22	; 0x16
    5e5c:	80 91 01 06 	lds	r24, 0x0601
    5e60:	89 17       	cp	r24, r25
    5e62:	28 f4       	brcc	.+10     	; 0x5e6e <xTaskGenericCreate+0x152>
    5e64:	eb 81       	ldd	r30, Y+3	; 0x03
    5e66:	fc 81       	ldd	r31, Y+4	; 0x04
    5e68:	86 89       	ldd	r24, Z+22	; 0x16
    5e6a:	80 93 01 06 	sts	0x0601, r24
    5e6e:	eb 81       	ldd	r30, Y+3	; 0x03
    5e70:	fc 81       	ldd	r31, Y+4	; 0x04
    5e72:	86 89       	ldd	r24, Z+22	; 0x16
    5e74:	28 2f       	mov	r18, r24
    5e76:	30 e0       	ldi	r19, 0x00	; 0
    5e78:	c9 01       	movw	r24, r18
    5e7a:	88 0f       	add	r24, r24
    5e7c:	99 1f       	adc	r25, r25
    5e7e:	88 0f       	add	r24, r24
    5e80:	99 1f       	adc	r25, r25
    5e82:	88 0f       	add	r24, r24
    5e84:	99 1f       	adc	r25, r25
    5e86:	82 0f       	add	r24, r18
    5e88:	93 1f       	adc	r25, r19
    5e8a:	ac 01       	movw	r20, r24
    5e8c:	48 5f       	subi	r20, 0xF8	; 248
    5e8e:	59 4f       	sbci	r21, 0xF9	; 249
    5e90:	8b 81       	ldd	r24, Y+3	; 0x03
    5e92:	9c 81       	ldd	r25, Y+4	; 0x04
    5e94:	9c 01       	movw	r18, r24
    5e96:	2e 5f       	subi	r18, 0xFE	; 254
    5e98:	3f 4f       	sbci	r19, 0xFF	; 255
    5e9a:	ca 01       	movw	r24, r20
    5e9c:	b9 01       	movw	r22, r18
    5e9e:	0e 94 92 25 	call	0x4b24	; 0x4b24 <vListInsertEnd>

			xReturn = pdPASS;
    5ea2:	81 e0       	ldi	r24, 0x01	; 1
    5ea4:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    5ea6:	0f 90       	pop	r0
    5ea8:	0f be       	out	0x3f, r0	; 63
    5eaa:	02 c0       	rjmp	.+4      	; 0x5eb0 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    5eac:	8f ef       	ldi	r24, 0xFF	; 255
    5eae:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    5eb0:	8d 81       	ldd	r24, Y+5	; 0x05
    5eb2:	81 30       	cpi	r24, 0x01	; 1
    5eb4:	71 f4       	brne	.+28     	; 0x5ed2 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    5eb6:	80 91 02 06 	lds	r24, 0x0602
    5eba:	88 23       	and	r24, r24
    5ebc:	51 f0       	breq	.+20     	; 0x5ed2 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    5ebe:	e0 91 fa 05 	lds	r30, 0x05FA
    5ec2:	f0 91 fb 05 	lds	r31, 0x05FB
    5ec6:	96 89       	ldd	r25, Z+22	; 0x16
    5ec8:	8e 85       	ldd	r24, Y+14	; 0x0e
    5eca:	98 17       	cp	r25, r24
    5ecc:	10 f4       	brcc	.+4      	; 0x5ed2 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    5ece:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <vPortYield>
			}
		}
	}

	return xReturn;
    5ed2:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5ed4:	64 96       	adiw	r28, 0x14	; 20
    5ed6:	0f b6       	in	r0, 0x3f	; 63
    5ed8:	f8 94       	cli
    5eda:	de bf       	out	0x3e, r29	; 62
    5edc:	0f be       	out	0x3f, r0	; 63
    5ede:	cd bf       	out	0x3d, r28	; 61
    5ee0:	cf 91       	pop	r28
    5ee2:	df 91       	pop	r29
    5ee4:	1f 91       	pop	r17
    5ee6:	0f 91       	pop	r16
    5ee8:	ff 90       	pop	r15
    5eea:	ef 90       	pop	r14
    5eec:	df 90       	pop	r13
    5eee:	cf 90       	pop	r12
    5ef0:	bf 90       	pop	r11
    5ef2:	af 90       	pop	r10
    5ef4:	08 95       	ret

00005ef6 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    5ef6:	df 93       	push	r29
    5ef8:	cf 93       	push	r28
    5efa:	00 d0       	rcall	.+0      	; 0x5efc <vTaskDelete+0x6>
    5efc:	00 d0       	rcall	.+0      	; 0x5efe <vTaskDelete+0x8>
    5efe:	00 d0       	rcall	.+0      	; 0x5f00 <vTaskDelete+0xa>
    5f00:	cd b7       	in	r28, 0x3d	; 61
    5f02:	de b7       	in	r29, 0x3e	; 62
    5f04:	9c 83       	std	Y+4, r25	; 0x04
    5f06:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    5f08:	0f b6       	in	r0, 0x3f	; 63
    5f0a:	f8 94       	cli
    5f0c:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    5f0e:	20 91 fa 05 	lds	r18, 0x05FA
    5f12:	30 91 fb 05 	lds	r19, 0x05FB
    5f16:	8b 81       	ldd	r24, Y+3	; 0x03
    5f18:	9c 81       	ldd	r25, Y+4	; 0x04
    5f1a:	82 17       	cp	r24, r18
    5f1c:	93 07       	cpc	r25, r19
    5f1e:	11 f4       	brne	.+4      	; 0x5f24 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    5f20:	1c 82       	std	Y+4, r1	; 0x04
    5f22:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    5f24:	8b 81       	ldd	r24, Y+3	; 0x03
    5f26:	9c 81       	ldd	r25, Y+4	; 0x04
    5f28:	00 97       	sbiw	r24, 0x00	; 0
    5f2a:	39 f4       	brne	.+14     	; 0x5f3a <vTaskDelete+0x44>
    5f2c:	80 91 fa 05 	lds	r24, 0x05FA
    5f30:	90 91 fb 05 	lds	r25, 0x05FB
    5f34:	9e 83       	std	Y+6, r25	; 0x06
    5f36:	8d 83       	std	Y+5, r24	; 0x05
    5f38:	04 c0       	rjmp	.+8      	; 0x5f42 <vTaskDelete+0x4c>
    5f3a:	8b 81       	ldd	r24, Y+3	; 0x03
    5f3c:	9c 81       	ldd	r25, Y+4	; 0x04
    5f3e:	9e 83       	std	Y+6, r25	; 0x06
    5f40:	8d 83       	std	Y+5, r24	; 0x05
    5f42:	8d 81       	ldd	r24, Y+5	; 0x05
    5f44:	9e 81       	ldd	r25, Y+6	; 0x06
    5f46:	9a 83       	std	Y+2, r25	; 0x02
    5f48:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    5f4a:	89 81       	ldd	r24, Y+1	; 0x01
    5f4c:	9a 81       	ldd	r25, Y+2	; 0x02
    5f4e:	02 96       	adiw	r24, 0x02	; 2
    5f50:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    5f54:	e9 81       	ldd	r30, Y+1	; 0x01
    5f56:	fa 81       	ldd	r31, Y+2	; 0x02
    5f58:	84 89       	ldd	r24, Z+20	; 0x14
    5f5a:	95 89       	ldd	r25, Z+21	; 0x15
    5f5c:	00 97       	sbiw	r24, 0x00	; 0
    5f5e:	29 f0       	breq	.+10     	; 0x5f6a <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    5f60:	89 81       	ldd	r24, Y+1	; 0x01
    5f62:	9a 81       	ldd	r25, Y+2	; 0x02
    5f64:	0c 96       	adiw	r24, 0x0c	; 12
    5f66:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    5f6a:	89 81       	ldd	r24, Y+1	; 0x01
    5f6c:	9a 81       	ldd	r25, Y+2	; 0x02
    5f6e:	9c 01       	movw	r18, r24
    5f70:	2e 5f       	subi	r18, 0xFE	; 254
    5f72:	3f 4f       	sbci	r19, 0xFF	; 255
    5f74:	84 e5       	ldi	r24, 0x54	; 84
    5f76:	96 e0       	ldi	r25, 0x06	; 6
    5f78:	b9 01       	movw	r22, r18
    5f7a:	0e 94 92 25 	call	0x4b24	; 0x4b24 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    5f7e:	80 91 fc 05 	lds	r24, 0x05FC
    5f82:	8f 5f       	subi	r24, 0xFF	; 255
    5f84:	80 93 fc 05 	sts	0x05FC, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    5f88:	80 91 07 06 	lds	r24, 0x0607
    5f8c:	8f 5f       	subi	r24, 0xFF	; 255
    5f8e:	80 93 07 06 	sts	0x0607, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    5f92:	0f 90       	pop	r0
    5f94:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    5f96:	80 91 02 06 	lds	r24, 0x0602
    5f9a:	88 23       	and	r24, r24
    5f9c:	31 f0       	breq	.+12     	; 0x5faa <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    5f9e:	8b 81       	ldd	r24, Y+3	; 0x03
    5fa0:	9c 81       	ldd	r25, Y+4	; 0x04
    5fa2:	00 97       	sbiw	r24, 0x00	; 0
    5fa4:	11 f4       	brne	.+4      	; 0x5faa <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    5fa6:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <vPortYield>
			}
		}
	}
    5faa:	26 96       	adiw	r28, 0x06	; 6
    5fac:	0f b6       	in	r0, 0x3f	; 63
    5fae:	f8 94       	cli
    5fb0:	de bf       	out	0x3e, r29	; 62
    5fb2:	0f be       	out	0x3f, r0	; 63
    5fb4:	cd bf       	out	0x3d, r28	; 61
    5fb6:	cf 91       	pop	r28
    5fb8:	df 91       	pop	r29
    5fba:	08 95       	ret

00005fbc <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    5fbc:	df 93       	push	r29
    5fbe:	cf 93       	push	r28
    5fc0:	cd b7       	in	r28, 0x3d	; 61
    5fc2:	de b7       	in	r29, 0x3e	; 62
    5fc4:	28 97       	sbiw	r28, 0x08	; 8
    5fc6:	0f b6       	in	r0, 0x3f	; 63
    5fc8:	f8 94       	cli
    5fca:	de bf       	out	0x3e, r29	; 62
    5fcc:	0f be       	out	0x3f, r0	; 63
    5fce:	cd bf       	out	0x3d, r28	; 61
    5fd0:	9e 83       	std	Y+6, r25	; 0x06
    5fd2:	8d 83       	std	Y+5, r24	; 0x05
    5fd4:	78 87       	std	Y+8, r23	; 0x08
    5fd6:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    5fd8:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    5fda:	0e 94 ca 30 	call	0x6194	; 0x6194 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    5fde:	ed 81       	ldd	r30, Y+5	; 0x05
    5fe0:	fe 81       	ldd	r31, Y+6	; 0x06
    5fe2:	20 81       	ld	r18, Z
    5fe4:	31 81       	ldd	r19, Z+1	; 0x01
    5fe6:	8f 81       	ldd	r24, Y+7	; 0x07
    5fe8:	98 85       	ldd	r25, Y+8	; 0x08
    5fea:	82 0f       	add	r24, r18
    5fec:	93 1f       	adc	r25, r19
    5fee:	9c 83       	std	Y+4, r25	; 0x04
    5ff0:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    5ff2:	ed 81       	ldd	r30, Y+5	; 0x05
    5ff4:	fe 81       	ldd	r31, Y+6	; 0x06
    5ff6:	20 81       	ld	r18, Z
    5ff8:	31 81       	ldd	r19, Z+1	; 0x01
    5ffa:	80 91 fe 05 	lds	r24, 0x05FE
    5ffe:	90 91 ff 05 	lds	r25, 0x05FF
    6002:	82 17       	cp	r24, r18
    6004:	93 07       	cpc	r25, r19
    6006:	a8 f4       	brcc	.+42     	; 0x6032 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    6008:	ed 81       	ldd	r30, Y+5	; 0x05
    600a:	fe 81       	ldd	r31, Y+6	; 0x06
    600c:	20 81       	ld	r18, Z
    600e:	31 81       	ldd	r19, Z+1	; 0x01
    6010:	8b 81       	ldd	r24, Y+3	; 0x03
    6012:	9c 81       	ldd	r25, Y+4	; 0x04
    6014:	82 17       	cp	r24, r18
    6016:	93 07       	cpc	r25, r19
    6018:	00 f5       	brcc	.+64     	; 0x605a <vTaskDelayUntil+0x9e>
    601a:	20 91 fe 05 	lds	r18, 0x05FE
    601e:	30 91 ff 05 	lds	r19, 0x05FF
    6022:	8b 81       	ldd	r24, Y+3	; 0x03
    6024:	9c 81       	ldd	r25, Y+4	; 0x04
    6026:	28 17       	cp	r18, r24
    6028:	39 07       	cpc	r19, r25
    602a:	b8 f4       	brcc	.+46     	; 0x605a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    602c:	81 e0       	ldi	r24, 0x01	; 1
    602e:	89 83       	std	Y+1, r24	; 0x01
    6030:	14 c0       	rjmp	.+40     	; 0x605a <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    6032:	ed 81       	ldd	r30, Y+5	; 0x05
    6034:	fe 81       	ldd	r31, Y+6	; 0x06
    6036:	20 81       	ld	r18, Z
    6038:	31 81       	ldd	r19, Z+1	; 0x01
    603a:	8b 81       	ldd	r24, Y+3	; 0x03
    603c:	9c 81       	ldd	r25, Y+4	; 0x04
    603e:	82 17       	cp	r24, r18
    6040:	93 07       	cpc	r25, r19
    6042:	48 f0       	brcs	.+18     	; 0x6056 <vTaskDelayUntil+0x9a>
    6044:	20 91 fe 05 	lds	r18, 0x05FE
    6048:	30 91 ff 05 	lds	r19, 0x05FF
    604c:	8b 81       	ldd	r24, Y+3	; 0x03
    604e:	9c 81       	ldd	r25, Y+4	; 0x04
    6050:	28 17       	cp	r18, r24
    6052:	39 07       	cpc	r19, r25
    6054:	10 f4       	brcc	.+4      	; 0x605a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    6056:	81 e0       	ldi	r24, 0x01	; 1
    6058:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    605a:	ed 81       	ldd	r30, Y+5	; 0x05
    605c:	fe 81       	ldd	r31, Y+6	; 0x06
    605e:	8b 81       	ldd	r24, Y+3	; 0x03
    6060:	9c 81       	ldd	r25, Y+4	; 0x04
    6062:	91 83       	std	Z+1, r25	; 0x01
    6064:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    6066:	89 81       	ldd	r24, Y+1	; 0x01
    6068:	88 23       	and	r24, r24
    606a:	59 f0       	breq	.+22     	; 0x6082 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    606c:	80 91 fa 05 	lds	r24, 0x05FA
    6070:	90 91 fb 05 	lds	r25, 0x05FB
    6074:	02 96       	adiw	r24, 0x02	; 2
    6076:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    607a:	8b 81       	ldd	r24, Y+3	; 0x03
    607c:	9c 81       	ldd	r25, Y+4	; 0x04
    607e:	0e 94 ca 34 	call	0x6994	; 0x6994 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    6082:	0e 94 d6 30 	call	0x61ac	; 0x61ac <xTaskResumeAll>
    6086:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    6088:	8a 81       	ldd	r24, Y+2	; 0x02
    608a:	88 23       	and	r24, r24
    608c:	11 f4       	brne	.+4      	; 0x6092 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    608e:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <vPortYield>
		}
	}
    6092:	28 96       	adiw	r28, 0x08	; 8
    6094:	0f b6       	in	r0, 0x3f	; 63
    6096:	f8 94       	cli
    6098:	de bf       	out	0x3e, r29	; 62
    609a:	0f be       	out	0x3f, r0	; 63
    609c:	cd bf       	out	0x3d, r28	; 61
    609e:	cf 91       	pop	r28
    60a0:	df 91       	pop	r29
    60a2:	08 95       	ret

000060a4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    60a4:	df 93       	push	r29
    60a6:	cf 93       	push	r28
    60a8:	00 d0       	rcall	.+0      	; 0x60aa <vTaskDelay+0x6>
    60aa:	00 d0       	rcall	.+0      	; 0x60ac <vTaskDelay+0x8>
    60ac:	0f 92       	push	r0
    60ae:	cd b7       	in	r28, 0x3d	; 61
    60b0:	de b7       	in	r29, 0x3e	; 62
    60b2:	9d 83       	std	Y+5, r25	; 0x05
    60b4:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    60b6:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    60b8:	8c 81       	ldd	r24, Y+4	; 0x04
    60ba:	9d 81       	ldd	r25, Y+5	; 0x05
    60bc:	00 97       	sbiw	r24, 0x00	; 0
    60be:	d1 f0       	breq	.+52     	; 0x60f4 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    60c0:	0e 94 ca 30 	call	0x6194	; 0x6194 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    60c4:	20 91 fe 05 	lds	r18, 0x05FE
    60c8:	30 91 ff 05 	lds	r19, 0x05FF
    60cc:	8c 81       	ldd	r24, Y+4	; 0x04
    60ce:	9d 81       	ldd	r25, Y+5	; 0x05
    60d0:	82 0f       	add	r24, r18
    60d2:	93 1f       	adc	r25, r19
    60d4:	9b 83       	std	Y+3, r25	; 0x03
    60d6:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    60d8:	80 91 fa 05 	lds	r24, 0x05FA
    60dc:	90 91 fb 05 	lds	r25, 0x05FB
    60e0:	02 96       	adiw	r24, 0x02	; 2
    60e2:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    60e6:	8a 81       	ldd	r24, Y+2	; 0x02
    60e8:	9b 81       	ldd	r25, Y+3	; 0x03
    60ea:	0e 94 ca 34 	call	0x6994	; 0x6994 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    60ee:	0e 94 d6 30 	call	0x61ac	; 0x61ac <xTaskResumeAll>
    60f2:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    60f4:	89 81       	ldd	r24, Y+1	; 0x01
    60f6:	88 23       	and	r24, r24
    60f8:	11 f4       	brne	.+4      	; 0x60fe <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    60fa:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <vPortYield>
		}
	}
    60fe:	0f 90       	pop	r0
    6100:	0f 90       	pop	r0
    6102:	0f 90       	pop	r0
    6104:	0f 90       	pop	r0
    6106:	0f 90       	pop	r0
    6108:	cf 91       	pop	r28
    610a:	df 91       	pop	r29
    610c:	08 95       	ret

0000610e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    610e:	af 92       	push	r10
    6110:	bf 92       	push	r11
    6112:	cf 92       	push	r12
    6114:	df 92       	push	r13
    6116:	ef 92       	push	r14
    6118:	ff 92       	push	r15
    611a:	0f 93       	push	r16
    611c:	df 93       	push	r29
    611e:	cf 93       	push	r28
    6120:	0f 92       	push	r0
    6122:	cd b7       	in	r28, 0x3d	; 61
    6124:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    6126:	26 e7       	ldi	r18, 0x76	; 118
    6128:	30 e0       	ldi	r19, 0x00	; 0
    612a:	8e ee       	ldi	r24, 0xEE	; 238
    612c:	93 e3       	ldi	r25, 0x33	; 51
    612e:	b9 01       	movw	r22, r18
    6130:	45 e5       	ldi	r20, 0x55	; 85
    6132:	50 e0       	ldi	r21, 0x00	; 0
    6134:	20 e0       	ldi	r18, 0x00	; 0
    6136:	30 e0       	ldi	r19, 0x00	; 0
    6138:	00 e0       	ldi	r16, 0x00	; 0
    613a:	ee 24       	eor	r14, r14
    613c:	ff 24       	eor	r15, r15
    613e:	cc 24       	eor	r12, r12
    6140:	dd 24       	eor	r13, r13
    6142:	aa 24       	eor	r10, r10
    6144:	bb 24       	eor	r11, r11
    6146:	0e 94 8e 2e 	call	0x5d1c	; 0x5d1c <xTaskGenericCreate>
    614a:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    614c:	89 81       	ldd	r24, Y+1	; 0x01
    614e:	81 30       	cpi	r24, 0x01	; 1
    6150:	51 f4       	brne	.+20     	; 0x6166 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    6152:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    6154:	81 e0       	ldi	r24, 0x01	; 1
    6156:	80 93 02 06 	sts	0x0602, r24
		xTickCount = ( portTickType ) 0U;
    615a:	10 92 ff 05 	sts	0x05FF, r1
    615e:	10 92 fe 05 	sts	0x05FE, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    6162:	0e 94 be 28 	call	0x517c	; 0x517c <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    6166:	0f 90       	pop	r0
    6168:	cf 91       	pop	r28
    616a:	df 91       	pop	r29
    616c:	0f 91       	pop	r16
    616e:	ff 90       	pop	r15
    6170:	ef 90       	pop	r14
    6172:	df 90       	pop	r13
    6174:	cf 90       	pop	r12
    6176:	bf 90       	pop	r11
    6178:	af 90       	pop	r10
    617a:	08 95       	ret

0000617c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    617c:	df 93       	push	r29
    617e:	cf 93       	push	r28
    6180:	cd b7       	in	r28, 0x3d	; 61
    6182:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    6184:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    6186:	10 92 02 06 	sts	0x0602, r1
	vPortEndScheduler();
    618a:	0e 94 f3 28 	call	0x51e6	; 0x51e6 <vPortEndScheduler>
}
    618e:	cf 91       	pop	r28
    6190:	df 91       	pop	r29
    6192:	08 95       	ret

00006194 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    6194:	df 93       	push	r29
    6196:	cf 93       	push	r28
    6198:	cd b7       	in	r28, 0x3d	; 61
    619a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    619c:	80 91 03 06 	lds	r24, 0x0603
    61a0:	8f 5f       	subi	r24, 0xFF	; 255
    61a2:	80 93 03 06 	sts	0x0603, r24
}
    61a6:	cf 91       	pop	r28
    61a8:	df 91       	pop	r29
    61aa:	08 95       	ret

000061ac <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    61ac:	df 93       	push	r29
    61ae:	cf 93       	push	r28
    61b0:	00 d0       	rcall	.+0      	; 0x61b2 <xTaskResumeAll+0x6>
    61b2:	00 d0       	rcall	.+0      	; 0x61b4 <xTaskResumeAll+0x8>
    61b4:	cd b7       	in	r28, 0x3d	; 61
    61b6:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    61b8:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    61ba:	0f b6       	in	r0, 0x3f	; 63
    61bc:	f8 94       	cli
    61be:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    61c0:	80 91 03 06 	lds	r24, 0x0603
    61c4:	81 50       	subi	r24, 0x01	; 1
    61c6:	80 93 03 06 	sts	0x0603, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    61ca:	80 91 03 06 	lds	r24, 0x0603
    61ce:	88 23       	and	r24, r24
    61d0:	09 f0       	breq	.+2      	; 0x61d4 <xTaskResumeAll+0x28>
    61d2:	6c c0       	rjmp	.+216    	; 0x62ac <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    61d4:	80 91 fd 05 	lds	r24, 0x05FD
    61d8:	88 23       	and	r24, r24
    61da:	09 f4       	brne	.+2      	; 0x61de <xTaskResumeAll+0x32>
    61dc:	67 c0       	rjmp	.+206    	; 0x62ac <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    61de:	19 82       	std	Y+1, r1	; 0x01
    61e0:	41 c0       	rjmp	.+130    	; 0x6264 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    61e2:	e0 91 50 06 	lds	r30, 0x0650
    61e6:	f0 91 51 06 	lds	r31, 0x0651
    61ea:	86 81       	ldd	r24, Z+6	; 0x06
    61ec:	97 81       	ldd	r25, Z+7	; 0x07
    61ee:	9c 83       	std	Y+4, r25	; 0x04
    61f0:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    61f2:	8b 81       	ldd	r24, Y+3	; 0x03
    61f4:	9c 81       	ldd	r25, Y+4	; 0x04
    61f6:	0c 96       	adiw	r24, 0x0c	; 12
    61f8:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    61fc:	8b 81       	ldd	r24, Y+3	; 0x03
    61fe:	9c 81       	ldd	r25, Y+4	; 0x04
    6200:	02 96       	adiw	r24, 0x02	; 2
    6202:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    6206:	eb 81       	ldd	r30, Y+3	; 0x03
    6208:	fc 81       	ldd	r31, Y+4	; 0x04
    620a:	96 89       	ldd	r25, Z+22	; 0x16
    620c:	80 91 01 06 	lds	r24, 0x0601
    6210:	89 17       	cp	r24, r25
    6212:	28 f4       	brcc	.+10     	; 0x621e <xTaskResumeAll+0x72>
    6214:	eb 81       	ldd	r30, Y+3	; 0x03
    6216:	fc 81       	ldd	r31, Y+4	; 0x04
    6218:	86 89       	ldd	r24, Z+22	; 0x16
    621a:	80 93 01 06 	sts	0x0601, r24
    621e:	eb 81       	ldd	r30, Y+3	; 0x03
    6220:	fc 81       	ldd	r31, Y+4	; 0x04
    6222:	86 89       	ldd	r24, Z+22	; 0x16
    6224:	28 2f       	mov	r18, r24
    6226:	30 e0       	ldi	r19, 0x00	; 0
    6228:	c9 01       	movw	r24, r18
    622a:	88 0f       	add	r24, r24
    622c:	99 1f       	adc	r25, r25
    622e:	88 0f       	add	r24, r24
    6230:	99 1f       	adc	r25, r25
    6232:	88 0f       	add	r24, r24
    6234:	99 1f       	adc	r25, r25
    6236:	82 0f       	add	r24, r18
    6238:	93 1f       	adc	r25, r19
    623a:	88 5f       	subi	r24, 0xF8	; 248
    623c:	99 4f       	sbci	r25, 0xF9	; 249
    623e:	2b 81       	ldd	r18, Y+3	; 0x03
    6240:	3c 81       	ldd	r19, Y+4	; 0x04
    6242:	2e 5f       	subi	r18, 0xFE	; 254
    6244:	3f 4f       	sbci	r19, 0xFF	; 255
    6246:	b9 01       	movw	r22, r18
    6248:	0e 94 92 25 	call	0x4b24	; 0x4b24 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    624c:	eb 81       	ldd	r30, Y+3	; 0x03
    624e:	fc 81       	ldd	r31, Y+4	; 0x04
    6250:	96 89       	ldd	r25, Z+22	; 0x16
    6252:	e0 91 fa 05 	lds	r30, 0x05FA
    6256:	f0 91 fb 05 	lds	r31, 0x05FB
    625a:	86 89       	ldd	r24, Z+22	; 0x16
    625c:	98 17       	cp	r25, r24
    625e:	10 f0       	brcs	.+4      	; 0x6264 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    6260:	81 e0       	ldi	r24, 0x01	; 1
    6262:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    6264:	80 91 4b 06 	lds	r24, 0x064B
    6268:	88 23       	and	r24, r24
    626a:	09 f0       	breq	.+2      	; 0x626e <xTaskResumeAll+0xc2>
    626c:	ba cf       	rjmp	.-140    	; 0x61e2 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    626e:	80 91 04 06 	lds	r24, 0x0604
    6272:	88 23       	and	r24, r24
    6274:	71 f0       	breq	.+28     	; 0x6292 <xTaskResumeAll+0xe6>
    6276:	07 c0       	rjmp	.+14     	; 0x6286 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    6278:	0e 94 95 31 	call	0x632a	; 0x632a <vTaskIncrementTick>
						--uxMissedTicks;
    627c:	80 91 04 06 	lds	r24, 0x0604
    6280:	81 50       	subi	r24, 0x01	; 1
    6282:	80 93 04 06 	sts	0x0604, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    6286:	80 91 04 06 	lds	r24, 0x0604
    628a:	88 23       	and	r24, r24
    628c:	a9 f7       	brne	.-22     	; 0x6278 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    628e:	81 e0       	ldi	r24, 0x01	; 1
    6290:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    6292:	89 81       	ldd	r24, Y+1	; 0x01
    6294:	81 30       	cpi	r24, 0x01	; 1
    6296:	21 f0       	breq	.+8      	; 0x62a0 <xTaskResumeAll+0xf4>
    6298:	80 91 05 06 	lds	r24, 0x0605
    629c:	81 30       	cpi	r24, 0x01	; 1
    629e:	31 f4       	brne	.+12     	; 0x62ac <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    62a0:	81 e0       	ldi	r24, 0x01	; 1
    62a2:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    62a4:	10 92 05 06 	sts	0x0605, r1
					portYIELD_WITHIN_API();
    62a8:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    62ac:	0f 90       	pop	r0
    62ae:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    62b0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    62b2:	0f 90       	pop	r0
    62b4:	0f 90       	pop	r0
    62b6:	0f 90       	pop	r0
    62b8:	0f 90       	pop	r0
    62ba:	cf 91       	pop	r28
    62bc:	df 91       	pop	r29
    62be:	08 95       	ret

000062c0 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    62c0:	df 93       	push	r29
    62c2:	cf 93       	push	r28
    62c4:	00 d0       	rcall	.+0      	; 0x62c6 <xTaskGetTickCount+0x6>
    62c6:	cd b7       	in	r28, 0x3d	; 61
    62c8:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    62ca:	0f b6       	in	r0, 0x3f	; 63
    62cc:	f8 94       	cli
    62ce:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    62d0:	80 91 fe 05 	lds	r24, 0x05FE
    62d4:	90 91 ff 05 	lds	r25, 0x05FF
    62d8:	9a 83       	std	Y+2, r25	; 0x02
    62da:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    62dc:	0f 90       	pop	r0
    62de:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    62e0:	89 81       	ldd	r24, Y+1	; 0x01
    62e2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    62e4:	0f 90       	pop	r0
    62e6:	0f 90       	pop	r0
    62e8:	cf 91       	pop	r28
    62ea:	df 91       	pop	r29
    62ec:	08 95       	ret

000062ee <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    62ee:	df 93       	push	r29
    62f0:	cf 93       	push	r28
    62f2:	00 d0       	rcall	.+0      	; 0x62f4 <xTaskGetTickCountFromISR+0x6>
    62f4:	0f 92       	push	r0
    62f6:	cd b7       	in	r28, 0x3d	; 61
    62f8:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    62fa:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    62fc:	80 91 fe 05 	lds	r24, 0x05FE
    6300:	90 91 ff 05 	lds	r25, 0x05FF
    6304:	9b 83       	std	Y+3, r25	; 0x03
    6306:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    6308:	8a 81       	ldd	r24, Y+2	; 0x02
    630a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    630c:	0f 90       	pop	r0
    630e:	0f 90       	pop	r0
    6310:	0f 90       	pop	r0
    6312:	cf 91       	pop	r28
    6314:	df 91       	pop	r29
    6316:	08 95       	ret

00006318 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    6318:	df 93       	push	r29
    631a:	cf 93       	push	r28
    631c:	cd b7       	in	r28, 0x3d	; 61
    631e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    6320:	80 91 fd 05 	lds	r24, 0x05FD
}
    6324:	cf 91       	pop	r28
    6326:	df 91       	pop	r29
    6328:	08 95       	ret

0000632a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    632a:	df 93       	push	r29
    632c:	cf 93       	push	r28
    632e:	00 d0       	rcall	.+0      	; 0x6330 <vTaskIncrementTick+0x6>
    6330:	00 d0       	rcall	.+0      	; 0x6332 <vTaskIncrementTick+0x8>
    6332:	00 d0       	rcall	.+0      	; 0x6334 <vTaskIncrementTick+0xa>
    6334:	cd b7       	in	r28, 0x3d	; 61
    6336:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    6338:	80 91 03 06 	lds	r24, 0x0603
    633c:	88 23       	and	r24, r24
    633e:	09 f0       	breq	.+2      	; 0x6342 <vTaskIncrementTick+0x18>
    6340:	bb c0       	rjmp	.+374    	; 0x64b8 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    6342:	80 91 fe 05 	lds	r24, 0x05FE
    6346:	90 91 ff 05 	lds	r25, 0x05FF
    634a:	01 96       	adiw	r24, 0x01	; 1
    634c:	90 93 ff 05 	sts	0x05FF, r25
    6350:	80 93 fe 05 	sts	0x05FE, r24
		if( xTickCount == ( portTickType ) 0U )
    6354:	80 91 fe 05 	lds	r24, 0x05FE
    6358:	90 91 ff 05 	lds	r25, 0x05FF
    635c:	00 97       	sbiw	r24, 0x00	; 0
    635e:	d1 f5       	brne	.+116    	; 0x63d4 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    6360:	80 91 47 06 	lds	r24, 0x0647
    6364:	90 91 48 06 	lds	r25, 0x0648
    6368:	9c 83       	std	Y+4, r25	; 0x04
    636a:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    636c:	80 91 49 06 	lds	r24, 0x0649
    6370:	90 91 4a 06 	lds	r25, 0x064A
    6374:	90 93 48 06 	sts	0x0648, r25
    6378:	80 93 47 06 	sts	0x0647, r24
			pxOverflowDelayedTaskList = pxTemp;
    637c:	8b 81       	ldd	r24, Y+3	; 0x03
    637e:	9c 81       	ldd	r25, Y+4	; 0x04
    6380:	90 93 4a 06 	sts	0x064A, r25
    6384:	80 93 49 06 	sts	0x0649, r24
			xNumOfOverflows++;
    6388:	80 91 06 06 	lds	r24, 0x0606
    638c:	8f 5f       	subi	r24, 0xFF	; 255
    638e:	80 93 06 06 	sts	0x0606, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    6392:	e0 91 47 06 	lds	r30, 0x0647
    6396:	f0 91 48 06 	lds	r31, 0x0648
    639a:	80 81       	ld	r24, Z
    639c:	88 23       	and	r24, r24
    639e:	39 f4       	brne	.+14     	; 0x63ae <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    63a0:	8f ef       	ldi	r24, 0xFF	; 255
    63a2:	9f ef       	ldi	r25, 0xFF	; 255
    63a4:	90 93 cc 01 	sts	0x01CC, r25
    63a8:	80 93 cb 01 	sts	0x01CB, r24
    63ac:	13 c0       	rjmp	.+38     	; 0x63d4 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    63ae:	e0 91 47 06 	lds	r30, 0x0647
    63b2:	f0 91 48 06 	lds	r31, 0x0648
    63b6:	05 80       	ldd	r0, Z+5	; 0x05
    63b8:	f6 81       	ldd	r31, Z+6	; 0x06
    63ba:	e0 2d       	mov	r30, r0
    63bc:	86 81       	ldd	r24, Z+6	; 0x06
    63be:	97 81       	ldd	r25, Z+7	; 0x07
    63c0:	9e 83       	std	Y+6, r25	; 0x06
    63c2:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    63c4:	ed 81       	ldd	r30, Y+5	; 0x05
    63c6:	fe 81       	ldd	r31, Y+6	; 0x06
    63c8:	82 81       	ldd	r24, Z+2	; 0x02
    63ca:	93 81       	ldd	r25, Z+3	; 0x03
    63cc:	90 93 cc 01 	sts	0x01CC, r25
    63d0:	80 93 cb 01 	sts	0x01CB, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    63d4:	20 91 fe 05 	lds	r18, 0x05FE
    63d8:	30 91 ff 05 	lds	r19, 0x05FF
    63dc:	80 91 cb 01 	lds	r24, 0x01CB
    63e0:	90 91 cc 01 	lds	r25, 0x01CC
    63e4:	28 17       	cp	r18, r24
    63e6:	39 07       	cpc	r19, r25
    63e8:	08 f4       	brcc	.+2      	; 0x63ec <vTaskIncrementTick+0xc2>
    63ea:	6b c0       	rjmp	.+214    	; 0x64c2 <vTaskIncrementTick+0x198>
    63ec:	e0 91 47 06 	lds	r30, 0x0647
    63f0:	f0 91 48 06 	lds	r31, 0x0648
    63f4:	80 81       	ld	r24, Z
    63f6:	88 23       	and	r24, r24
    63f8:	39 f4       	brne	.+14     	; 0x6408 <vTaskIncrementTick+0xde>
    63fa:	8f ef       	ldi	r24, 0xFF	; 255
    63fc:	9f ef       	ldi	r25, 0xFF	; 255
    63fe:	90 93 cc 01 	sts	0x01CC, r25
    6402:	80 93 cb 01 	sts	0x01CB, r24
    6406:	5d c0       	rjmp	.+186    	; 0x64c2 <vTaskIncrementTick+0x198>
    6408:	e0 91 47 06 	lds	r30, 0x0647
    640c:	f0 91 48 06 	lds	r31, 0x0648
    6410:	05 80       	ldd	r0, Z+5	; 0x05
    6412:	f6 81       	ldd	r31, Z+6	; 0x06
    6414:	e0 2d       	mov	r30, r0
    6416:	86 81       	ldd	r24, Z+6	; 0x06
    6418:	97 81       	ldd	r25, Z+7	; 0x07
    641a:	9e 83       	std	Y+6, r25	; 0x06
    641c:	8d 83       	std	Y+5, r24	; 0x05
    641e:	ed 81       	ldd	r30, Y+5	; 0x05
    6420:	fe 81       	ldd	r31, Y+6	; 0x06
    6422:	82 81       	ldd	r24, Z+2	; 0x02
    6424:	93 81       	ldd	r25, Z+3	; 0x03
    6426:	9a 83       	std	Y+2, r25	; 0x02
    6428:	89 83       	std	Y+1, r24	; 0x01
    642a:	20 91 fe 05 	lds	r18, 0x05FE
    642e:	30 91 ff 05 	lds	r19, 0x05FF
    6432:	89 81       	ldd	r24, Y+1	; 0x01
    6434:	9a 81       	ldd	r25, Y+2	; 0x02
    6436:	28 17       	cp	r18, r24
    6438:	39 07       	cpc	r19, r25
    643a:	38 f4       	brcc	.+14     	; 0x644a <vTaskIncrementTick+0x120>
    643c:	89 81       	ldd	r24, Y+1	; 0x01
    643e:	9a 81       	ldd	r25, Y+2	; 0x02
    6440:	90 93 cc 01 	sts	0x01CC, r25
    6444:	80 93 cb 01 	sts	0x01CB, r24
    6448:	3c c0       	rjmp	.+120    	; 0x64c2 <vTaskIncrementTick+0x198>
    644a:	8d 81       	ldd	r24, Y+5	; 0x05
    644c:	9e 81       	ldd	r25, Y+6	; 0x06
    644e:	02 96       	adiw	r24, 0x02	; 2
    6450:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
    6454:	ed 81       	ldd	r30, Y+5	; 0x05
    6456:	fe 81       	ldd	r31, Y+6	; 0x06
    6458:	84 89       	ldd	r24, Z+20	; 0x14
    645a:	95 89       	ldd	r25, Z+21	; 0x15
    645c:	00 97       	sbiw	r24, 0x00	; 0
    645e:	29 f0       	breq	.+10     	; 0x646a <vTaskIncrementTick+0x140>
    6460:	8d 81       	ldd	r24, Y+5	; 0x05
    6462:	9e 81       	ldd	r25, Y+6	; 0x06
    6464:	0c 96       	adiw	r24, 0x0c	; 12
    6466:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
    646a:	ed 81       	ldd	r30, Y+5	; 0x05
    646c:	fe 81       	ldd	r31, Y+6	; 0x06
    646e:	96 89       	ldd	r25, Z+22	; 0x16
    6470:	80 91 01 06 	lds	r24, 0x0601
    6474:	89 17       	cp	r24, r25
    6476:	28 f4       	brcc	.+10     	; 0x6482 <vTaskIncrementTick+0x158>
    6478:	ed 81       	ldd	r30, Y+5	; 0x05
    647a:	fe 81       	ldd	r31, Y+6	; 0x06
    647c:	86 89       	ldd	r24, Z+22	; 0x16
    647e:	80 93 01 06 	sts	0x0601, r24
    6482:	ed 81       	ldd	r30, Y+5	; 0x05
    6484:	fe 81       	ldd	r31, Y+6	; 0x06
    6486:	86 89       	ldd	r24, Z+22	; 0x16
    6488:	28 2f       	mov	r18, r24
    648a:	30 e0       	ldi	r19, 0x00	; 0
    648c:	c9 01       	movw	r24, r18
    648e:	88 0f       	add	r24, r24
    6490:	99 1f       	adc	r25, r25
    6492:	88 0f       	add	r24, r24
    6494:	99 1f       	adc	r25, r25
    6496:	88 0f       	add	r24, r24
    6498:	99 1f       	adc	r25, r25
    649a:	82 0f       	add	r24, r18
    649c:	93 1f       	adc	r25, r19
    649e:	ac 01       	movw	r20, r24
    64a0:	48 5f       	subi	r20, 0xF8	; 248
    64a2:	59 4f       	sbci	r21, 0xF9	; 249
    64a4:	8d 81       	ldd	r24, Y+5	; 0x05
    64a6:	9e 81       	ldd	r25, Y+6	; 0x06
    64a8:	9c 01       	movw	r18, r24
    64aa:	2e 5f       	subi	r18, 0xFE	; 254
    64ac:	3f 4f       	sbci	r19, 0xFF	; 255
    64ae:	ca 01       	movw	r24, r20
    64b0:	b9 01       	movw	r22, r18
    64b2:	0e 94 92 25 	call	0x4b24	; 0x4b24 <vListInsertEnd>
    64b6:	9a cf       	rjmp	.-204    	; 0x63ec <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    64b8:	80 91 04 06 	lds	r24, 0x0604
    64bc:	8f 5f       	subi	r24, 0xFF	; 255
    64be:	80 93 04 06 	sts	0x0604, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    64c2:	26 96       	adiw	r28, 0x06	; 6
    64c4:	0f b6       	in	r0, 0x3f	; 63
    64c6:	f8 94       	cli
    64c8:	de bf       	out	0x3e, r29	; 62
    64ca:	0f be       	out	0x3f, r0	; 63
    64cc:	cd bf       	out	0x3d, r28	; 61
    64ce:	cf 91       	pop	r28
    64d0:	df 91       	pop	r29
    64d2:	08 95       	ret

000064d4 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    64d4:	df 93       	push	r29
    64d6:	cf 93       	push	r28
    64d8:	00 d0       	rcall	.+0      	; 0x64da <vTaskSwitchContext+0x6>
    64da:	cd b7       	in	r28, 0x3d	; 61
    64dc:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    64de:	80 91 03 06 	lds	r24, 0x0603
    64e2:	88 23       	and	r24, r24
    64e4:	49 f0       	breq	.+18     	; 0x64f8 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    64e6:	81 e0       	ldi	r24, 0x01	; 1
    64e8:	80 93 05 06 	sts	0x0605, r24
    64ec:	54 c0       	rjmp	.+168    	; 0x6596 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    64ee:	80 91 01 06 	lds	r24, 0x0601
    64f2:	81 50       	subi	r24, 0x01	; 1
    64f4:	80 93 01 06 	sts	0x0601, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    64f8:	80 91 01 06 	lds	r24, 0x0601
    64fc:	28 2f       	mov	r18, r24
    64fe:	30 e0       	ldi	r19, 0x00	; 0
    6500:	c9 01       	movw	r24, r18
    6502:	88 0f       	add	r24, r24
    6504:	99 1f       	adc	r25, r25
    6506:	88 0f       	add	r24, r24
    6508:	99 1f       	adc	r25, r25
    650a:	88 0f       	add	r24, r24
    650c:	99 1f       	adc	r25, r25
    650e:	82 0f       	add	r24, r18
    6510:	93 1f       	adc	r25, r19
    6512:	fc 01       	movw	r30, r24
    6514:	e8 5f       	subi	r30, 0xF8	; 248
    6516:	f9 4f       	sbci	r31, 0xF9	; 249
    6518:	80 81       	ld	r24, Z
    651a:	88 23       	and	r24, r24
    651c:	41 f3       	breq	.-48     	; 0x64ee <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    651e:	80 91 01 06 	lds	r24, 0x0601
    6522:	28 2f       	mov	r18, r24
    6524:	30 e0       	ldi	r19, 0x00	; 0
    6526:	c9 01       	movw	r24, r18
    6528:	88 0f       	add	r24, r24
    652a:	99 1f       	adc	r25, r25
    652c:	88 0f       	add	r24, r24
    652e:	99 1f       	adc	r25, r25
    6530:	88 0f       	add	r24, r24
    6532:	99 1f       	adc	r25, r25
    6534:	82 0f       	add	r24, r18
    6536:	93 1f       	adc	r25, r19
    6538:	88 5f       	subi	r24, 0xF8	; 248
    653a:	99 4f       	sbci	r25, 0xF9	; 249
    653c:	9a 83       	std	Y+2, r25	; 0x02
    653e:	89 83       	std	Y+1, r24	; 0x01
    6540:	e9 81       	ldd	r30, Y+1	; 0x01
    6542:	fa 81       	ldd	r31, Y+2	; 0x02
    6544:	01 80       	ldd	r0, Z+1	; 0x01
    6546:	f2 81       	ldd	r31, Z+2	; 0x02
    6548:	e0 2d       	mov	r30, r0
    654a:	82 81       	ldd	r24, Z+2	; 0x02
    654c:	93 81       	ldd	r25, Z+3	; 0x03
    654e:	e9 81       	ldd	r30, Y+1	; 0x01
    6550:	fa 81       	ldd	r31, Y+2	; 0x02
    6552:	92 83       	std	Z+2, r25	; 0x02
    6554:	81 83       	std	Z+1, r24	; 0x01
    6556:	e9 81       	ldd	r30, Y+1	; 0x01
    6558:	fa 81       	ldd	r31, Y+2	; 0x02
    655a:	21 81       	ldd	r18, Z+1	; 0x01
    655c:	32 81       	ldd	r19, Z+2	; 0x02
    655e:	89 81       	ldd	r24, Y+1	; 0x01
    6560:	9a 81       	ldd	r25, Y+2	; 0x02
    6562:	03 96       	adiw	r24, 0x03	; 3
    6564:	28 17       	cp	r18, r24
    6566:	39 07       	cpc	r19, r25
    6568:	59 f4       	brne	.+22     	; 0x6580 <vTaskSwitchContext+0xac>
    656a:	e9 81       	ldd	r30, Y+1	; 0x01
    656c:	fa 81       	ldd	r31, Y+2	; 0x02
    656e:	01 80       	ldd	r0, Z+1	; 0x01
    6570:	f2 81       	ldd	r31, Z+2	; 0x02
    6572:	e0 2d       	mov	r30, r0
    6574:	82 81       	ldd	r24, Z+2	; 0x02
    6576:	93 81       	ldd	r25, Z+3	; 0x03
    6578:	e9 81       	ldd	r30, Y+1	; 0x01
    657a:	fa 81       	ldd	r31, Y+2	; 0x02
    657c:	92 83       	std	Z+2, r25	; 0x02
    657e:	81 83       	std	Z+1, r24	; 0x01
    6580:	e9 81       	ldd	r30, Y+1	; 0x01
    6582:	fa 81       	ldd	r31, Y+2	; 0x02
    6584:	01 80       	ldd	r0, Z+1	; 0x01
    6586:	f2 81       	ldd	r31, Z+2	; 0x02
    6588:	e0 2d       	mov	r30, r0
    658a:	86 81       	ldd	r24, Z+6	; 0x06
    658c:	97 81       	ldd	r25, Z+7	; 0x07
    658e:	90 93 fb 05 	sts	0x05FB, r25
    6592:	80 93 fa 05 	sts	0x05FA, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    6596:	0f 90       	pop	r0
    6598:	0f 90       	pop	r0
    659a:	cf 91       	pop	r28
    659c:	df 91       	pop	r29
    659e:	08 95       	ret

000065a0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    65a0:	df 93       	push	r29
    65a2:	cf 93       	push	r28
    65a4:	00 d0       	rcall	.+0      	; 0x65a6 <vTaskPlaceOnEventList+0x6>
    65a6:	00 d0       	rcall	.+0      	; 0x65a8 <vTaskPlaceOnEventList+0x8>
    65a8:	00 d0       	rcall	.+0      	; 0x65aa <vTaskPlaceOnEventList+0xa>
    65aa:	cd b7       	in	r28, 0x3d	; 61
    65ac:	de b7       	in	r29, 0x3e	; 62
    65ae:	9c 83       	std	Y+4, r25	; 0x04
    65b0:	8b 83       	std	Y+3, r24	; 0x03
    65b2:	7e 83       	std	Y+6, r23	; 0x06
    65b4:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    65b6:	4b 81       	ldd	r20, Y+3	; 0x03
    65b8:	5c 81       	ldd	r21, Y+4	; 0x04
    65ba:	80 91 fa 05 	lds	r24, 0x05FA
    65be:	90 91 fb 05 	lds	r25, 0x05FB
    65c2:	9c 01       	movw	r18, r24
    65c4:	24 5f       	subi	r18, 0xF4	; 244
    65c6:	3f 4f       	sbci	r19, 0xFF	; 255
    65c8:	ca 01       	movw	r24, r20
    65ca:	b9 01       	movw	r22, r18
    65cc:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    65d0:	80 91 fa 05 	lds	r24, 0x05FA
    65d4:	90 91 fb 05 	lds	r25, 0x05FB
    65d8:	02 96       	adiw	r24, 0x02	; 2
    65da:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    65de:	20 91 fe 05 	lds	r18, 0x05FE
    65e2:	30 91 ff 05 	lds	r19, 0x05FF
    65e6:	8d 81       	ldd	r24, Y+5	; 0x05
    65e8:	9e 81       	ldd	r25, Y+6	; 0x06
    65ea:	82 0f       	add	r24, r18
    65ec:	93 1f       	adc	r25, r19
    65ee:	9a 83       	std	Y+2, r25	; 0x02
    65f0:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    65f2:	89 81       	ldd	r24, Y+1	; 0x01
    65f4:	9a 81       	ldd	r25, Y+2	; 0x02
    65f6:	0e 94 ca 34 	call	0x6994	; 0x6994 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    65fa:	26 96       	adiw	r28, 0x06	; 6
    65fc:	0f b6       	in	r0, 0x3f	; 63
    65fe:	f8 94       	cli
    6600:	de bf       	out	0x3e, r29	; 62
    6602:	0f be       	out	0x3f, r0	; 63
    6604:	cd bf       	out	0x3d, r28	; 61
    6606:	cf 91       	pop	r28
    6608:	df 91       	pop	r29
    660a:	08 95       	ret

0000660c <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    660c:	df 93       	push	r29
    660e:	cf 93       	push	r28
    6610:	00 d0       	rcall	.+0      	; 0x6612 <xTaskRemoveFromEventList+0x6>
    6612:	00 d0       	rcall	.+0      	; 0x6614 <xTaskRemoveFromEventList+0x8>
    6614:	0f 92       	push	r0
    6616:	cd b7       	in	r28, 0x3d	; 61
    6618:	de b7       	in	r29, 0x3e	; 62
    661a:	9d 83       	std	Y+5, r25	; 0x05
    661c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    661e:	ec 81       	ldd	r30, Y+4	; 0x04
    6620:	fd 81       	ldd	r31, Y+5	; 0x05
    6622:	05 80       	ldd	r0, Z+5	; 0x05
    6624:	f6 81       	ldd	r31, Z+6	; 0x06
    6626:	e0 2d       	mov	r30, r0
    6628:	86 81       	ldd	r24, Z+6	; 0x06
    662a:	97 81       	ldd	r25, Z+7	; 0x07
    662c:	9b 83       	std	Y+3, r25	; 0x03
    662e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    6630:	8a 81       	ldd	r24, Y+2	; 0x02
    6632:	9b 81       	ldd	r25, Y+3	; 0x03
    6634:	0c 96       	adiw	r24, 0x0c	; 12
    6636:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    663a:	80 91 03 06 	lds	r24, 0x0603
    663e:	88 23       	and	r24, r24
    6640:	61 f5       	brne	.+88     	; 0x669a <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    6642:	8a 81       	ldd	r24, Y+2	; 0x02
    6644:	9b 81       	ldd	r25, Y+3	; 0x03
    6646:	02 96       	adiw	r24, 0x02	; 2
    6648:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    664c:	ea 81       	ldd	r30, Y+2	; 0x02
    664e:	fb 81       	ldd	r31, Y+3	; 0x03
    6650:	96 89       	ldd	r25, Z+22	; 0x16
    6652:	80 91 01 06 	lds	r24, 0x0601
    6656:	89 17       	cp	r24, r25
    6658:	28 f4       	brcc	.+10     	; 0x6664 <xTaskRemoveFromEventList+0x58>
    665a:	ea 81       	ldd	r30, Y+2	; 0x02
    665c:	fb 81       	ldd	r31, Y+3	; 0x03
    665e:	86 89       	ldd	r24, Z+22	; 0x16
    6660:	80 93 01 06 	sts	0x0601, r24
    6664:	ea 81       	ldd	r30, Y+2	; 0x02
    6666:	fb 81       	ldd	r31, Y+3	; 0x03
    6668:	86 89       	ldd	r24, Z+22	; 0x16
    666a:	28 2f       	mov	r18, r24
    666c:	30 e0       	ldi	r19, 0x00	; 0
    666e:	c9 01       	movw	r24, r18
    6670:	88 0f       	add	r24, r24
    6672:	99 1f       	adc	r25, r25
    6674:	88 0f       	add	r24, r24
    6676:	99 1f       	adc	r25, r25
    6678:	88 0f       	add	r24, r24
    667a:	99 1f       	adc	r25, r25
    667c:	82 0f       	add	r24, r18
    667e:	93 1f       	adc	r25, r19
    6680:	ac 01       	movw	r20, r24
    6682:	48 5f       	subi	r20, 0xF8	; 248
    6684:	59 4f       	sbci	r21, 0xF9	; 249
    6686:	8a 81       	ldd	r24, Y+2	; 0x02
    6688:	9b 81       	ldd	r25, Y+3	; 0x03
    668a:	9c 01       	movw	r18, r24
    668c:	2e 5f       	subi	r18, 0xFE	; 254
    668e:	3f 4f       	sbci	r19, 0xFF	; 255
    6690:	ca 01       	movw	r24, r20
    6692:	b9 01       	movw	r22, r18
    6694:	0e 94 92 25 	call	0x4b24	; 0x4b24 <vListInsertEnd>
    6698:	0a c0       	rjmp	.+20     	; 0x66ae <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    669a:	8a 81       	ldd	r24, Y+2	; 0x02
    669c:	9b 81       	ldd	r25, Y+3	; 0x03
    669e:	9c 01       	movw	r18, r24
    66a0:	24 5f       	subi	r18, 0xF4	; 244
    66a2:	3f 4f       	sbci	r19, 0xFF	; 255
    66a4:	8b e4       	ldi	r24, 0x4B	; 75
    66a6:	96 e0       	ldi	r25, 0x06	; 6
    66a8:	b9 01       	movw	r22, r18
    66aa:	0e 94 92 25 	call	0x4b24	; 0x4b24 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    66ae:	ea 81       	ldd	r30, Y+2	; 0x02
    66b0:	fb 81       	ldd	r31, Y+3	; 0x03
    66b2:	96 89       	ldd	r25, Z+22	; 0x16
    66b4:	e0 91 fa 05 	lds	r30, 0x05FA
    66b8:	f0 91 fb 05 	lds	r31, 0x05FB
    66bc:	86 89       	ldd	r24, Z+22	; 0x16
    66be:	98 17       	cp	r25, r24
    66c0:	18 f0       	brcs	.+6      	; 0x66c8 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    66c2:	81 e0       	ldi	r24, 0x01	; 1
    66c4:	89 83       	std	Y+1, r24	; 0x01
    66c6:	01 c0       	rjmp	.+2      	; 0x66ca <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    66c8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    66ca:	89 81       	ldd	r24, Y+1	; 0x01
}
    66cc:	0f 90       	pop	r0
    66ce:	0f 90       	pop	r0
    66d0:	0f 90       	pop	r0
    66d2:	0f 90       	pop	r0
    66d4:	0f 90       	pop	r0
    66d6:	cf 91       	pop	r28
    66d8:	df 91       	pop	r29
    66da:	08 95       	ret

000066dc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    66dc:	df 93       	push	r29
    66de:	cf 93       	push	r28
    66e0:	00 d0       	rcall	.+0      	; 0x66e2 <vTaskSetTimeOutState+0x6>
    66e2:	cd b7       	in	r28, 0x3d	; 61
    66e4:	de b7       	in	r29, 0x3e	; 62
    66e6:	9a 83       	std	Y+2, r25	; 0x02
    66e8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    66ea:	80 91 06 06 	lds	r24, 0x0606
    66ee:	e9 81       	ldd	r30, Y+1	; 0x01
    66f0:	fa 81       	ldd	r31, Y+2	; 0x02
    66f2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    66f4:	80 91 fe 05 	lds	r24, 0x05FE
    66f8:	90 91 ff 05 	lds	r25, 0x05FF
    66fc:	e9 81       	ldd	r30, Y+1	; 0x01
    66fe:	fa 81       	ldd	r31, Y+2	; 0x02
    6700:	92 83       	std	Z+2, r25	; 0x02
    6702:	81 83       	std	Z+1, r24	; 0x01
}
    6704:	0f 90       	pop	r0
    6706:	0f 90       	pop	r0
    6708:	cf 91       	pop	r28
    670a:	df 91       	pop	r29
    670c:	08 95       	ret

0000670e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    670e:	df 93       	push	r29
    6710:	cf 93       	push	r28
    6712:	00 d0       	rcall	.+0      	; 0x6714 <xTaskCheckForTimeOut+0x6>
    6714:	00 d0       	rcall	.+0      	; 0x6716 <xTaskCheckForTimeOut+0x8>
    6716:	0f 92       	push	r0
    6718:	cd b7       	in	r28, 0x3d	; 61
    671a:	de b7       	in	r29, 0x3e	; 62
    671c:	9b 83       	std	Y+3, r25	; 0x03
    671e:	8a 83       	std	Y+2, r24	; 0x02
    6720:	7d 83       	std	Y+5, r23	; 0x05
    6722:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    6724:	0f b6       	in	r0, 0x3f	; 63
    6726:	f8 94       	cli
    6728:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    672a:	ea 81       	ldd	r30, Y+2	; 0x02
    672c:	fb 81       	ldd	r31, Y+3	; 0x03
    672e:	90 81       	ld	r25, Z
    6730:	80 91 06 06 	lds	r24, 0x0606
    6734:	98 17       	cp	r25, r24
    6736:	71 f0       	breq	.+28     	; 0x6754 <xTaskCheckForTimeOut+0x46>
    6738:	ea 81       	ldd	r30, Y+2	; 0x02
    673a:	fb 81       	ldd	r31, Y+3	; 0x03
    673c:	21 81       	ldd	r18, Z+1	; 0x01
    673e:	32 81       	ldd	r19, Z+2	; 0x02
    6740:	80 91 fe 05 	lds	r24, 0x05FE
    6744:	90 91 ff 05 	lds	r25, 0x05FF
    6748:	82 17       	cp	r24, r18
    674a:	93 07       	cpc	r25, r19
    674c:	18 f0       	brcs	.+6      	; 0x6754 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    674e:	81 e0       	ldi	r24, 0x01	; 1
    6750:	89 83       	std	Y+1, r24	; 0x01
    6752:	2f c0       	rjmp	.+94     	; 0x67b2 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    6754:	20 91 fe 05 	lds	r18, 0x05FE
    6758:	30 91 ff 05 	lds	r19, 0x05FF
    675c:	ea 81       	ldd	r30, Y+2	; 0x02
    675e:	fb 81       	ldd	r31, Y+3	; 0x03
    6760:	81 81       	ldd	r24, Z+1	; 0x01
    6762:	92 81       	ldd	r25, Z+2	; 0x02
    6764:	28 1b       	sub	r18, r24
    6766:	39 0b       	sbc	r19, r25
    6768:	ec 81       	ldd	r30, Y+4	; 0x04
    676a:	fd 81       	ldd	r31, Y+5	; 0x05
    676c:	80 81       	ld	r24, Z
    676e:	91 81       	ldd	r25, Z+1	; 0x01
    6770:	28 17       	cp	r18, r24
    6772:	39 07       	cpc	r19, r25
    6774:	e0 f4       	brcc	.+56     	; 0x67ae <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    6776:	ec 81       	ldd	r30, Y+4	; 0x04
    6778:	fd 81       	ldd	r31, Y+5	; 0x05
    677a:	40 81       	ld	r20, Z
    677c:	51 81       	ldd	r21, Z+1	; 0x01
    677e:	ea 81       	ldd	r30, Y+2	; 0x02
    6780:	fb 81       	ldd	r31, Y+3	; 0x03
    6782:	21 81       	ldd	r18, Z+1	; 0x01
    6784:	32 81       	ldd	r19, Z+2	; 0x02
    6786:	80 91 fe 05 	lds	r24, 0x05FE
    678a:	90 91 ff 05 	lds	r25, 0x05FF
    678e:	b9 01       	movw	r22, r18
    6790:	68 1b       	sub	r22, r24
    6792:	79 0b       	sbc	r23, r25
    6794:	cb 01       	movw	r24, r22
    6796:	84 0f       	add	r24, r20
    6798:	95 1f       	adc	r25, r21
    679a:	ec 81       	ldd	r30, Y+4	; 0x04
    679c:	fd 81       	ldd	r31, Y+5	; 0x05
    679e:	91 83       	std	Z+1, r25	; 0x01
    67a0:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    67a2:	8a 81       	ldd	r24, Y+2	; 0x02
    67a4:	9b 81       	ldd	r25, Y+3	; 0x03
    67a6:	0e 94 6e 33 	call	0x66dc	; 0x66dc <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    67aa:	19 82       	std	Y+1, r1	; 0x01
    67ac:	02 c0       	rjmp	.+4      	; 0x67b2 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    67ae:	81 e0       	ldi	r24, 0x01	; 1
    67b0:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    67b2:	0f 90       	pop	r0
    67b4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    67b6:	89 81       	ldd	r24, Y+1	; 0x01
}
    67b8:	0f 90       	pop	r0
    67ba:	0f 90       	pop	r0
    67bc:	0f 90       	pop	r0
    67be:	0f 90       	pop	r0
    67c0:	0f 90       	pop	r0
    67c2:	cf 91       	pop	r28
    67c4:	df 91       	pop	r29
    67c6:	08 95       	ret

000067c8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    67c8:	df 93       	push	r29
    67ca:	cf 93       	push	r28
    67cc:	cd b7       	in	r28, 0x3d	; 61
    67ce:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    67d0:	81 e0       	ldi	r24, 0x01	; 1
    67d2:	80 93 05 06 	sts	0x0605, r24
}
    67d6:	cf 91       	pop	r28
    67d8:	df 91       	pop	r29
    67da:	08 95       	ret

000067dc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    67dc:	df 93       	push	r29
    67de:	cf 93       	push	r28
    67e0:	00 d0       	rcall	.+0      	; 0x67e2 <prvIdleTask+0x6>
    67e2:	cd b7       	in	r28, 0x3d	; 61
    67e4:	de b7       	in	r29, 0x3e	; 62
    67e6:	9a 83       	std	Y+2, r25	; 0x02
    67e8:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    67ea:	0e 94 8c 34 	call	0x6918	; 0x6918 <prvCheckTasksWaitingTermination>
    67ee:	fd cf       	rjmp	.-6      	; 0x67ea <prvIdleTask+0xe>

000067f0 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    67f0:	0f 93       	push	r16
    67f2:	1f 93       	push	r17
    67f4:	df 93       	push	r29
    67f6:	cf 93       	push	r28
    67f8:	cd b7       	in	r28, 0x3d	; 61
    67fa:	de b7       	in	r29, 0x3e	; 62
    67fc:	29 97       	sbiw	r28, 0x09	; 9
    67fe:	0f b6       	in	r0, 0x3f	; 63
    6800:	f8 94       	cli
    6802:	de bf       	out	0x3e, r29	; 62
    6804:	0f be       	out	0x3f, r0	; 63
    6806:	cd bf       	out	0x3d, r28	; 61
    6808:	9a 83       	std	Y+2, r25	; 0x02
    680a:	89 83       	std	Y+1, r24	; 0x01
    680c:	7c 83       	std	Y+4, r23	; 0x04
    680e:	6b 83       	std	Y+3, r22	; 0x03
    6810:	4d 83       	std	Y+5, r20	; 0x05
    6812:	3f 83       	std	Y+7, r19	; 0x07
    6814:	2e 83       	std	Y+6, r18	; 0x06
    6816:	19 87       	std	Y+9, r17	; 0x09
    6818:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    681a:	89 81       	ldd	r24, Y+1	; 0x01
    681c:	9a 81       	ldd	r25, Y+2	; 0x02
    681e:	49 96       	adiw	r24, 0x19	; 25
    6820:	2b 81       	ldd	r18, Y+3	; 0x03
    6822:	3c 81       	ldd	r19, Y+4	; 0x04
    6824:	b9 01       	movw	r22, r18
    6826:	48 e0       	ldi	r20, 0x08	; 8
    6828:	50 e0       	ldi	r21, 0x00	; 0
    682a:	0e 94 01 36 	call	0x6c02	; 0x6c02 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    682e:	e9 81       	ldd	r30, Y+1	; 0x01
    6830:	fa 81       	ldd	r31, Y+2	; 0x02
    6832:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    6834:	8d 81       	ldd	r24, Y+5	; 0x05
    6836:	85 30       	cpi	r24, 0x05	; 5
    6838:	10 f0       	brcs	.+4      	; 0x683e <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    683a:	84 e0       	ldi	r24, 0x04	; 4
    683c:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    683e:	e9 81       	ldd	r30, Y+1	; 0x01
    6840:	fa 81       	ldd	r31, Y+2	; 0x02
    6842:	8d 81       	ldd	r24, Y+5	; 0x05
    6844:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    6846:	89 81       	ldd	r24, Y+1	; 0x01
    6848:	9a 81       	ldd	r25, Y+2	; 0x02
    684a:	02 96       	adiw	r24, 0x02	; 2
    684c:	0e 94 82 25 	call	0x4b04	; 0x4b04 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    6850:	89 81       	ldd	r24, Y+1	; 0x01
    6852:	9a 81       	ldd	r25, Y+2	; 0x02
    6854:	0c 96       	adiw	r24, 0x0c	; 12
    6856:	0e 94 82 25 	call	0x4b04	; 0x4b04 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    685a:	e9 81       	ldd	r30, Y+1	; 0x01
    685c:	fa 81       	ldd	r31, Y+2	; 0x02
    685e:	89 81       	ldd	r24, Y+1	; 0x01
    6860:	9a 81       	ldd	r25, Y+2	; 0x02
    6862:	91 87       	std	Z+9, r25	; 0x09
    6864:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    6866:	8d 81       	ldd	r24, Y+5	; 0x05
    6868:	28 2f       	mov	r18, r24
    686a:	30 e0       	ldi	r19, 0x00	; 0
    686c:	85 e0       	ldi	r24, 0x05	; 5
    686e:	90 e0       	ldi	r25, 0x00	; 0
    6870:	82 1b       	sub	r24, r18
    6872:	93 0b       	sbc	r25, r19
    6874:	e9 81       	ldd	r30, Y+1	; 0x01
    6876:	fa 81       	ldd	r31, Y+2	; 0x02
    6878:	95 87       	std	Z+13, r25	; 0x0d
    687a:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    687c:	e9 81       	ldd	r30, Y+1	; 0x01
    687e:	fa 81       	ldd	r31, Y+2	; 0x02
    6880:	89 81       	ldd	r24, Y+1	; 0x01
    6882:	9a 81       	ldd	r25, Y+2	; 0x02
    6884:	93 8b       	std	Z+19, r25	; 0x13
    6886:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    6888:	29 96       	adiw	r28, 0x09	; 9
    688a:	0f b6       	in	r0, 0x3f	; 63
    688c:	f8 94       	cli
    688e:	de bf       	out	0x3e, r29	; 62
    6890:	0f be       	out	0x3f, r0	; 63
    6892:	cd bf       	out	0x3d, r28	; 61
    6894:	cf 91       	pop	r28
    6896:	df 91       	pop	r29
    6898:	1f 91       	pop	r17
    689a:	0f 91       	pop	r16
    689c:	08 95       	ret

0000689e <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    689e:	df 93       	push	r29
    68a0:	cf 93       	push	r28
    68a2:	0f 92       	push	r0
    68a4:	cd b7       	in	r28, 0x3d	; 61
    68a6:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    68a8:	19 82       	std	Y+1, r1	; 0x01
    68aa:	13 c0       	rjmp	.+38     	; 0x68d2 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    68ac:	89 81       	ldd	r24, Y+1	; 0x01
    68ae:	28 2f       	mov	r18, r24
    68b0:	30 e0       	ldi	r19, 0x00	; 0
    68b2:	c9 01       	movw	r24, r18
    68b4:	88 0f       	add	r24, r24
    68b6:	99 1f       	adc	r25, r25
    68b8:	88 0f       	add	r24, r24
    68ba:	99 1f       	adc	r25, r25
    68bc:	88 0f       	add	r24, r24
    68be:	99 1f       	adc	r25, r25
    68c0:	82 0f       	add	r24, r18
    68c2:	93 1f       	adc	r25, r19
    68c4:	88 5f       	subi	r24, 0xF8	; 248
    68c6:	99 4f       	sbci	r25, 0xF9	; 249
    68c8:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    68cc:	89 81       	ldd	r24, Y+1	; 0x01
    68ce:	8f 5f       	subi	r24, 0xFF	; 255
    68d0:	89 83       	std	Y+1, r24	; 0x01
    68d2:	89 81       	ldd	r24, Y+1	; 0x01
    68d4:	85 30       	cpi	r24, 0x05	; 5
    68d6:	50 f3       	brcs	.-44     	; 0x68ac <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    68d8:	85 e3       	ldi	r24, 0x35	; 53
    68da:	96 e0       	ldi	r25, 0x06	; 6
    68dc:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    68e0:	8e e3       	ldi	r24, 0x3E	; 62
    68e2:	96 e0       	ldi	r25, 0x06	; 6
    68e4:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    68e8:	8b e4       	ldi	r24, 0x4B	; 75
    68ea:	96 e0       	ldi	r25, 0x06	; 6
    68ec:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    68f0:	84 e5       	ldi	r24, 0x54	; 84
    68f2:	96 e0       	ldi	r25, 0x06	; 6
    68f4:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    68f8:	85 e3       	ldi	r24, 0x35	; 53
    68fa:	96 e0       	ldi	r25, 0x06	; 6
    68fc:	90 93 48 06 	sts	0x0648, r25
    6900:	80 93 47 06 	sts	0x0647, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    6904:	8e e3       	ldi	r24, 0x3E	; 62
    6906:	96 e0       	ldi	r25, 0x06	; 6
    6908:	90 93 4a 06 	sts	0x064A, r25
    690c:	80 93 49 06 	sts	0x0649, r24
}
    6910:	0f 90       	pop	r0
    6912:	cf 91       	pop	r28
    6914:	df 91       	pop	r29
    6916:	08 95       	ret

00006918 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    6918:	df 93       	push	r29
    691a:	cf 93       	push	r28
    691c:	00 d0       	rcall	.+0      	; 0x691e <prvCheckTasksWaitingTermination+0x6>
    691e:	0f 92       	push	r0
    6920:	cd b7       	in	r28, 0x3d	; 61
    6922:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    6924:	80 91 fc 05 	lds	r24, 0x05FC
    6928:	88 23       	and	r24, r24
    692a:	71 f1       	breq	.+92     	; 0x6988 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    692c:	0e 94 ca 30 	call	0x6194	; 0x6194 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    6930:	80 91 54 06 	lds	r24, 0x0654
    6934:	1b 82       	std	Y+3, r1	; 0x03
    6936:	88 23       	and	r24, r24
    6938:	11 f4       	brne	.+4      	; 0x693e <prvCheckTasksWaitingTermination+0x26>
    693a:	81 e0       	ldi	r24, 0x01	; 1
    693c:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    693e:	0e 94 d6 30 	call	0x61ac	; 0x61ac <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    6942:	8b 81       	ldd	r24, Y+3	; 0x03
    6944:	88 23       	and	r24, r24
    6946:	01 f5       	brne	.+64     	; 0x6988 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    6948:	0f b6       	in	r0, 0x3f	; 63
    694a:	f8 94       	cli
    694c:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    694e:	e0 91 59 06 	lds	r30, 0x0659
    6952:	f0 91 5a 06 	lds	r31, 0x065A
    6956:	86 81       	ldd	r24, Z+6	; 0x06
    6958:	97 81       	ldd	r25, Z+7	; 0x07
    695a:	9a 83       	std	Y+2, r25	; 0x02
    695c:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    695e:	89 81       	ldd	r24, Y+1	; 0x01
    6960:	9a 81       	ldd	r25, Y+2	; 0x02
    6962:	02 96       	adiw	r24, 0x02	; 2
    6964:	0e 94 4a 26 	call	0x4c94	; 0x4c94 <vListRemove>
					--uxCurrentNumberOfTasks;
    6968:	80 91 fd 05 	lds	r24, 0x05FD
    696c:	81 50       	subi	r24, 0x01	; 1
    696e:	80 93 fd 05 	sts	0x05FD, r24
					--uxTasksDeleted;
    6972:	80 91 fc 05 	lds	r24, 0x05FC
    6976:	81 50       	subi	r24, 0x01	; 1
    6978:	80 93 fc 05 	sts	0x05FC, r24
				}
				taskEXIT_CRITICAL();
    697c:	0f 90       	pop	r0
    697e:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    6980:	89 81       	ldd	r24, Y+1	; 0x01
    6982:	9a 81       	ldd	r25, Y+2	; 0x02
    6984:	0e 94 63 35 	call	0x6ac6	; 0x6ac6 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    6988:	0f 90       	pop	r0
    698a:	0f 90       	pop	r0
    698c:	0f 90       	pop	r0
    698e:	cf 91       	pop	r28
    6990:	df 91       	pop	r29
    6992:	08 95       	ret

00006994 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    6994:	df 93       	push	r29
    6996:	cf 93       	push	r28
    6998:	00 d0       	rcall	.+0      	; 0x699a <prvAddCurrentTaskToDelayedList+0x6>
    699a:	cd b7       	in	r28, 0x3d	; 61
    699c:	de b7       	in	r29, 0x3e	; 62
    699e:	9a 83       	std	Y+2, r25	; 0x02
    69a0:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    69a2:	e0 91 fa 05 	lds	r30, 0x05FA
    69a6:	f0 91 fb 05 	lds	r31, 0x05FB
    69aa:	89 81       	ldd	r24, Y+1	; 0x01
    69ac:	9a 81       	ldd	r25, Y+2	; 0x02
    69ae:	93 83       	std	Z+3, r25	; 0x03
    69b0:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    69b2:	20 91 fe 05 	lds	r18, 0x05FE
    69b6:	30 91 ff 05 	lds	r19, 0x05FF
    69ba:	89 81       	ldd	r24, Y+1	; 0x01
    69bc:	9a 81       	ldd	r25, Y+2	; 0x02
    69be:	82 17       	cp	r24, r18
    69c0:	93 07       	cpc	r25, r19
    69c2:	70 f4       	brcc	.+28     	; 0x69e0 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    69c4:	80 91 49 06 	lds	r24, 0x0649
    69c8:	90 91 4a 06 	lds	r25, 0x064A
    69cc:	20 91 fa 05 	lds	r18, 0x05FA
    69d0:	30 91 fb 05 	lds	r19, 0x05FB
    69d4:	2e 5f       	subi	r18, 0xFE	; 254
    69d6:	3f 4f       	sbci	r19, 0xFF	; 255
    69d8:	b9 01       	movw	r22, r18
    69da:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <vListInsert>
    69de:	1e c0       	rjmp	.+60     	; 0x6a1c <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    69e0:	40 91 47 06 	lds	r20, 0x0647
    69e4:	50 91 48 06 	lds	r21, 0x0648
    69e8:	80 91 fa 05 	lds	r24, 0x05FA
    69ec:	90 91 fb 05 	lds	r25, 0x05FB
    69f0:	9c 01       	movw	r18, r24
    69f2:	2e 5f       	subi	r18, 0xFE	; 254
    69f4:	3f 4f       	sbci	r19, 0xFF	; 255
    69f6:	ca 01       	movw	r24, r20
    69f8:	b9 01       	movw	r22, r18
    69fa:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    69fe:	20 91 cb 01 	lds	r18, 0x01CB
    6a02:	30 91 cc 01 	lds	r19, 0x01CC
    6a06:	89 81       	ldd	r24, Y+1	; 0x01
    6a08:	9a 81       	ldd	r25, Y+2	; 0x02
    6a0a:	82 17       	cp	r24, r18
    6a0c:	93 07       	cpc	r25, r19
    6a0e:	30 f4       	brcc	.+12     	; 0x6a1c <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    6a10:	89 81       	ldd	r24, Y+1	; 0x01
    6a12:	9a 81       	ldd	r25, Y+2	; 0x02
    6a14:	90 93 cc 01 	sts	0x01CC, r25
    6a18:	80 93 cb 01 	sts	0x01CB, r24
		}
	}
}
    6a1c:	0f 90       	pop	r0
    6a1e:	0f 90       	pop	r0
    6a20:	cf 91       	pop	r28
    6a22:	df 91       	pop	r29
    6a24:	08 95       	ret

00006a26 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    6a26:	df 93       	push	r29
    6a28:	cf 93       	push	r28
    6a2a:	cd b7       	in	r28, 0x3d	; 61
    6a2c:	de b7       	in	r29, 0x3e	; 62
    6a2e:	28 97       	sbiw	r28, 0x08	; 8
    6a30:	0f b6       	in	r0, 0x3f	; 63
    6a32:	f8 94       	cli
    6a34:	de bf       	out	0x3e, r29	; 62
    6a36:	0f be       	out	0x3f, r0	; 63
    6a38:	cd bf       	out	0x3d, r28	; 61
    6a3a:	9c 83       	std	Y+4, r25	; 0x04
    6a3c:	8b 83       	std	Y+3, r24	; 0x03
    6a3e:	7e 83       	std	Y+6, r23	; 0x06
    6a40:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    6a42:	81 e2       	ldi	r24, 0x21	; 33
    6a44:	90 e0       	ldi	r25, 0x00	; 0
    6a46:	0e 94 ec 24 	call	0x49d8	; 0x49d8 <pvPortMalloc>
    6a4a:	9a 83       	std	Y+2, r25	; 0x02
    6a4c:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    6a4e:	89 81       	ldd	r24, Y+1	; 0x01
    6a50:	9a 81       	ldd	r25, Y+2	; 0x02
    6a52:	00 97       	sbiw	r24, 0x00	; 0
    6a54:	69 f1       	breq	.+90     	; 0x6ab0 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    6a56:	8d 81       	ldd	r24, Y+5	; 0x05
    6a58:	9e 81       	ldd	r25, Y+6	; 0x06
    6a5a:	00 97       	sbiw	r24, 0x00	; 0
    6a5c:	39 f4       	brne	.+14     	; 0x6a6c <prvAllocateTCBAndStack+0x46>
    6a5e:	8b 81       	ldd	r24, Y+3	; 0x03
    6a60:	9c 81       	ldd	r25, Y+4	; 0x04
    6a62:	0e 94 ec 24 	call	0x49d8	; 0x49d8 <pvPortMalloc>
    6a66:	98 87       	std	Y+8, r25	; 0x08
    6a68:	8f 83       	std	Y+7, r24	; 0x07
    6a6a:	04 c0       	rjmp	.+8      	; 0x6a74 <prvAllocateTCBAndStack+0x4e>
    6a6c:	8d 81       	ldd	r24, Y+5	; 0x05
    6a6e:	9e 81       	ldd	r25, Y+6	; 0x06
    6a70:	98 87       	std	Y+8, r25	; 0x08
    6a72:	8f 83       	std	Y+7, r24	; 0x07
    6a74:	e9 81       	ldd	r30, Y+1	; 0x01
    6a76:	fa 81       	ldd	r31, Y+2	; 0x02
    6a78:	8f 81       	ldd	r24, Y+7	; 0x07
    6a7a:	98 85       	ldd	r25, Y+8	; 0x08
    6a7c:	90 8f       	std	Z+24, r25	; 0x18
    6a7e:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    6a80:	e9 81       	ldd	r30, Y+1	; 0x01
    6a82:	fa 81       	ldd	r31, Y+2	; 0x02
    6a84:	87 89       	ldd	r24, Z+23	; 0x17
    6a86:	90 8d       	ldd	r25, Z+24	; 0x18
    6a88:	00 97       	sbiw	r24, 0x00	; 0
    6a8a:	39 f4       	brne	.+14     	; 0x6a9a <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    6a8c:	89 81       	ldd	r24, Y+1	; 0x01
    6a8e:	9a 81       	ldd	r25, Y+2	; 0x02
    6a90:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortFree>
			pxNewTCB = NULL;
    6a94:	1a 82       	std	Y+2, r1	; 0x02
    6a96:	19 82       	std	Y+1, r1	; 0x01
    6a98:	0b c0       	rjmp	.+22     	; 0x6ab0 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    6a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    6a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    6a9e:	87 89       	ldd	r24, Z+23	; 0x17
    6aa0:	90 8d       	ldd	r25, Z+24	; 0x18
    6aa2:	2b 81       	ldd	r18, Y+3	; 0x03
    6aa4:	3c 81       	ldd	r19, Y+4	; 0x04
    6aa6:	65 ea       	ldi	r22, 0xA5	; 165
    6aa8:	70 e0       	ldi	r23, 0x00	; 0
    6aaa:	a9 01       	movw	r20, r18
    6aac:	0e 94 fa 35 	call	0x6bf4	; 0x6bf4 <memset>
		}
	}

	return pxNewTCB;
    6ab0:	89 81       	ldd	r24, Y+1	; 0x01
    6ab2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6ab4:	28 96       	adiw	r28, 0x08	; 8
    6ab6:	0f b6       	in	r0, 0x3f	; 63
    6ab8:	f8 94       	cli
    6aba:	de bf       	out	0x3e, r29	; 62
    6abc:	0f be       	out	0x3f, r0	; 63
    6abe:	cd bf       	out	0x3d, r28	; 61
    6ac0:	cf 91       	pop	r28
    6ac2:	df 91       	pop	r29
    6ac4:	08 95       	ret

00006ac6 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    6ac6:	df 93       	push	r29
    6ac8:	cf 93       	push	r28
    6aca:	00 d0       	rcall	.+0      	; 0x6acc <prvDeleteTCB+0x6>
    6acc:	cd b7       	in	r28, 0x3d	; 61
    6ace:	de b7       	in	r29, 0x3e	; 62
    6ad0:	9a 83       	std	Y+2, r25	; 0x02
    6ad2:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    6ad4:	e9 81       	ldd	r30, Y+1	; 0x01
    6ad6:	fa 81       	ldd	r31, Y+2	; 0x02
    6ad8:	87 89       	ldd	r24, Z+23	; 0x17
    6ada:	90 8d       	ldd	r25, Z+24	; 0x18
    6adc:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortFree>
		vPortFree( pxTCB );
    6ae0:	89 81       	ldd	r24, Y+1	; 0x01
    6ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    6ae4:	0e 94 32 25 	call	0x4a64	; 0x4a64 <vPortFree>
	}
    6ae8:	0f 90       	pop	r0
    6aea:	0f 90       	pop	r0
    6aec:	cf 91       	pop	r28
    6aee:	df 91       	pop	r29
    6af0:	08 95       	ret

00006af2 <__mulsi3>:
    6af2:	62 9f       	mul	r22, r18
    6af4:	d0 01       	movw	r26, r0
    6af6:	73 9f       	mul	r23, r19
    6af8:	f0 01       	movw	r30, r0
    6afa:	82 9f       	mul	r24, r18
    6afc:	e0 0d       	add	r30, r0
    6afe:	f1 1d       	adc	r31, r1
    6b00:	64 9f       	mul	r22, r20
    6b02:	e0 0d       	add	r30, r0
    6b04:	f1 1d       	adc	r31, r1
    6b06:	92 9f       	mul	r25, r18
    6b08:	f0 0d       	add	r31, r0
    6b0a:	83 9f       	mul	r24, r19
    6b0c:	f0 0d       	add	r31, r0
    6b0e:	74 9f       	mul	r23, r20
    6b10:	f0 0d       	add	r31, r0
    6b12:	65 9f       	mul	r22, r21
    6b14:	f0 0d       	add	r31, r0
    6b16:	99 27       	eor	r25, r25
    6b18:	72 9f       	mul	r23, r18
    6b1a:	b0 0d       	add	r27, r0
    6b1c:	e1 1d       	adc	r30, r1
    6b1e:	f9 1f       	adc	r31, r25
    6b20:	63 9f       	mul	r22, r19
    6b22:	b0 0d       	add	r27, r0
    6b24:	e1 1d       	adc	r30, r1
    6b26:	f9 1f       	adc	r31, r25
    6b28:	bd 01       	movw	r22, r26
    6b2a:	cf 01       	movw	r24, r30
    6b2c:	11 24       	eor	r1, r1
    6b2e:	08 95       	ret

00006b30 <__udivmodsi4>:
    6b30:	a1 e2       	ldi	r26, 0x21	; 33
    6b32:	1a 2e       	mov	r1, r26
    6b34:	aa 1b       	sub	r26, r26
    6b36:	bb 1b       	sub	r27, r27
    6b38:	fd 01       	movw	r30, r26
    6b3a:	0d c0       	rjmp	.+26     	; 0x6b56 <__udivmodsi4_ep>

00006b3c <__udivmodsi4_loop>:
    6b3c:	aa 1f       	adc	r26, r26
    6b3e:	bb 1f       	adc	r27, r27
    6b40:	ee 1f       	adc	r30, r30
    6b42:	ff 1f       	adc	r31, r31
    6b44:	a2 17       	cp	r26, r18
    6b46:	b3 07       	cpc	r27, r19
    6b48:	e4 07       	cpc	r30, r20
    6b4a:	f5 07       	cpc	r31, r21
    6b4c:	20 f0       	brcs	.+8      	; 0x6b56 <__udivmodsi4_ep>
    6b4e:	a2 1b       	sub	r26, r18
    6b50:	b3 0b       	sbc	r27, r19
    6b52:	e4 0b       	sbc	r30, r20
    6b54:	f5 0b       	sbc	r31, r21

00006b56 <__udivmodsi4_ep>:
    6b56:	66 1f       	adc	r22, r22
    6b58:	77 1f       	adc	r23, r23
    6b5a:	88 1f       	adc	r24, r24
    6b5c:	99 1f       	adc	r25, r25
    6b5e:	1a 94       	dec	r1
    6b60:	69 f7       	brne	.-38     	; 0x6b3c <__udivmodsi4_loop>
    6b62:	60 95       	com	r22
    6b64:	70 95       	com	r23
    6b66:	80 95       	com	r24
    6b68:	90 95       	com	r25
    6b6a:	9b 01       	movw	r18, r22
    6b6c:	ac 01       	movw	r20, r24
    6b6e:	bd 01       	movw	r22, r26
    6b70:	cf 01       	movw	r24, r30
    6b72:	08 95       	ret

00006b74 <__prologue_saves__>:
    6b74:	2f 92       	push	r2
    6b76:	3f 92       	push	r3
    6b78:	4f 92       	push	r4
    6b7a:	5f 92       	push	r5
    6b7c:	6f 92       	push	r6
    6b7e:	7f 92       	push	r7
    6b80:	8f 92       	push	r8
    6b82:	9f 92       	push	r9
    6b84:	af 92       	push	r10
    6b86:	bf 92       	push	r11
    6b88:	cf 92       	push	r12
    6b8a:	df 92       	push	r13
    6b8c:	ef 92       	push	r14
    6b8e:	ff 92       	push	r15
    6b90:	0f 93       	push	r16
    6b92:	1f 93       	push	r17
    6b94:	cf 93       	push	r28
    6b96:	df 93       	push	r29
    6b98:	cd b7       	in	r28, 0x3d	; 61
    6b9a:	de b7       	in	r29, 0x3e	; 62
    6b9c:	ca 1b       	sub	r28, r26
    6b9e:	db 0b       	sbc	r29, r27
    6ba0:	0f b6       	in	r0, 0x3f	; 63
    6ba2:	f8 94       	cli
    6ba4:	de bf       	out	0x3e, r29	; 62
    6ba6:	0f be       	out	0x3f, r0	; 63
    6ba8:	cd bf       	out	0x3d, r28	; 61
    6baa:	09 94       	ijmp

00006bac <__epilogue_restores__>:
    6bac:	2a 88       	ldd	r2, Y+18	; 0x12
    6bae:	39 88       	ldd	r3, Y+17	; 0x11
    6bb0:	48 88       	ldd	r4, Y+16	; 0x10
    6bb2:	5f 84       	ldd	r5, Y+15	; 0x0f
    6bb4:	6e 84       	ldd	r6, Y+14	; 0x0e
    6bb6:	7d 84       	ldd	r7, Y+13	; 0x0d
    6bb8:	8c 84       	ldd	r8, Y+12	; 0x0c
    6bba:	9b 84       	ldd	r9, Y+11	; 0x0b
    6bbc:	aa 84       	ldd	r10, Y+10	; 0x0a
    6bbe:	b9 84       	ldd	r11, Y+9	; 0x09
    6bc0:	c8 84       	ldd	r12, Y+8	; 0x08
    6bc2:	df 80       	ldd	r13, Y+7	; 0x07
    6bc4:	ee 80       	ldd	r14, Y+6	; 0x06
    6bc6:	fd 80       	ldd	r15, Y+5	; 0x05
    6bc8:	0c 81       	ldd	r16, Y+4	; 0x04
    6bca:	1b 81       	ldd	r17, Y+3	; 0x03
    6bcc:	aa 81       	ldd	r26, Y+2	; 0x02
    6bce:	b9 81       	ldd	r27, Y+1	; 0x01
    6bd0:	ce 0f       	add	r28, r30
    6bd2:	d1 1d       	adc	r29, r1
    6bd4:	0f b6       	in	r0, 0x3f	; 63
    6bd6:	f8 94       	cli
    6bd8:	de bf       	out	0x3e, r29	; 62
    6bda:	0f be       	out	0x3f, r0	; 63
    6bdc:	cd bf       	out	0x3d, r28	; 61
    6bde:	ed 01       	movw	r28, r26
    6be0:	08 95       	ret

00006be2 <memcpy>:
    6be2:	fb 01       	movw	r30, r22
    6be4:	dc 01       	movw	r26, r24
    6be6:	02 c0       	rjmp	.+4      	; 0x6bec <memcpy+0xa>
    6be8:	01 90       	ld	r0, Z+
    6bea:	0d 92       	st	X+, r0
    6bec:	41 50       	subi	r20, 0x01	; 1
    6bee:	50 40       	sbci	r21, 0x00	; 0
    6bf0:	d8 f7       	brcc	.-10     	; 0x6be8 <memcpy+0x6>
    6bf2:	08 95       	ret

00006bf4 <memset>:
    6bf4:	dc 01       	movw	r26, r24
    6bf6:	01 c0       	rjmp	.+2      	; 0x6bfa <memset+0x6>
    6bf8:	6d 93       	st	X+, r22
    6bfa:	41 50       	subi	r20, 0x01	; 1
    6bfc:	50 40       	sbci	r21, 0x00	; 0
    6bfe:	e0 f7       	brcc	.-8      	; 0x6bf8 <memset+0x4>
    6c00:	08 95       	ret

00006c02 <strncpy>:
    6c02:	fb 01       	movw	r30, r22
    6c04:	dc 01       	movw	r26, r24
    6c06:	41 50       	subi	r20, 0x01	; 1
    6c08:	50 40       	sbci	r21, 0x00	; 0
    6c0a:	48 f0       	brcs	.+18     	; 0x6c1e <strncpy+0x1c>
    6c0c:	01 90       	ld	r0, Z+
    6c0e:	0d 92       	st	X+, r0
    6c10:	00 20       	and	r0, r0
    6c12:	c9 f7       	brne	.-14     	; 0x6c06 <strncpy+0x4>
    6c14:	01 c0       	rjmp	.+2      	; 0x6c18 <strncpy+0x16>
    6c16:	1d 92       	st	X+, r1
    6c18:	41 50       	subi	r20, 0x01	; 1
    6c1a:	50 40       	sbci	r21, 0x00	; 0
    6c1c:	e0 f7       	brcc	.-8      	; 0x6c16 <strncpy+0x14>
    6c1e:	08 95       	ret

00006c20 <_exit>:
    6c20:	f8 94       	cli

00006c22 <__stop_program>:
    6c22:	ff cf       	rjmp	.-2      	; 0x6c22 <__stop_program>
